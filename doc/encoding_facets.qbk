[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/v0/custom_encoding_error_handling.cpp]

[section Encoding UTF-8]
[h4 The `u8encoder` class template]

``
template <typename F>
// requires requires(F func, output_writer<char>& out, std::size_t count)
// {
//    { func(out, count) } -> bool;
// }
class u8encoder: public encoder<char>
{

public:

    u8encoder(F error_handling_function, bool wtf8 = false);

    u8encoder(const u8encoder& other);

    u8encoder(u8encoder&& other);

    ~u8encoder();

    u8encoder &  wtf8(bool _ = true) &;
    u8encoder && wtf8(bool _ = true) &&;
    u8encoder    wtf8(bool _ = true) const &;

    std::size_t length(char32_t ch) const noexcept override;

    bool encode
        ( output_writer<char>& destination
        , std::size_t count
        , char32_t ch
        ) const override;
};

``
`u8encoder<F>::encode(destination, count, ch)` writes `count` times into `destination` the code point `ch`, if it is a valid code point. Otherwise it calls and returns `error_handling_function(destination, count)`. It return `false` on the ocurrence of a such failure that there is not point in writing anything else.

The `wtf8` flag determinates wheter the surrogates halves ( the code points in the range U+D800 to U+DFFF ) are considered valid ( if it's `true` then they valid ). The code points greater than U+10FFFF are aways considered invalid. 


[h4 The `make_u8encoder` helper functions]
[#put_utf8_replacement_char]
``
bool put_utf8_replacement_char
    ( output_writer<char>& destination
    , std::size_t count
    )
{
    // writes u8"\uFFFE" count times
    return destination.repeat(count, '\xEF', '\xBF', '\xBD'); 
}

auto make_u8encoder(bool wtf8 = false)
{
    using F = bool(*)(output_writer<char>&, std::size_t>;
    return u8encoder<F>{put_utf8_replacement_char, wtf8};
}
``
``
template <typename F>
auto make_u8encoder(F error_handling_func, bool wtf8 = false)
{
    return u8encoder<F>{error_handling_func, wtf8};
}
``

[h4 The default encoder for narrow stings]

By default, narrow strings are encoded using `u8encoder` with the `wtf8` flag set to `false` and the `error_handling_function` equal to `to_ut8_put_replacement_char`. It's is the same of the result of `make_u8encoder(false)`.

[endsect]
[section Encoding UTF-16]

[h4 The `u16encoder` class template]

``
template <typename CharT, typename F>
// requires requires(F func, output_writer<CharT>& out, std::size_t count)
// {
//    { func(out, count) } -> bool;
// }
class u16encoder: public encoder<CharT>
{

public:

    u16encoder(F error_handling_function, bool tolerate_surrogates = false);

    u16encoder(const u16encoder& cp);

    u16encoder(u16encoder&& mv);

    ~u16encoder();

    u16encoder &  tolerate_surrogates(bool b = true) &;
    u16encoder && tolerate_surrogates(bool b = true) &&;
    u16encoder    tolerate_surrogates(bool b = true) const &;

    std::size_t length(char32_t ch) const noexcept override;

    bool encode
        ( output_writer<CharT>& destination
        , std::size_t count
        , char32_t ch
        ) const override;

};
``
`u16encoder<F>::encode(destination, count, ch)`  writes `count` times into `destination` the code point `ch`, if it is a valid code point. Otherwise it calls and returns `error_handling_function(destination, count)`. `false` is returned on the ocurrence of a such failure that there is not point in writing anything else into `destination`.

If the the flag `tolerate_surrogates` is `true`, then the code points in the range U+D800 to U+DFFF (the surrogates halves) are allowed, and are translated just as the other code points below U+10000. The code points greater than U+10FFFF are aways considered invalid.

[h4 The `make_u16encoder` helper functions]
[#put_utf16_replacement_char]
``
template <typename CharT>
bool put_utf16_replacement_char
    ( output_writer<CharT>& destination
    , std::size_t count
    )
{
    return destination.repeat(count, 0xFFFE); 
}

template <typename CharT>
auto make_u16encoder(bool tolerate_surrogates = false)
{
    using F = bool(*)(output_writer<CharT>&, std::size_t>;
    return u16encoder<CharT, F>{put_utf16_replacement_char, tolerate_surrogates};
}
``
``
template <typename CharT, typename F>
auto make_u16encoder(F error_handling_func, bool tolerate_surrogates = false)
{
    return u8encoder<F>{error_handling_func, tolerate_surrogates};
}
``

[h4 The default UTF-16 encoder]

By default, UTF-16 is encoded using `u16encoder` with the `tolerate_surrogates` flag set to `false` and the `error_handling_function` equal to `put_utf16_replacement_char`.

[endsect]

[section Customizing the encoder error handling function]


[/
The function object that handles the invalid code point in `u8encoder` and `u16encoder` receives two paramenters:
]

Both `u8encoder` and `u16encoder` receive in their constructors a function object [~`error_handling_function`] that handles invalid code points. This function receives two parameters:

* the [~destination], whose type is [link output_writer `output_writer`]`<CharT>&`
* the [~count], whose type is std::size_t. This is the number of times the failed code point was meant to be written if it was valid.

Its return is of type  `bool` and tells whether the writing process shall continue after this failure.

There are basically three kinds of error handler function that you can implement. If you want to: 

* replace the invalid code point by some other character, then write this character into [~destination] using the member functions of [link output_writer `output_writer`]. Take [link put_utf8_replacement_char put_utf8_replacement_char] and [link put_utf16_replacement_char put_utf16_replacement_char] as examples.
* cause an error code, then call `destination.set_error(`[~code]`)` and then return `false`.
* throw an exception, then, well, just throw it.

[caution The error handler function must not write into `destination` more than `(4 * `[~count]`)` bytes ( or `(4 * `[~count]`)` instances of `char` in the case of `u8encoder` or `(2 * `[~count]`)` instances of [~CharT] in the case of `u16encoder`). That's because `u8encoder::length(ch)` and `u16encoder::lenght(ch)` return `4` and `2` respectively when `ch` is an invalid code point. And this value in turn is used to calculate the total length to be passed to the [link OutputWriter_reserve `reserve`] function]

[h4 Example]

[custom_encoding_error_handling]

[endsect]
[section How to implement your own encoder]
You need to create a non abstract, [@http://en.cppreference.com/w/cpp/concept/CopyConstructible CopyConstructible] class that inherits from [^encoder<][~CharT][^>], where [~CharT] is `char`, `wchar_t`, `char16_t` or `char32_t`. An instance of such class is a facet object.

[h4 The `encoder` class template]
``
template <typename CharT> class encoder
{
public:

    using category = encoder_tag<CharT>;

    virtual ~encoder();

    virtual std::size_t length(char32_t ch) const = 0;

    virtual bool encode
        ( output_writer<CharT>& destination
        , std::size_t count
        , char32_t ch
        ) const = 0;

};
``

* The [*`encode`] member function shall write the code point `ch` into `destination` `count` times. It shall return `true` on success. Returning `false` will prevent subsequent calls.

* The [*`length`] member function shall return how many instance of `CharT` are needed to represent code point `ch`.

[endsect]
