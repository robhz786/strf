[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/v0/decoding_facets.cpp]

[section Overview]

[warning
This library is not part of the Boost C++ Libraries yet.
It is still in and early stage of development and subject to change without
preserving backwards compatibility.
]

Boost.Stringify is a locale-independent format library with some unique features.


[h3 Why ( and why not ) to use Boost.Stringify]

[h4 Pros]

* Provides some nice [link special_input_types.special_input_types special input types].
* It supports many [link output_types.output_types destination types]
* It is highly extensible.
    * When adding [link extend_input.extend_input new input types], you can create your own new format options, as well as new [link section_facets facet categories]
    * You can also add [link extend_output.extend_output new destination types]. If you work, for instance, with some non standard string type ( as is usual in C++ ), you will probably find it easy to extend Boost.Stringify to write into this string type.


[/
* Any ill-specified formatting ( like applying hexadecimal format to string ) leads to compilation errors instead of run-time errors.
]
* It's UTF-8 and UTF-16 friendly:
    * Support for all character types ( `char`, `wchar_t`, `char32_t` and `char16_t`)
    * You can customize [link facet_width_calculation.width_calculation how the width is calculated], choosing more accurate methods than just assuming that width equals to length.
    * The [link format_functions fill] and [link numpunct punctuation] characters are `char32_t`, which gives you options beyond the ASCII table ( when the destination character type is `char` )
    * It provides an easy to convert one encoding to another ( and you can customize how such conversions are done ):  [input_output_different_char_types]

[h4 Cons]

* [link benchmarks.benchmarks.compilation_performance Code bloat]
* Requires a C++14 compiler
* No support for date and time input (yet)
* Tends to be more verbose than libraries based on format string ( like printf )


[h3 As static library or header-only]

[def __STRINGIFY_CPP__
[@../../build/stringify.cpp build/stringify.cpp]
]

By default Boost.Stringify is prepared to be used as a header-only library. But it can also be used as a static library. This reduces the [link benchmarks.benchmarks.compilation_performance code bloat].

[/
And in order to build the library, since there is only one source file ( __STRINGIFY_CPP__ ), probably the best way it to just copy this file to your own project, and configure the use the build system of your choice to generate the library file from it.
]

Probably the best way build the library is to create a project in the build system of your own choice to do this. This should be easy, since there is only one source file ( __STRINGIFY_CPP__ ) to compile



Also, the code that uses it as static library must have the macro  `BOOST_STRINGIFY_NOT_HEADER_ONLY` defined.




[h3 Compilers]

In its current state, Boost.Stringify is known to work in the following compilers:

* Clang 3.8 (with [^--std=c++14] option )
* GCC 6 (with [^--std=c++14] option ) and 7
* Visual Studio 2017 15.2

However, more recent compilers may be necessary as the library evolves.

[endsect]

