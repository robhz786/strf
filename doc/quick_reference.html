<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>The Strf formatting library - Quit Reference</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>The Strf formatting library - Quit Reference</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#usage_syntax">1. Main usage syntax</a>
<ul class="sectlevel2">
<li><a href="#destinations">1.1. Destinations</a></li>
<li><a href="#reserve">1.2. Reserving</a></li>
<li><a href="#tr_string">1.3. Tr-string</a></li>
<li><a href="#facets">1.4. Facets</a></li>
</ul>
</li>
<li><a href="#numpunct">2. Numeric punctuation</a></li>
<li><a href="#lettercase">3. Letter case</a></li>
<li><a href="#encoding">4. Character encodings</a>
<ul class="sectlevel2">
<li><a href="#_class_template_code_encoding_code">4.1. Class template <code>encoding</code></a></li>
<li><a href="#_supported_encodings">4.2. Supported encodings</a></li>
<li><a href="#encoding_conversion">4.3. Encoding conversion</a></li>
<li><a href="#encoding_error">4.4. Encoding error handling</a></li>
<li><a href="#surrogate_policy">4.5. Surrogates tolerance</a></li>
</ul>
</li>
<li><a href="#width_calculation">5. Width Calculation</a></li>
<li><a href="#format_functions">6. Format functions</a></li>
<li><a href="#input_types">7. Input types</a>
<ul class="sectlevel2">
<li><a href="#_integers">7.1. Integers</a></li>
<li><a href="#_floating_points">7.2. Floating Points</a></li>
<li><a href="#__code_const_void_code">7.3. <code>const void*</code></a></li>
<li><a href="#_single_characters">7.4. Single characters</a></li>
<li><a href="#_strings">7.5. Strings</a></li>
<li><a href="#_ranges">7.6. Ranges</a></li>
<li><a href="#joins">7.7. Joins</a></li>
<li><a href="#_facets">7.8. Facets</a></li>
</ul>
</li>
<li><a href="#_extending_the_library">8. Extending the library</a>
<ul class="sectlevel2">
<li><a href="#_adding_output_types">8.1. Adding output types</a></li>
<li><a href="#_adding_input_typess">8.2. Adding input typess</a></li>
<li><a href="#_adding_facets">8.3. Adding Facets</a></li>
<li><a href="#_adding_encodings">8.4. Adding encodings</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="usage_syntax">1. Main usage syntax</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<object type="image/svg+xml" data="syntax.svg"><span class="alt">syntax</span></object>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">#include &lt;strf.hpp&gt;
#include &lt;cassert&gt;

std::string sample()
{
    int x = 100;

    std::string str =
        strf::to_string // the destination
        .reserve(100)   // The reserved capacity in the created string
        .with(strf::monotonic_grouping&lt;10&gt;{3}) // numeric punctuation
        .tr("{0} times {0} is equal to {1}", x, x*x);

    assert(str.capacity() &gt;= 100);
    assert(str == "100 times 100 is equal to 10,000");
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="destinations">1.1. Destinations</h3>
<div class="paragraph">
<p>The "destination" is what defines the effect and also the return type of the main usage syntax, as listed below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr /*...*/ to_string;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Creates a string object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>std::string</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr /*...*/ to_u16string;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Creates a string object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>std::u16string</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr /*...*/ to_u32string;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Creates a string object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>std::u32string</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Support reserve
</td>
<td class="hdlist2">
<p>Yes.</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr /*...*/ to_wstring;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Creates a string object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>std::wstring</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Support reserve
</td>
<td class="hdlist2">
<p>Yes.</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT, typename Traits, typename Alloc&gt;
constexpr /*...*/ to_basic_string;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Creates a string object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>std::basic_string&lt;CharT, Traits, Alloc&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Support reserve
</td>
<td class="hdlist2">
<p>Yes.</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT, typename Traits, typename Alloc&gt;
/*...*/ append (std::basic_string&lt;CharT, Traits, Alloc&gt;&amp; str);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Appends the generated content to <code>str</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>void</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Support reserve
</td>
<td class="hdlist2">
<p>Yes. The effect is to call <code>str.reserve(std.size() + size)</code>, where <code>size</code> is the value passed to <code>reserve</code> function in the main usage syntax or the calculated content&#8217;s size when <code>reserve_calc</code> is used.</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT, typename Traits, typename Alloc&gt;
/*...*/ assign (std::basic_string&lt;CharT, Traits, Alloc&gt;&amp; str);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Assign <code>str</code> to the generated content.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>void</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Support reserve
</td>
<td class="hdlist2">
<p>Yes.</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">/*...*/ to ( char*     dest, std::size_t count );
/*...*/ to ( char8_t*  dest, std::size_t count );
/*...*/ to ( char16_t* dest, std::size_t count );
/*...*/ to ( char32_t* dest, std::size_t count );
/*...*/ to ( wchar_t*  dest, std::size_t count );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requirements
</td>
<td class="hdlist2">
<p><code>count &gt; 0</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>Write the generated content to <code>dest</code>.</p>
</li>
<li>
<p>Write no more than <code>count</code> characters including the termination character.</p>
</li>
<li>
<p>The terminations character is always written.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>struct /*...*/ { std::decltype(dest) ptr; bool truncated; };</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>ptr</code> points to the last written position. Hence <code>*ptr</code> is always equal to <code>'\0'</code></p>
</li>
<li>
<p><code>truncated</code> is equal to <code>true</code> when <code>count</code> is smaller than the content&#8217;s size.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">/*...*/ to ( char*     dest, char*     dest_end );
/*...*/ to ( char8_t*  dest, char8_t*  dest_end );
/*...*/ to ( char16_t* dest, char16_t* dest_end );
/*...*/ to ( char32_t* dest, char32_t* dest_end );
/*...*/ to ( wchar_t*  dest, wchar_t*  dest_end );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requirements
</td>
<td class="hdlist2">
<p><code>dest_end &gt; dest</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as in <code>to(dest, dest_end - dest)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p>Same as in <code>to(dest, dest_end - dest)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>Same as in <code>to(dest, dest_end - dest)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Support reserve
</td>
<td class="hdlist2">
<p>No</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template&lt;std::size_t N&gt; /*...*/ to ( char     (&amp;dest)[N] );
template&lt;std::size_t N&gt; /*...*/ to ( char8_t  (&amp;dest)[N] );
template&lt;std::size_t N&gt; /*...*/ to ( char16_t (&amp;dest)[N] );
template&lt;std::size_t N&gt; /*...*/ to ( char32_t (&amp;dest)[N] );
template&lt;std::size_t N&gt; /*...*/ to ( wchar_t  (&amp;dest)[N] );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as in <code>to(dest, N)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p>Same as in <code>to(dest, N)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>Same as in <code>to(dest, N)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Support reserve
</td>
<td class="hdlist2">
<p>No</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT = char&gt;
/*...*/ to(std::FILE* dest);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Successively call
<code>std::fwrite(buffer, sizeof(CharT),/*...* , dest)</code>
until the whole content is written or until an error happens, where <code>buffer</code> is
an internal array of <code>CharT</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>struct /*...*/ { std::size_t count; bool success; };</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>count</code> is sum of the returned values returned by the several calls to <code>std::fwrite</code>.</p>
</li>
<li>
<p><code>success</code> is <code>false</code> if an error occured.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Support reserve
</td>
<td class="hdlist2">
<p>No</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">/*...*/ wto(std::FILE* dest);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Successively call <code>std::fputwc(/*...*/, dest)</code>
until the whole content is written or until it returns <code>WEOF</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>struct /*...*/ { std::size_t count; bool success; };</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>count</code> is sum of the returned values returned by the several calls to <code>std::fwrite</code>.</p>
</li>
<li>
<p><code>success</code> is <code>false</code> if an error occured.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Support reserve
</td>
<td class="hdlist2">
<p>No</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT, typename Traits = std::char_traits&lt;CharT&gt; &gt;
/*...*/ to(std::basic_streambuf&lt;CharT, Traits&gt;&amp; dest);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Successively call <code>dest.sputn(/*...*/)</code>
until the whole content is written or until an error occur.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>struct /*...*/ { std::streambuf count; bool success; };</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>count</code> is sum of the returned values returned by the several calls to <code>dest.sputn(/*...*/)</code></p>
</li>
<li>
<p><code>success</code> is <code>false</code> if an error occured.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Support reserve
</td>
<td class="hdlist2">
<p>No</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="reserve">1.2. Reserving</h3>
<div class="paragraph">
<p>The <code>reserve</code> and <code>reserve_calc</code> are only supported in some destination types, as indicated above.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>reserve(std::size_t count)</code> : The size of <code>count</code> characters is reserve in the destination object.</p>
</li>
<li>
<p><code>reserve_calc()</code> : The necessary amount of characters is calculated and reserved in the destination object.</p>
</li>
<li>
<p><code>no_reserve()</code> : No size is reserved in the destination object.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="tr_string">1.3. Tr-string</h3>
<div class="paragraph">
<p>The <em>tr-string</em> is what in other formatting
libraries would be called as the <em>format string</em>,
with the difference that it does not specify any formatting.
Its purpose is to enable the use of translation tools like
<a href="https://en.wikipedia.org/wiki/Gettext">gettext</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto s = strf::to_string.tr("{} in hexadecimal is {}", x, strf::hex(x));</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_syntax">Syntax</h4>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">A <code>'{'</code> followed by</th>
<th class="tableblock halign-left valign-top">until</th>
<th class="tableblock halign-left valign-top">means</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'-'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the next <code>'}'</code> or end of string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a comment</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a digit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the next <code>'}'</code> or end of string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a positional argument reference</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">another <code>'{'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the second <code>'{'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">an escaped <code>'{'</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">any other character</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the next <code>'}'</code> or end of string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a non positional argument reference</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_comments">Comments</h5>
<div class="paragraph">
<p>When the tr-string has to be translated to other languages, the translation may be in charge of someone else than you. So you can add comments intended to help such person.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string.tr
    ( "You can learn more about python{-the programming language, not the reptile} at {}"
    , "www.python.org" );
assert(str == "You can learn more about python at www.python.org");</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_positional_arguments">Positional arguments</h5>
<div class="paragraph">
<p>Position zero refers to the first input argument. The characters the after the digits are ignored. So they can also be used as comments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string.tr("{1 a person} likes {0 a food type}.", "sandwich", "Paul");
assert(str == "Paul likes sandwich.");</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_non_positional_arguments">Non positional arguments</h5>
<div class="paragraph">
<p>The characters the after the <code>'{'</code> are ignored as well</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string.tr("{a person} likes {a food type}.", "Paul", "sandwich");
assert(str == "Paul likes sandwich.");</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_escapes">Escapes</h5>
<div class="paragraph">
<p>There is no way to escape the <code>'}'</code> character. There is no need to, since the <code>'}'</code> has special meaning only if it corresponds to a previous &#8217;{'</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string.tr("} {{ } {}", "aaa");
assert(str == "} { } aaa");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tr_string_error">Tr-string error handling</h4>
<div class="paragraph">
<p>The enumeration <code>tr_invalid_arg</code> is a <a href="#facets">facet</a> that specifies what happens when the tr-string references a non existing argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">enum class tr_invalid_arg{ replace, stop, ignore };</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>tr_invalid_arg::stop</code> : Throws an exception.</p>
</li>
<li>
<p><code>tr_invalid_arg::ignore</code> : Ignores the invalid reference.</p>
</li>
<li>
<p><code>tr_invalid_arg::replace</code> :  Replaces the invalid reference by the <a href="https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character">replacement character &#xFFFD;</a>. This is the default.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="facets">1.4. Facets</h3>
<div class="paragraph">
<p>These are not the same as the facets handled by <code>std::locale</code>,
but they are analogous.
Keep in mind that this is a locale-independent library.
So things are always printed as in the C-locale, unless
you explicitly specify otherwise, which you do by passing
<em>facet objects</em> to the <code><a href="#usage_syntax">with</a></code> function.</p>
</div>
<div class="paragraph">
<p>Every <em>facet</em> belongs to a <em>facet category</em>.
Each facet category corresponds to a concept, <em>i.e.</em> a set of requirements that a class must satisfy. A class that satisfies such requirements is a facet of such facet category. Moreover, for each facet category there is class whose name, by convention, has a "_c" suffix and is the name of the category.</p>
</div>
<div class="paragraph">
<p>For example, <code><a href="#numpunct">monotonic_grouping</a>&lt;10&gt;</code> and
<code><a href="#numpunct">str_grouping</a>&lt;10&gt;</code>  are both facets of the category
<code><a href="#numpunct">numpunct_c</a>&lt;10&gt;</code>.
Both have the same purpose: to customize numeric punctuation.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 14.2857%;">
<col style="width: 57.1429%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Category</th>
<th class="tableblock halign-left valign-top">Constrainable</th>
<th class="tableblock halign-left valign-top">What it controls</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#width_calculation">width_calculation_c</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">How the width is calculated</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#numpunct">numpunct_c</a>&lt;10&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Numeric punctuation for decimal base</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#numpunct">numpunct_c</a>&lt;16&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Numeric punctuation for hexadecimal base</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#numpunct">numpunct_c</a>&lt;8&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Numeric punctuation for octal base</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#numpunct">numpunct_c</a>&lt;2&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Numeric punctuation for binary base</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#lettercase">lettercase_c</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Letter case in numeric types</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#encoding">encoding_c</a>&lt;CharT&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The encoding correponding to character type <code>CharT</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#encoding_error">encoding_error_c</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Encoding error handling</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#surrogate_policy">surrogate_policy_c</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Wheter surrogates are treated as errors</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#tr_string_error">tr_string_error_c</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tr-string parsing error handling</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="constrained_facets">Constrained facets</h4>
<div class="paragraph">
<p>With the <code>constrain</code> function template you can create <em>constrained facets</em>, which are facets that only apply to certain input types. Its template parameter is a template type that contains a <code>value</code> member constexpr convertible to bool that tells whether a given input type is under the influence of the given facet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto facet_obj = strf::constrain&lt;std::is_signed&gt;(strf::monotonic_grouping&lt;10&gt;{3});
auto s = strf::to_string.with(facet_obj)(100000u, "  ", 100000);
assert(s == "100000  100,000");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The library provides some type traits to parameterize <code>constrain</code>:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_int_number</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">matches <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code> and the corresponding unsigned types</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_char</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">matches <code>char</code>, <code>char8_t</code>, <code>wchar_t</code>, <code>char16_t</code>, and <code>char32_t</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_string</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">matches strings.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="facet_overriding">Overriding facets</h4>
<div class="paragraph">
<p>If there are two or more facets object passed to the <code>with</code> function of the same category, and that apply to the same input type, then the last one wins:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto punct_dec_1 = strf::monotonic_grouping&lt;10&gt;{1};
auto punct_dec_2 = strf::monotonic_grouping&lt;10&gt;{2}.thousands_sep('.');
auto punct_dec_3 = strf::monotonic_grouping&lt;10&gt;{3}.thousands_sep('^');;

// Below, punct_dec_3 overrides punct_dec_2, but only for signed types.
// punct_dec_2 overrides punct_dec_1 for all input types,
// hence the presence of punt_dec_1 bellow has no effect.

auto s = strf::to_string
    .with( punct_dec_1
         , punct_dec_2
         , strf::constrain&lt;std::is_signed&gt;(punct_dec_3) )
    ( 100000, "  ", 100000u ) ;

assert(s == "100^000  10.00.00");</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="numpunct">2. Numeric punctuation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The facets of the <code>numpunct_c&lt;Base&gt;</code> category specify
the decimal point, the group separator character, and the groups'
size when printing numbers in the numeric base <code>Base</code>.
The library currently provides two
facets belonging to this category for you to choose.
If all groups have the same size, then you should choose the
<code>monotonic_grouping&lt;Base&gt;</code> facet since it is optimized for this situation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr int base = 10;

auto str = strf::to_string
    .with(strf::monotonic_grouping&lt;base&gt;{3}.thousands_sep(U'.'))
    (100000000000ll);

assert(str == "100.000.000.000");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, you can use the <code>str_grouping&lt;Base&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr int base = 10;

auto punct = strf::str_grouping&lt;base&gt;{"\4\3\2"};
auto str = strf::to_string.with(punct)(100000000000ll);
assert(str == "1,00,00,000,0000");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lettercase">3. Letter case</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>lettercase</code> facet affects the letter cases when printing numeric values.
The default value is <code>strf::lowercase</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

enum class lettercase { lower = /*...*/, mixed = /*...*/, upper = /*...*/ };

constexpr lettercase lowercase = lettercase::lower;
constexpr lettercase mixedcase = lettercase::mixed;
constexpr lettercase uppercase = lettercase::upper;

}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. Printed numeric values examples</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Value</th>
<th class="tableblock halign-left valign-top">Result examples</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>strf::lowercase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0xab</code> <code>1e+50</code> <code>inf</code> <code>nan</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>strf::mixedcase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0xAB</code> <code>1e+50</code> <code>Inf</code> <code>NaN</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>strf::uppercase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0XAB</code> <code>1E+50</code> <code>INF</code> <code>NAN</code></p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Usage example</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str_upper = strf::to_string.with(strf::uppercase)
    ( ~strf::hex(0xabc), ' '
    , 1.0e+50, ' '
    , std::numeric_limits&lt;FloatT&gt;::infinity() );

assert(str_upper == "0XAB 1E+50 INF");

auto str_mixed = strf::to_string.with(strf::mixedcase)
    ( ~strf::hex(0xabc), ' '
    , 1.e+50, ' '
    , std::numeric_limits&lt;FloatT&gt;::infinity() );

assert(str_upper == "0xAB 1e+50 Inf");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="encoding">4. Character encodings</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_class_template_code_encoding_code">4.1. Class template <code>encoding</code></h3>
<div class="paragraph">
<p>The <code>encoding</code> class template stores a reference to an const object
with static storage duration of an implementation-defined type that
contains information and algorithms related to a character encoding.
It has the size of a pointer, and it is cheap to copy.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename CharT&gt;
class encoding
{
public:
    encoding (const encoding&amp;) noexcept;
    encoding&amp; operator=(const encoding&amp;);
    bool operator==(const encoding&amp;);
    const char* name() const; // example: "UTF-8"

    // other functions ( to-do ) ...
};

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>So an <code>encoding</code> object is used to represent an econding.
When used as a facet, <code>encoding&lt;CharT&gt;</code> specifies what is the character
encoding corresponding to <code>CharT</code>. For example, you may have noticed that
<a href="#numpunct">punctuation characters</a> and fill characters are specified
as <code>char32_t</code>. They are aways assumed to be in UTF-32.
How they are converted is specified that the <code>encoding</code> facet.</p>
</div>
<div class="listingblock">
<div class="title">Example: write in Windows-1252</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto s = strf::to_string
    .with(strf::windows_1252&lt;char&gt;())
    .with(strf::str_grouping&lt;10&gt;{"\4\3\2"}.thousands_sep(0x2022))
    ("one hundred billions = ", 100000000000ll);

// The character U+2022 is encoded as '\225' in Windows-1252
assert(s == "one hundred billions = 1\2250000\225000\2250000");</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_supported_encodings">4.2. Supported encodings</h3>
<div class="paragraph">
<p>Currently the library only provide few encodings. But list is expected
to grow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename CharT&gt; encoding&lt;CharT&gt; utf8();</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requirements
</td>
<td class="hdlist2">
<p><code>sizeof(CharT) == 1</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p>The UTF-8 encoding</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p>This is the default facet for <code>char</code> and <code>char8_t</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename CharT&gt; encoding&lt;CharT&gt; iso_8859_1();</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requirements
</td>
<td class="hdlist2">
<p><code>sizeof(CharT) == 1</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p>The <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO/IEC 8859-1</a> encoding</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename CharT&gt; encoding&lt;CharT&gt; iso_8859_1();</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requirements
</td>
<td class="hdlist2">
<p><code>sizeof(CharT) == 1</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p>The <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO/IEC 8859-1</a> encoding</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename CharT&gt; encoding&lt;CharT&gt; iso_8859_15();</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requirements
</td>
<td class="hdlist2">
<p><code>sizeof(CharT) == 1</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p>The <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859-15">ISO/IEC 8859-15</a> encoding</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename CharT&gt; encoding&lt;CharT&gt; windows_1252();</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requirements
</td>
<td class="hdlist2">
<p><code>sizeof(CharT) == 1</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p>The <a href="https://en.wikipedia.org/wiki/Windows-1252">Windows-1252</a> encoding</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename CharT&gt; encoding&lt;CharT&gt; utf16()`;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requirements
</td>
<td class="hdlist2">
<p><code>sizeof(CharT) == 2</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p>The UTF-16 encoding.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p>This is the default for <code>char16_t</code>.</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template&lt;typename CharT&gt; encoding&lt;CharT&gt; utf32();</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Requirements
</td>
<td class="hdlist2">
<p><code>sizeof(CharT) == 4</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p>UTF-32 encoding.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p>This is the default for <code>char32_t</code>.</p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">encoding&lt;wchar_t&gt; utfw();</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Returns
</td>
<td class="hdlist2">
<p>UTF-16 if <code>sizeof(wchar_t) == 2</code> and UTF-32 if <code>sizeof(wchar_t) == 4</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p>This is the default for <code>wchar_t</code>.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="encoding_conversion">4.3. Encoding conversion</h3>
<div class="paragraph">
<p>Since the library knows the encoding correspondig to each
character type, and knows how to convert from one to another,
it is possible to mix input string of difference characters
types. It is necessary though to use the <code>cv</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str   = strf::to_string( "aaa-"
                            , strf::cv(u"bbb-")
                            , strf::cv(U"ccc-")
                            , strf::cv(L"ddd") );

auto str16 = strf::to_u16string( strf::cv("aaa-")
                               , u"bbb-"
                               , strf::cv(U"ccc-")
                               , strf::cv(L"ddd") );

assert(str   ==  "aaa-bbb-ccc-ddd");
assert(str16 == u"aaa-bbb-ccc-ddd");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>cv</code> function can also specify an alternative encoding
for a specific input string argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str_utf8 = strf::to_u8string
    ( strf::cv("--\xA4--", strf::iso_8859_1&lt;char&gt;())
    , strf::cv("--\xA4--", strf::iso_8859_15&lt;char&gt;()));

assert(str_utf8 == u8"--\u00A4----\u20AC--");</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also the <code>sani</code> function that was the same
effect as <code>cv</code> except when the input encoding is same as the
output. In this case <code>sani</code> causes the input to be
sanitized, whereas <code>cv</code> does not:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string
    .with(strf::iso_8859_3&lt;char&gt;()) // the output encoding
    ( strf::cv("--\xff--")                           // does't sanitize
    , strf::cv("--\xff--", strf::iso_8859_3&lt;char&gt;()) // does't sanitize ( same encoding )
    , strf::cv("--\xff--", strf::utf8&lt;char&gt;())       // sanitizes ( different encoding )
    , strf::sani("--\xff--")                             // sanitizes
    , strf::sani("--\xff--", strf::iso_8859_3&lt;char&gt;()) ) // sanitizes

assert(str == "--\xff----\xff----?----?----?--");</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="encoding_error">4.4. Encoding error handling</h3>
<div class="paragraph">
<p>The <code>encoding_error</code> enumeration controls how invalid
sequences are handled during encoding conversion.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {
enum class encoding_error{ replace, stop };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default value is <code>encoding_error::replace</code>, that
causes the invalid sequence to be replaced the
<a href="https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character">replacement character &#xFFFD;</a>. When the input is UTF-8,
the library follows the practice recommended by the Unicode
Standard ( search for "Best Practices for Using U+FFFD" in
<a href="https://www.unicode.org/versions/Unicode10.0.0/ch03.pdf">Chapter 3</a> ).</p>
</div>
<div class="listingblock">
<div class="title">Replace</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_u8string (strf::cv("--\x99--"));
assert(str == u8"--\uFFFD--");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Throw exception</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">bool transcoding_failed = false;
try{
    auto str = strf::to_string
        .with(strf::encoding_error::stop)
        (strf::cv("--\x99--"));
}
catch(strf::encoding_failure&amp;){
    transcoding_failed = true;
}
assert(transcoding_failed);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="surrogate_policy">4.5. Surrogates tolerance</h3>
<div class="paragraph">
<p>The <code>surrogate_policy</code> enumeration is a facet that controls
whether surrogates are tolerated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {
enum class surrogate_policy : bool { strict = false, lax = true };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default value is <code>surrogate_policy::strict</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">std::u16string input_utf16 {u"-----"};
input_utf16[1] = 0xD800; // a surrogate character alone

// convert to UTF-8
auto str_strict = strf::to_u8string(strf::cv(input_utf16));
auto str_lax = strf::to_u8string
    .with(strf::surrogate_policy::lax)
    ( strf::cv(input_utf16) );

assert(str_strict == u8"-\uFFFD---");  // surrogate sanitized
assert(str_lax == (const char8_t*)"-\xED\xA0\x80---"); // surrogate allowed

// Then back to UTF-16
auto utf16_strict = strf::to_u16string(strf::cv(str_lax));

auto utf16_lax = strf::to_u16string
    .with(strf::surrogate_policy::lax)
    ( strf::cv(str_lax) );

assert(utf16_strict == u"-\uFFFD\uFFFD\uFFFD---"); // surrogate sanitized
assert(utf16_lax == input_utf16);                  // surrogate preserved</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="width_calculation">5. Width Calculation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>to-do</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="format_functions">6. Format functions</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename T&gt;
constexpr /*...*/ fmt(const T&amp; value);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fmt(value)</code> returns an object that contains a copy or reference of
<code>value</code> as well as format information and what is called here as
<em>format functions</em>. These are member functions whose return type&#8201;&#8212;&#8201;which is usually but not always the same as of <code>fmt(value)</code>&#8201;&#8212;&#8201;also contains the same format functions. This way, you can call
several of them in a row like
<code>fmt(value).func1(/*...*/).func2(/*...*/).func3(/*...*/)</code>. What format functions are available depends on the
type of <code>value</code>, so you need to check them in the further section
<a href="#input_types">Input types</a>. But there is a set of format functions
that is common is most input types, which are related to alignment
(<em>a.k.a</em> justification):</p>
</div>
<div id="alignment_format_functions" class="hdlist">
<div class="title">Text aligment format function</div>
<table>
<tr>
<td class="hdlist1">
<code>operator&gt;(std::int16_t width)</code>
</td>
<td class="hdlist2">
<p>Align to the right ( Or to the left right-to-left (RTL) script )</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>operator&lt;(std::int16_t width)</code>
</td>
<td class="hdlist2">
<p>Align to the left ( Or to the right right-to-left (RTL) script )</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>operator^(std::int16_t width)</code>
</td>
<td class="hdlist2">
<p>Center alignment</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>operator%(std::int16_t width)</code>
</td>
<td class="hdlist2">
<p>Split the content, like in <code>std::internal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>fill(char32_t ch)</code>
</td>
<td class="hdlist2">
<p>Set the fill character.</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are also some global functions that act as syntatic sugar
for format functions:</p>
</div>
<div id="format_function_aliases" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename T&gt;
constexpr auto fmt(const T&amp; value)
{
    return make_fmt(strf::rank&lt;5&gt;{}, value);
}

template &lt;typename T&gt;
constexpr auto hex(const T&amp; value)
{
    return fmt(value).hex();
}

template &lt;typename T&gt;
constexpr auto dec(const T&amp; value)
{
    return fmt(value).dec();
}

template &lt;typename T&gt;
constexpr auto oct(const T&amp; value)
{
    return fmt(value).oct();
}

template &lt;typename T&gt;
constexpr auto bin(const T&amp; value)
{
    return fmt(value).bin();
}

template &lt;typename T&gt;
constexpr auto left(const T&amp; value, int width)
{
    return fmt(value) &lt; width;
}

template &lt;typename T&gt;
constexpr auto right(const T&amp; value, int width)
{
    return fmt(value) &gt; width;
}

template &lt;typename T&gt;
constexpr auto split(const T&amp; value, int width)
{
    return fmt(value) % width;
}

template &lt;typename T&gt;
constexpr auto center(const T&amp; value, int width)
{
    return fmt(value) ^ width;
}

template &lt;typename T&gt;
constexpr auto left(const T&amp; value, int width, char32_t fill)
{
    return fmt(value).fill(fill) &lt; width;
}

template &lt;typename T&gt;
constexpr auto right(const T&amp; value, int width, char32_t fill)
{
    return fmt(value).fill(fill) &gt; width;
}

template &lt;typename T&gt;
constexpr auto cv(const T&amp; value)
{
    return fmt(value).cv();
}

template &lt;typename T, typename E&gt;
constexpr auto cv(const T&amp; value, const E&amp; encoding)
{
    return fmt(value).cv(encoding);
}

template &lt;typename T&gt;
constexpr auto sani(const T&amp; value)
{
    return fmt(value).sani();
}

template &lt;typename T, typename E&gt;
constexpr auto sani(const T&amp; value, const E&amp; encoding)
{
    return fmt(value).sani(encoding);
}

} // namespace strf</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="input_types">7. Input types</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_integers">7.1. Integers</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Types</dt>
<dd>
<p><code>short</code>,
<code>int</code>,
<code>long int</code>,
<code>long long int</code>,
<code>unsigned short</code>,
<code>unsigned int</code>,
<code>unsigned long int</code> and
<code>unsigned long long int</code></p>
</dd>
</dl>
</div>
<div id="int_fmt" class="dlist">
<dl>
<dt class="hdlist1">Format functions</dt>
<dd>
<p>( in addition to <a href="#alignment_format_functions">alignment functions</a> )</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>dec()</code></dt>
<dd>
<p>Use decimal base ( This is already the default, though )</p>
</dd>
<dt class="hdlist1"><code>hex()</code></dt>
<dd>
<p>Use hexadecimal base.</p>
</dd>
<dt class="hdlist1"><code>oct()</code></dt>
<dd>
<p>Use octal base.</p>
</dd>
<dt class="hdlist1"><code>bin()</code></dt>
<dd>
<p>Use binary base.</p>
</dd>
<dt class="hdlist1"><code>p(unsigned precision)</code></dt>
<dd>
<p>Ensures that at least <code>precision</code> digits
are printed by adding extra zero leading digits if necessary.</p>
</dd>
<dt class="hdlist1"><code>operator+()</code></dt>
<dd>
<p>When in decimal base, print the positive sign
<code>"+"</code> when value is non negative. No effect for other bases.</p>
</dd>
<dt class="hdlist1"><code>operator~()</code></dt>
<dd>
<p>Print the base indication
( <code>"0x"</code> for hexadecimal, <code>"0"</code> for octal and <code>"0b"</code> for binary ).
No effect in decimal base.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#lettercase">lettercase_c</a></code></p>
</li>
<li>
<p><code><a href="#numpunct">numpunct_c</a>&lt;<em>Base</em>&gt;</code></p>
</li>
<li>
<p><code><a href="#encoding">encoding_c</a>&lt;<em>CharType</em>&gt;</code>: Affects the printing of the <a href="#alignment_format_functions">fill character</a> and of the <a href="#numpunct">punctuation characters</a>.</p>
</li>
<li>
<p><code><a href="#surrogate_policy">surrogate_policy_c</a></code>: Affects the printing of the <a href="#alignment_format_functions">fill character</a>.</p>
</li>
<li>
<p><code><a href="#encoding_error">encoding_error_c</a></code>: Affects the printing of the <a href="#alignment_format_functions">fill character</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_floating_points">7.2. Floating Points</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Types</dt>
<dd>
<p><code>float</code>, <code>double</code></p>
</dd>
<dt class="hdlist1">Format functions</dt>
<dd>
<p>( In addition to the <a href="#alignment_format_functions">alignment functions</a> )</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>operator+()</code></dt>
<dd>
<p>When in decimal base, print the positive sign
<code>"+"</code> when value is non negative. No effect for other bases.</p>
</dd>
<dt class="hdlist1"><code>operator~()</code></dt>
<dd>
<p>Prints the decimal point even when there
are no fractional digits.</p>
</dd>
<dt class="hdlist1"><code>sci()</code></dt>
<dd>
<p>Use scientific notation, like this: <code>"1.2345e+02"</code>.</p>
</dd>
<dt class="hdlist1"><code>fixed()</code></dt>
<dd>
<p>Use decimanl notation, like this: <code>"123.45"</code>.</p>
</dd>
<dt class="hdlist1"><code>gen()</code></dt>
<dd>
<p>This is the default notation.
When precision is unspecified ( or equal to <code>(unsigned)-1</code> )
prints in the scientfic notation if, and only if, it is shorter
than the fixed notation. Otherwise, does like in <code>std::printf</code>:
uses the scientfic notation if the exponent is less than -4 or greater
than or equal to the precision. Trailing fractional zeros are not printed.</p>
</dd>
<dt class="hdlist1"><code>p(unsigned precision)</code></dt>
<dd>
<p>If <code>precision == (unsigned)-1</code>, which is
the default, then prints the minimal amount of digits so that value
can fully recovered by a parser. Otherwise, if notation is <em>general</em>,
<code>precision</code> is the number of significant digits. Otherwise it is
the number of fractional digits. <code>precision == 0</code> has the same effect as
<code>precision == 1</code>.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#lettercase">lettercase_c</a></code></p>
</li>
<li>
<p><code><a href="#numpunct">numpunct_c</a>&lt;10&gt;</code></p>
</li>
<li>
<p><code><a href="#encoding">encoding_c</a>&lt;<em>CharType</em>&gt;</code>: Affects the printing of the <a href="#alignment_format_functions">fill character</a> and of the <a href="#numpunct">punctuation characters</a>.</p>
</li>
<li>
<p><code><a href="#surrogate_policy">surrogate_policy_c</a></code>: Affects the printing of the <a href="#alignment_format_functions">fill character</a>.</p>
</li>
<li>
<p><code><a href="#encoding_error">encoding_error_c</a></code>: Affects the printing of the <a href="#alignment_format_functions">fill character</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="__code_const_void_code">7.3. <code>const void*</code></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Types</dt>
<dd>
<p><code>const void*</code></p>
</dd>
<dt class="hdlist1">Format functions</dt>
<dd>
<p>The <a href="#alignment_format_functions">alignment functions</a> only.</p>
</dd>
<dt class="hdlist1">Facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#lettercase">lettercase_c</a></code></p>
</li>
<li>
<p><code><a href="#numpunct">numpunct_c</a>&lt;16&gt;</code></p>
</li>
<li>
<p><code><a href="#encoding">encoding_c</a>&lt;<em>CharType</em>&gt;</code>: Affects the printing of the <a href="#alignment_format_functions">fill character</a> and of the <a href="#numpunct">punctuation characters</a>.</p>
</li>
<li>
<p><code><a href="#surrogate_policy">surrogate_policy_c</a></code>: Affects the printing of the <a href="#alignment_format_functions">fill character</a>.</p>
</li>
<li>
<p><code><a href="#encoding_error">encoding_error_c</a></code>: Affects the printing of the <a href="#alignment_format_functions">fill character</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_single_characters">7.4. Single characters</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Type</dt>
<dd>
<p><code>CharT</code>, that is the output character type defined by the <a href="#destinations">destination</a>.</p>
</dd>
<dt class="hdlist1">Format functions</dt>
<dd>
<p>( in addition to <a href="#alignment_format_functions">alignment functions</a> )</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>multi(std::size_t count)</code></dt>
<dd>
<p>Prints the character <code>count</code> times. Default value is <code>1</code>.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#width_calculation">width_calculation_c</a></code></p>
</li>
<li>
<p><code><a href="#encoding">encoding_c</a>&lt;<em>CharType</em>&gt;</code></p>
</li>
<li>
<p><code><a href="#surrogate_policy">surrogate_policy_c</a></code></p>
</li>
<li>
<p><code><a href="#encoding_error">encoding_error_c</a></code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_strings">7.5. Strings</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Types</dt>
<dd>
<p><code>const CharT*</code>, <code>std::string_view&lt;CharT, Traits&gt;</code>
and <code>std::basic_string&lt;CharT, Traits, Alloc&gt;</code></p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>where:</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>CharT</code> is the character type. If it is not the same as the output character type ( defined by the <a href="#destinations">destination</a> ), then it is necessare to use the <code>cv</code> or <code>sani</code> format function.</p>
</li>
<li>
<p><code>Traits</code> can be any type that satisfies <a href="https://en.cppreference.com/w/cpp/named_req/CharTraits">CharTraits</a></p>
</li>
<li>
<p><code>Alloc</code> can be any type that satisfies <a href="https://en.cppreference.com/w/cpp/named_req/Allocator">Allocator</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Format functions</dt>
<dd>
<p>( in addition to <a href="#alignment_format_functions">alignment functions</a> )</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>sani(encoding&lt;CharT&gt; enc)</code></dt>
<dd>
<p>Translates input string from <code>enc</code> to the
output encoding. If the encodings are the same
then sanitizes the input string.</p>
</dd>
<dt class="hdlist1"><code>sani()</code></dt>
<dd>
<p>Translates input string from the encoding associated to <code>CharT</code> to
the output encoding. If these encodings are the same
then sanitizes the input string.</p>
</dd>
<dt class="hdlist1"><code>cv(encoding&lt;CharT&gt; enc)</code></dt>
<dd>
<p>Translates input string from <code>enc</code> to the
output encoding, if these encodings are not the same.
Otherwise, copies input string as it is.</p>
</dd>
<dt class="hdlist1"><code>cv()</code></dt>
<dd>
<p>Translates input string from the encoding associated to <code>CharT</code> to
the output encoding, if these encodings are not the same.
Otherwise, copies the input string as it is.</p>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string(strf::center(u" Hello! ", 16, '*').cv());
assert(str == "**** Hello! ****");</code></pre>
</div>
</div>
<div class="paragraph">
<p>See also the section about <a href="#encoding_conversion">encoding conversion</a>.</p>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">Facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#width_calculation">width_calculation_c</a></code></p>
</li>
<li>
<p><code><a href="#encoding">encoding_c</a>&lt;<em>CharType</em>&gt;</code></p>
</li>
<li>
<p><code><a href="#surrogate_policy">surrogate_policy_c</a></code></p>
</li>
<li>
<p><code><a href="#encoding_error">encoding_error_c</a></code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ranges">7.6. Ranges</h3>
<div class="sect3">
<h4 id="_without_formatting">Without formatting</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename Range&gt;
/*...*/ range(const Range&amp; r);

template &lt;typename T, std::size_t N&gt;
/*...*/ range(T (&amp;array)[N]);

template &lt;typename Iterator&gt;
/*...*/ range(const Iterator&amp; begin, const Iterator&amp; end);

// With operation

template &lt;typename Range, typename UnaryOperation&gt;
/*...*/ range(const Range&amp; r, UnaryOperation unary_op);

template &lt;typename T, std::size_t N, typename UnaryOperation&gt;
/*...*/ range(T (&amp;array)[N], UnaryOperation unary_op);

template &lt;typename Iterator, typename UnaryOperation&gt;
/*...*/ range( const Iterator&amp; begin
             , const Iterator&amp; end
             , UnaryOperation unary_op );

// With separator:

template &lt;typename Range, typename CharT&gt;
/*...*/ separated_range(const Range&amp; r, const CharT* separator);

template &lt;typename T, std::size_t N, typename CharT&gt;
/*...*/ separated_range(T (&amp;array)[N], const CharT* separator);

template &lt;typename Iterator, typename CharT&gt;
/*...*/ separated_range( const Iterator&amp; begin
                       , const Iterator&amp; end
                       , const CharT* separator );

// With separator and operation

template &lt;typename Range, typename CharT, typename UnaryOperation&gt;
/*...*/ separated_range( const Range&amp; r
                       , const CharT* separator
                       , UnaryOperation unary_op );

template &lt;typename T, std::size_t N, typename CharT, typename UnaryOperation&gt;
/*...*/ separated_range( T (&amp;array)[N]
                       , const CharT* separator
                       , UnaryOperation unary_op );

template &lt;typename Iterator, typename CharT, typename UnaryOperation&gt;
/*...*/ separated_range( const Iterator&amp; begin
                       , const Iterator&amp; end
                       , const CharT* separator
                       , UnaryOperation unary_op );
} // namespace strf</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">int arr[3] = { 11, 22, 33 };

auto str = strf::to_string(strf::range(arr));
assert(str == "112233");

str = strf::to_string(strf::separated_range(arr, ", "));
assert(str == "11, 22, 33");

auto op = [](auto x){ return strf::<a href="#joins">join</a>('(', +strf::fmt(x * 10), ')'); };

str = strf::to_string(strf::separated_range(arr, ", ", op));
assert(str == "(+110), (+220), (+330)");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_with_formatting">With formatting</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename Range&gt;
/*...*/ fmt_range(const Range&amp; r);

template &lt;typename T, std::size_t N&gt;
/*...*/ fmt_range(T (&amp;array)[N], const Range&amp; r);

template &lt;typename Iterator&gt;
/*...*/ fmt_range(const Iterator&amp; begin, const Iterator&amp; end);

// With separator

template &lt;typename Range, typename CharT&gt;
/*...*/ fmt_separated_range(const Range&amp; r, const CharT* separator);

template &lt;typename T, std::size_t N, typename CharT&gt;
/*...*/ fmt_separated_range(T (&amp;array)[N], const CharT* separator);

template &lt;typename Iterator, typename CharT&gt;
/*...*/ fmt_separated_range( const Iterator&amp; begin
                           , const Iterator&amp; end
                           , const CharT* separator );
} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any format function applicable to the element type of the
range can also be applied to the
expression <code>strf::fmt_range(/*...*/)</code> or
<code>strf::fmt_separated_range(/*...*/)</code>.
This way the format functions is applied to all elements:</p>
</div>
<div class="listingblock">
<div class="title">Example 1</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">std::vector&lt;int&gt; vec = { 11, 22, 33 };
auto str1 = strf::to_string("[", +strf::fmt_separated_range(vec, " ;") &gt; 4, "]");
assert(str1 == "[ +11 ; +22 ; +33]");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 2</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">std::vector&lt;int&gt; vec = { 11, 22, 33 };
auto str2 = strf::to_string
    ( "["
    , ~strf::fmt_separated_range(vec, " / ").fill('.').hex() &gt; 6,
    " ]");

assert(str2 == "[..0xfa / ..0xfb / ..0xfc]");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Actually, you don&#8217;t need to use <code>fmt_range</code> or <code>fmt_separated_range</code>.
You can apply format function directly into <code>range(/*...*/)</code>
or <code>separarated_range(/*...*/)</code>, as long as you don&#8217;t pass
an operation function object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">std::vector&lt;int&gt; vec = { 11, 22, 33 };
auto str = strf::to_string("[", ~strf::hex(strf::separated_range(vec, " ; ")), "]");
assert(str == "[0xb ; 0x16 ; 0x21]");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="joins">7.7. Joins</h3>
<div class="sect3">
<h4 id="_without_alignment">Without alignment</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename ... Args&gt;
/*...*/ join(const Args&amp; ... args);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Joins</em> enables you to group a set of input arguments as one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">std::string month = "May";
int day = 5;

auto str = strf::to_string.tr("Today is {}.", strf::join(month, ' ', day))
assert(str == "Today is May 5")</code></pre>
</div>
</div>
<div class="paragraph">
<p>It can be handy to create aliases:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">struct date{ int day, month, year; };

auto as_yyyymmdd = [](date d)
{
    return strf::join( strf::<a href="#int_fmt">dec</a>(d.year).<a href="#int_fmt">p</a>(4), '/'
                     , strf::<a href="#int_fmt">dec</a>(d.month).<a href="#int_fmt">p</a>(2), '/'
                     , strf::<a href="#int_fmt">dec</a>(d.day).<a href="#int_fmt">p</a>(2) );
};

date today {1, 1, 1935};
auto str = strf::to_string("Today is ", as_yyyymmdd(today), '.');
assert(str == "Today is 1935/01/01.");</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Watch out for dangling references when using joins.
When passing an array to <code>join</code>, it is stored by reference
in the returned object. So the code below has UB:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>auto get_hello(const char* name)
{
    char buff[20]; // temporary array
    strcpy(buff, "Hello");
    return strf::join(buff, name, '!');
}

int main()
{
    // accessing a dangling array reference
    strf::to(stdout)(get_hello("Maria"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, <code>get_hello()</code> could be fixed by simply returning instead
<code>strf::join("Hello", name, '!')</code>, since string literals have
static storage duration.</p>
</div>
<div class="paragraph">
<p>Also, although arguments are stored by value in joins
( except for arrays ), some of the arguments may contain references.
For exemple, if <code>str</code> is a <code>std::string</code>, then
<code>strf::<a href="#format_function_aliases">right</a>(str, 10)</code> doesn&#8217;t store a copy of
<code>str</code>, but a reference to its array of characters.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you don&#8217;t want to ( or can not ) store an argument by copy in a
join, you can use <code>std::reference_wrapper</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>std::string name = /*...*/;
strf::to(stdout) (strf::join("Hello ", std::ref(name), '!') ^ 50);</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_with_alignment">With alignment</h4>
<div class="paragraph">
<p>You can apply the <a href="#alignment_format_functions">alignment format functions</a>
one the return type of <code>join(args...)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string
    ("---", strf::join("abc", "def", 123) &gt; 15, "---");

assert(str == "---      abcdef123---");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>split_pos</code> function specifies how many arguments
go before the fill when the <code>operator%</code> is used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">str = strf::to_string
    ( strf::join('a', 'b', 'c', 'd', 'e', 'f').split_pos(2) % 10 );
assert(str == "ab    cdef");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The functions below provide an alternartive syntax to create aligned
join. Their return type has the <code>operator()(const Args&amp; ... args)</code> member function
that receives the elements of the join.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

enum class text_alignment {left, right, split, center};

/* ... */ join_align( std::int16_t width
                    , text_alignment align
                    , char32_t fillchar = U' '
                    , std::ptrdiff_t split_pos = 0 );
/* ... */ join_center(int width, char32_t fillchar = U' ');
/* ... */ join_left(int width, char32_t fillchar = U' ');
/* ... */ join_right(int width, char32_t fillchar = U' ');
/* ... */ join_split(int width, int split_pos);
/* ... */ join_split( std::int16_t width
                    , char32_t fillchar
                    , std::ptrdiff_t split_pos );
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string
    ("---", strf::join_right(15) ("abc", "def", 123), "---");
assert(str == "---      abcdef123---");

str = strf::to_string
    ("---", strf::join_center(15) ("abc", "def", 123), "---");
assert(str == "---   abcdef123   ---");

str = strf::to_string
    ( "---"
    , strf::join_left(15, U'.') ("abc", strf::right("def", 5), 123)
    , "---" );
assert(str == "---abc  def123....---");

str = strf::to_string
    ( "---"
    , strf::join_split(15, '.', 1) (strf::left("abc", 5), "def", 123)
    , "---" );
assert(str == "---abc  ....def123---");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_facets">7.8. Facets</h3>
<div class="paragraph">
<p>It is possible to <a href="#facet_overriding">override facets</a>
to only a subset of the input arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt; typename FPack &gt;
class inner_pack
{
public:
    template &lt;typename... Args&gt;
    /*...*/  operator()(const Args&amp;... args) const;
    //...
};

template &lt;typename ... Facets&gt;
inner_pack&lt;/*...*/&gt; with(const Facets&amp;... facets);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 1</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string.with(strf::monotonic_grouping&lt;10&gt;(1))
    ( 10000
    , "  "
    , strf::hex(0x10000)
    , strf::with( strf::monotonic_grouping&lt;10&gt;(3)
                , strf::monotonic_grouping&lt;16&gt;(4).thousands_sep('\'') )
        ( "  { "
        , 10000
        , "  "
        , strf::hex(0x10000)
        , " }" ) );

assert(str == "1,0,0,0,0  10000  { 10,000  1'0000 }");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 2</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto fp = strf::pack
    ( strf::monotonic_grouping&lt;10&gt;(3)
    , strf::monotonic_grouping&lt;16&gt;(4).thousands_sep('\'') );

auto str = strf::to_string.with(strf::monotonic_grouping&lt;10&gt;(1))
    ( 10000
    , "  "
    , strf::hex(0x10000)
    , strf::with(fp)
        ( "  { "
        , 10000
        , "  "
        , strf::hex(0x10000)
        , strf::with
            (strf::monotonic_grouping&lt;10&gt;(2).thousands_sep('.'))
              ("  { ", 10000, " }")
        , " }" ) );

assert(str == "1,0,0,0,0  10000  { 10,000  1'0000  { 1.00.00 } }");</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extending_the_library">8. Extending the library</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_adding_output_types">8.1. Adding output types</h3>
<div class="paragraph">
<p>to-do</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_input_typess">8.2. Adding input typess</h3>
<div class="paragraph">
<p>to-do</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_facets">8.3. Adding Facets</h3>
<div class="paragraph">
<p>to-do</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_encodings">8.4. Adding encodings</h3>
<div class="paragraph">
<p>to-do</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-05-23 16:48:15 -03
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>
</body>
</html>