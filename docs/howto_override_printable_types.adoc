////
Copyright (C) (See commit logs on github.com/robhz786/strf)
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
////

:printable_overrider_c: <<strf_hpp#printable_overrider_c,printable_overrider_c>>
:make_printer_input: <<strf_hpp#make_printer_input,make_printer_input>>
:use_facet: <<strf_hpp#use_facet,use_facet>>
:pack: <<strf_hpp#pack,pack>>
:set_alignment_format: <<strf_hpp#alignment_formatter,set_alignment_format>>
:get_alignment_format: <<strf_hpp#alignment_formatter,get_alignment_format>>
:constrain: <<strf_hpp#constrain,constrain>>
:printable_with_fmt: <<strf_hpp#printable_with_fmt,printable_with_fmt>>
:PrintableTraits: <<strf_hpp#PrintableTraits,PrintableTraits>>
:PrinterInput: <<strf_hpp#PrinterInput,PrinterInput>>
:printable_traits_of: <<strf_hpp#printable_traits_of,printable_traits_of>>
:lettercase: <<strf_hpp#lettercase,lettercase>>
:representative_of_printable: <<strf_hpp#representative_of_printable,representative_of_printable>>


:is_printable_and_overridable: <<strf_hpp#is_printable_and_overridable,is_printable_and_overridable>>
:remove_cvref_t: link:https://en.cppreference.com/w/cpp/types/remove_cvref[remove_cvref_t]


= How to override printable types
:source-highlighter: prettify
:icons: font
:toc: left
:toc-title: Adding printable types

Strf allows you not only to <<howto_add_printable_types#,add printable types>>,
but also to override existing ones. The procedure is similar; the
main difference is that instead of defining a _{PrintableTraits}_ type,
you create a facet of the `{printable_overrider_c}` category,
which is almost the same thing.
So this document presumes you already know how to do that.
If you don't,
<<howto_add_printable_types#CreatePrintableTraits,click here>>
to get some explanation.


The facet shall contain the
`make_input` member function templates that will
replace those defined in the _{PrintableTraits}_ class of the
overrided type.
For example, one could define a facet to override the `bool` like this:


////

In the following example, we override the `bool` type,
causing its values to be printed in a another language:

which also has a `make_input` function template
that returns a _{PrinterInput}_ object.

As an example, let's to override the `bool` type,
so that its values will be printed in italian (as "vero" and "falso" )
instead of english.
////


[source,cpp,subs=normal]
----
struct italian_bool_facet
{
    using category = strf::{printable_overrider_c};

    template <typename CharT, typename Pre, typename FPack>
    constexpr static auto make_input
        ( strf::tag<CharT>, Pre& pre, const FPack&, bool x ) noexcept
    {
        return strf::{make_printer_input}<CharT>
            ( pre
            , strf::{pack}()
            , strf::conv(x ? "vero" : "falso") );
    }

    template <typename CharT, typename Pre, typename FPack, typename... T>
    constexpr static auto make_input
        ( strf::tag<CharT>
        , Pre& pre
        , const FPack& fp
        , strf::{printable_with_fmt}<T\...> x ) noexcept
    {
        return strf::{make_printer_input}<CharT>
            ( pre
            , fp
            , strf::conv(x.value() ? "vero" : "falso")
                .{set_alignment_format}(x.{get_alignment_format}()) );
    }
};
----
Everything in `make_input`
( semantics, return type, arguments, etc )
is just like as in the __PrintableTraits__ requirements, except that here it is
allowed to be non-static, though it must be then const (
so instead of hardcoded strings like `"vero"`, and `"falso"`
, we could use member variables, which would probably make more sense ).

Just as it is usual in __PrintableTraits__ classes,
you can see that we have two `make_input` fuctions
( though the first one is unnecessary ).
The second one handles `bool` values with formatting.
Even if we don't define it, an expression like
`strf::right(true, 10, '.')`
is still well-formed, because the format functions
that are applicable to a printable type keep being the same
when we override it. We can't change them.
So it makes sense to overload `make_input`
with `{printable_with_fmt}` argument even
if you don't want to support formatting, just to
add a `static_assert` to emit a clear error message.

But if do you want support formatting then
check in the <<strf_hpp#printable_types_list,documentation>> what
are the format functions ( or the __Formatters__ )
applicable to the printable type you are overriding.
If you take a look at the part the covers
`<<strf_hpp#printable_bool,bool>>`,
you can see that we only need to handle
<<strf_hpp#alignment_formatter, alignment formatting>>.
And that's what we did in the implementation above.

////
Even if you don't want to support formatting,
it still makes sense to overload `make_input`
taking the `{printable_with_fmt}` argument and add
a `static_assert` with an explanatory message.

////


Things are more lenient regarding facets:
you can completely ignore the facet categories that
influence the original printable type, as well as consider others
or <<howto_add_printable_types#creating_facet,new>> ones.
You can see that although `bool` type is influenced
by `{lettercase}` facet our override just ignores it.

////
Now, let's see how to use our implementation.
One important thing you *must* remember when using a facet object
of the `printable_overrider_c` category is to constrain
it so that it only affects the types it aims to override.
////


Now we are almost ready to use our implementation.
There is just a detail you *must*
remember before using a facet object
of the `printable_overrider_c` category &#x2014; you must constrain
it to the types it aims to override.
If you don't that, __i.e.__ if you use the facet directly,
then Strf will apply it to all overridables types:


////
this is what happens:

then it will override all types that are overridables,



If you use the value `italian_bool_facet{}` directly, __i.e.__
without `strf::constrain`,
then all arguments to be printed would be passed to
`italian_bool_facet::make_input` &#x2014; raw strings,
integers, float points values, everything
would be and printed as "vero" or "falso"
( unless when it fails to compile for not being
convertible ).
////


[source,cpp,subs=normal]
----
auto str = strf::to_string.with(italian_bool_facet{})
    (true, '/', false, '/', 1, '/', 0, '/', 1.0, '/', 0.0, '/', (void*)0);
assert(str == "vero/falso/vero/falso/vero/falso/falso");
----
That's certainly not what we want. What we we want is to apply
`italian_bool_facet` to `bool` arguments only,
and we do do the following to achieve this:

[source,cpp,subs=normal]
----
template <typename T>
struct is_bool: std::is_same<T, strf::{representative_of_printable}<bool>> {};

constexpr auto italian_bool = strf::{constrain}<is_bool>(italian_bool_facet{});
----

// `strf::{representative_of_printable}<X>` is a type alias to
// `strf::{printable_traits_of}<X>::<<strf_hpp#PrintableTraits_representative_type,representative_type>>`,
// which is usually the same as
// `strf::{printable_traits_of}<X>::<<strf_hpp#PrintableTraits_forwarded_type,forwarded_type>>`,
// which is usually the same as
// `std::{remove_cvref_t}<X>`.
// In fact, `strf::{representative_of_printable}<bool>` is an alias to `bool`,
// but it is a better practice to use `strf::{representative_of_printable}` instead.

When `strf::{printable_traits_of}<X>` ( the __{PrintableTraits}__ class of `X` )
does not have the member type alias `<<strf_hpp#PrintableTraits_is_overridable,is_overridable>>`,
or it is an alias to `std::false_type`, then `X` is not overridable.
An example of an non-overridable type is `char`
( that's why `'\'` was printed as "\" and not as "vero" in the previous snippet ).
You can use `strf::{is_printable_and_overridable}<X>` to check at compile-time
whether a type `X` is overridable.

Ok, now thinks should work:

[source,cpp,subs=normal]
----
auto str = strf::to_string.with(italian_bool)
    (true, '/', false, '/', 1, '/', 0, '/', 1.0, '/', 0.0, '/', (void*)0);
assert(str == "vero/falso/1/0/1/0/0x0");

// and with formatting:

str = strf::to_string.with(italian_bool)
    ( strf::center(true, 10, '.'), '/'
    , strf::center(false, 10, '.') );
assert(str == "\...vero\.../..falso\...");
----

You may be wondering why printable types are overriden this way,
__i.e.__ through facets.
Couldn't this library have adoped another method,
like the __tag_invoke__ pattern ? The problem of using __tag_invoke__
for this purpose or any other customization point technique
is that the customization point is activated by the inclusion
of a header, and headers may be included unintentionally.
You definitely don't want to accidentally change how a value is printed.


