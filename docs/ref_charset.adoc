////
Copyright (C) (See commit logs on github.com/robhz786/strf)
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
////

== Character encodings

:transcoding_error_notifier: <<transcoding_error_notifier,transcoding_error_notifier>>
:transcoding_error_notifier_c: <<transcoding_error_notifier_c,transcoding_error_notifier_c>>
:transcoding_error_notifier_nullptr: <<transcoding_error_notifier_nullptr,transcoding_error_notifier_nullptr>>
:TranscodingErrorNotifierPtr: <<TranscodingErrorNotifierPtr,TranscodingErrorNotifierPtr>>

:transcode_flags: <<transcode_flags,transcode_flags>>
:transcode_stop_reason: <<transcode_stop_reason,transcode_stop_reason>>

:charset_id: <<charset_id,charset_id>>
:scid_utf8:         <<charset_id,scid_utf8>>
:scid_utf16:        <<charset_id,scid_utf16>>
:scid_utf32:        <<charset_id,scid_utf32>>
:scid_ascii:        <<charset_id,scid_ascii>>
:scid_iso_8859_1:   <<charset_id,scid_iso_8859_1>>
:scid_iso_8859_3:   <<charset_id,scid_iso_8859_3>>
:scid_iso_8859_15:  <<charset_id,scid_iso_8859_15>>
:scid_windows_1252: <<charset_id,scid_windows_1252>>


:transcode_dest: <<transcode_dest,transcode_dest>>
:transcode_f: <<charset_function_pointers,transcode_f>>
:transcode_size_f: <<charset_function_pointers,transcode_size_f>>
:unsafe_transcode_f: <<charset_function_pointers,unsafe_transcode_f>>
:unsafe_transcode_size_f: <<charset_function_pointers,unsafe_transcode_size_f>>

:transcode_result: <<transcode_result,transcode_result>>
:transcode_size_result: <<transcode_size_result,transcode_size_result>>

:decode_encode_result: <<decode_encode_result,decode_encode_result>>
:decode_encode_size_result: <<decode_encode_size_result,decode_encode_size_result>>

:write_replacement_char_f: <<charset_function_pointers,write_replacement_char_f>>
:validate_f: <<charset_function_pointers,validate_f>>
:encoded_char_size_f: <<charset_function_pointers,encoded_char_size_f>>
:encode_fill_f: <<charset_function_pointers,encode_fill_f>>
:decode_unit_f: <<charset_function_pointers,decode_unit_f>>
:encode_char_f: <<charset_function_pointers,encode_char_f>>
:encode_fill_f: <<charset_function_pointers,encode_fill_f>>
:codepoints_count_result: <<charset_function_pointers,codepoints_count_result>>
:count_codepoints_fast_f: <<charset_function_pointers,count_codepoints_fast_f>>
:count_codepoints_f: <<charset_function_pointers,count_codepoints_f>>
:decode_unit_f: <<charset_function_pointers,decode_unit_f>>
:find_transcoder_f: <<charset_function_pointers,find_transcoder_f>>
:facet_traits: <<facet_traits,facet_tratis>>
:facet_category: <<facet_category,facet_category>>
:count_codepoints_result: <<count_codepoints_result,count_codepoints_result>>

:static_transcoder: <<static_transcoder,static_transcoder>>
:static_charset: <<static_charset,static_charset>>
:static_charset: <<static_charset,static_charset>>

:dynamic_transcoder: <<dynamic_transcoder,dynamic_transcoder>>
:dynamic_charset_data: <<dynamic_charset_data,dynamic_charset_data>>
:dynamic_charset: <<dynamic_charset,dynamic_charset>>
:dynamic_charset: <<dynamic_charset,dynamic_charset>>

:find_transcoder: <<find_transcoder,find_transcoder>>
:decode_encode: <<decode_encode,decode_encode>>
:decode_encode_size: <<decode_encode_size,decode_encode_size>>
:unsafe_decode_encode: <<unsafe_decode_encode,unsafe_decode_encode>>
:unsafe_decode_encode_size: <<unsafe_decode_encode_size,unsafe_decode_encode_size>>

:Transcoder: <<Transcoder,Transcoder>>
:transcode: <<Transcoder_transcode,transcode>>
:unsafe_transcode: <<Transcoder_unsafe_transcode,unsafe_transcode>>
:transcode_func: <<Transcoder_transcode_func,transcode_func>>
:unsafe_transcode_func: <<Transcoder_unsafe_transcode_func,unsafe_transcode_func>>

:transcode_size: <<Transcoder_transcode_size,transcode_size>>
:unsafe_transcode_size: <<Transcoder_unsafe_transcode_size,unsafe_transcode_size>>
:transcode_size_func: <<Transcoder_transcode_size_func,transcode_size_func>>
:unsafe_transcode_func: <<Transcoder_unsafe_transcode_func,unsafe_transcode_func>>
:unsafe_transcode_size_func: <<Transcoder_unsafe_transcode_size_func,unsafe_transcode_size_func>>

:Charset: <<Charset,Charset>>
:to_u32: <<Charset_to_u32,to_u32>>
:from_u32: <<Charset_from_u32,from_u32>>

:code_unit: <<Charset_code_unit,code_unit>>
:charset_c: <<charset_c,charset_c>>

:utf_t: <<utf_t,utf_t>>
:utf: <<static_charset_constexpr,utf>>

=== Enumeration `charset_id` [[charset_id]]

[source,cpp]
----
namespace strf {
enum class charset_id : unsigned { };

constexpr charset_id  scid_ascii        = /* ... */;
constexpr charset_id  scid_utf8         = /* ... */;
constexpr charset_id  scid_utf16        = /* ... */;
constexpr charset_id  scid_utf32        = /* ... */;
constexpr charset_id  scid_iso_8859_1   = /* ... */;
constexpr charset_id  scid_iso_8859_2   = /* ... */;
constexpr charset_id  scid_iso_8859_3   = /* ... */;
constexpr charset_id  scid_iso_8859_4   = /* ... */;
constexpr charset_id  scid_iso_8859_5   = /* ... */;
constexpr charset_id  scid_iso_8859_6   = /* ... */;
constexpr charset_id  scid_iso_8859_7   = /* ... */;
constexpr charset_id  scid_iso_8859_8   = /* ... */;
constexpr charset_id  scid_iso_8859_9   = /* ... */;
constexpr charset_id  scid_iso_8859_10  = /* ... */;
constexpr charset_id  scid_iso_8859_11  = /* ... */;
constexpr charset_id  scid_iso_8859_13  = /* ... */;
constexpr charset_id  scid_iso_8859_14  = /* ... */;
constexpr charset_id  scid_iso_8859_15  = /* ... */;
constexpr charset_id  scid_iso_8859_16  = /* ... */;

constexpr charset_id  scid_windows_1250 = /* ... */;
constexpr charset_id  scid_windows_1251 = /* ... */;
constexpr charset_id  scid_windows_1252 = /* ... */;
constexpr charset_id  scid_windows_1253 = /* ... */;
constexpr charset_id  scid_windows_1254 = /* ... */;
constexpr charset_id  scid_windows_1255 = /* ... */;
constexpr charset_id  scid_windows_1256 = /* ... */;
constexpr charset_id  scid_windows_1257 = /* ... */;
constexpr charset_id  scid_windows_1258 = /* ... */;

} // namespace strf
----

=== Facet category `transcoding_error_notifier_c` [[transcoding_error_notifier_c]]

A facet of the `transcoding_error_notifier_c` category must satisfy the
__{TranscodingErrorNotifierPtr}__ type requirements.

[source,cpp,subs=normal]
----
namespace strf {
struct transcoding_error_notifier_c {
    static constexpr bool constrainable = false;
    static constexpr {transcoding_error_notifier_nullptr} get_default() noexcept {
        return {};
    }
};
} // namespace strf
----


==== Type requirement __TranscodingErrorNotifierPtr__ [[TranscodingErrorNotifierPtr]]

Given

* `X`, a __TranscodingErrorNotifierPtr__ type
* `x`, a const value of type `X`

The following must hold:

* `{facet_category}<X>` is a type alias to `transcoding_error_notifier_c`
* `X` is __MoveConstructible__

====
[source,cpp]
----
x.get()
----
[horizontal]
Return type:: `{transcoding_error_notifier}{asterisk}`
====

==== Struct `transcoding_error_notifier_nullptr` [[transcoding_error_notifier_nullptr]]

[source,cpp]
----
namespace strf {

struct transcoding_error_notifier_nullptr {
    using category = transcoding_error_notifier_c;

    constexpr transcoding_error_notifier* get() const { return nullptr; }
};

} // namespace strf
----

==== Struct `transcoding_error_notifier_ptr` [[transcoding_error_notifier_ptr]]

[source,cpp]
----
namespace strf {

struct transcoding_error_notifier_ptr {
    using category = transcoding_error_notifier_c;

    constexpr transcoding_error_notifier* get() const { return ptr; }

    transcoding_error_notifier* ptr = nullptr;
};

} // namespace strf
----

==== Class transcoding_error_notifier [[transcoding_error_notifier]]
[source,cpp,subs=normal]
----
namespace strf {

class transcoding_error_notifier {
public:
    virtual ~transcoding_error_notifier() {}

    virtual void invalid_sequence
        ( int code_unit_size
        , const char* source_charset_name
        , const void* sequence_ptr
        , std::ptrdiff_t code_units_count )
    {
    }

    virtual void unsupported_codepoint
        ( const char* destination_charset_name
        , unsigned codepoint )
    {
    }
};

} // namespace strf

----

=== Enum `transcode_flags` [[transcode_flags]]

[source,cpp,subs=normal]
----
namespace strf {

enum class transcode_flags {
    none = 0,
    lax_surrogate_policy = 1,
    stop_on_invalid_sequence = 1 << 1,
    stop_on_unsupported_codepoint = 1 << 2
};

constexpr transcode_flags  operator|(transcode_flags a, transcode_flags b) noexcept;
constexpr transcode_flags  operator&(transcode_flags a, transcode_flags b) noexcept;
constexpr transcode_flags& operator|=(transcode_flags& a, transcode_flags b) noexcept;
constexpr transcode_flags& operator&=(transcode_flags& a, transcode_flags b) noexcept;

constexpr bool with_strict_surrogate_policy(transcode_flags f) noexcept;
constexpr bool with_lax_surrogate_policy(transcode_flags f) noexcept;
constexpr bool with_stop_on_invalid_sequence(transcode_flags f) noexcept;
constexpr bool with_stop_on_unsupported_codepoint(transcode_flags f) noexcept;

} // namespace strf
----
The `transcode_flags` is a flags enum, __i.e.__ the value of a
`transcode_flags` can be a combination the above values.

=== Enum `transcode_stop_reason` [[transcode_stop_reason]]

[source,cpp,subs=normal]
----
namespace strf {
enum class transcode_stop_reason : std::uint32_t {
    completed,
    insufficient_output_space,
    unsupported_codepoint,
    invalid_sequence
};
----

The `transcode_stop_reason` is used in the return type of the several trancode
functions of the library with the following semantics:

* `transcode_stop_reason::completed` implies that all input has been transcoded
  (though some parts of it might be invalid and thus been replaced by the
   replacement character U+FFFD or `'?'` )
* `transcode_stop_reason::insufficient_output_space` implies that the transcoding stopped
  because the destination is too small
* `transcode_stop_reason::invalid_sequence` implies that both the input has an
  invalid sequence (__i.e.__ it is not conformant to its encoding ) and the flag
  `{transcode_flags}::stop_on_invalid_sequence` was set.
* `transcode_stop_reason::unsupported_codepoint` implies that both the input has a
  condepoint that not encodable in the destination character encoding ( though it
  is this a valid in the source character encoding, which may happen,
  for instance, when converting UTF-8 to ISO 8859-1) and the flag
  `{transcode_flags}::stop_on_unsupported_codepoint` was set.

The `transcode_stop_reason` is not a flags enum, __i.e.__ the value of a
`transcode_stop_reason` is always expected to one of the above values ( never a
combination of them )

=== Facet category template `charset_c` [[charset_c]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT>
struct charset_c {
    static constexpr bool constrainable = false;
    static constexpr {utf}<CharT> get_default() noexcept;
};

template <typename CharT, {charset_id} CSId>
struct {facet_traits}<{static_charset}<CharT, CSId>>
{
    using category = charset_c<CharT>;
};

template <typename CharT>
struct {facet_traits}<{dynamic_charset}<CharT>>
{
    using category = charset_c<CharT>;
};
} // namespace strf
----

For a type to be a facet of `charset_c<CharT>` it has
to be a _{Charset}_ type for `CharT`. The library provides
two class templates that satisfy that: `{static_charset}`
and `{dynamic_charset}`

=== Type alias template `transcode_dest` [[transcode_dest]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT>
using transcode_dest = {output_buffer}<CharT, 3>;

} // namespace strf
----

=== Struct template `transcode_result` [[transcode_result]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename SrcCharT, typename DstCharT>
struct transcode_result {
    const SrcCharT* src_ptr;
    DstCharT* dst_ptr;
    {transcode_stop_reason} stop_reason;
};

} // namespace strf
----

=== Struct template `transcode_size_result` [[transcode_size_result]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT>
struct transcode_size_result {
    std::ptrdiff_t ssize;
    const CharT* src_ptr;
    {transcode_stop_reason} stop_reason;
};

} // namespace strf
----


=== Struct template `count_codepoints_result` [[count_codepoints_result]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT>
struct count_codepoints_result {
    std::ptrdiff_t count;
    const CharT* ptr;
};

} // namespace strf
----



=== Aliases for pointers to functions [[charset_function_pointers]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename SrcCharT, typename DstCharT>
using transcode_f = {transcode_result}<CharT> ({asterisk})
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}{asterisk} err_notifier
    , {transcode_flags} flags );

template <typename SrcCharT, typename DstCharT>
using unsafe_transcode_f = transcode_f<SrcCharT, DstCharT>

template <typename SrcCharT>
using transcode_size_f = {transcode_size_result}<ScrCharT> ({asterisk})
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , std::ptrdiff_t limit
    , {transcode_flags} flags );

template <typename SrcCharT>
using unsafe_transcode_size_f = strf::transcode_size_f<SrcCharT, DstCharT>;

template <typename CharT>
using write_replacement_char_f = void({asterisk})( {transcode_dest}<CharT>& );

using validate_f = int ({asterisk})(char32_t ch);

using encoded_char_size_f = int ({asterisk}) (char32_t ch);

template <typename CharT>
using encode_char_f = CharT{asterisk}({asterisk}) (CharT{asterisk} dest, char32_t ch);

template <typename CharT>
using encode_fill_f = void ({asterisk})
    ( {transcode_dest}<CharT>&
    , std::ptrdiff_t count
    , char32_t ch );

template <typename CharT>
using count_codepoints_fast_f = count_codepoints_result<CharT> ({asterisk})
    ( const CharT{asterisk} src
    , const CharT{asterisk} src_end
    , std::ptrdiff_t max_count );

template <typename CharT>
using count_codepoints_f = count_codepoints_result<CharT> ({asterisk})
    ( const CharT{asterisk} src
    , const CharT{asterisk} src_end
    , std::ptrdiff_t max_count );

template <typename CharT>
using decode_unit_f = char32_t ({asterisk}) ( CharT );

template <typename SrcCharT, typename DstCharT>
using find_transcoder_f = {dynamic_transcoder}<SrcCharT, DstCharT> ({asterisk})
    ( {charset_id} );

} // namespace strf
----

=== Type requirement _Transcoder_ [[Transcoder]]

Given

* `SrcCharT`, one of the types: `char`, `char8_t`, `char16_t`, `char32_t` or `wchar_t`
* `DstCharT`, one of the types: `char`, `char8_t`, `char16_t`, `char32_t` or `wchar_t`
* `X`, a _Transcoder_ type from `SrcCharT` to `DstCharT`
* `x`, an expression of type `X` or `const X`
* `src`, a value of type `const SrcCharT*`
* `src_end`, a value of type `const SrcCharT*` pointing immediately after
             the last character of the string that begins at `str`
* `dst`, a value of type `DstCharT*`
* `dst_end`, a value of type `DstCharT*` pointing immediately after
             the last element of the array that begins at `dst`
* `limit` is value of type `std::ptrdiff_t`
* `err_notifier`, is a pointer of type `{transcoding_error_notifier}`
* `flags`, a value of type `{transcode_flags}`

The following must hold:

* `X` is https://en.cppreference.com/w/cpp/named_req/CopyConstructible[CopyConstructible].
* `X` supports the following syntax and semantics:

[[Transcoder_src_code_unit]]
====
[source,cpp]
----
X::src_code_unit
----
A type alias to `SrcCharT`
====

[[Transcoder_dst_code_unit]]
====
[source,cpp]
----
X::dst_code_unit
----
A type alias to `DstCharT`
====

[[Transcoder_transcode]]
====
[source,cpp]
----
x.transcode(src, src_end, dst, dst_end, err_notifier, flags)
----
Precondition:: `x.transcode_func() != nullptr` is `true`
Return type:: `{transcode_result}`
Effect:: Converts the content of `src` from one encoding to another writing
the result to `dst`.
+
--
As this function iterates from `src` to `src_end`, if it reads a sequence that is invalid
( non-conformant to the source character encoding ) then it calls
`err_notifier\-><<transcoding_error_notifier,invalid_sequence>>(ch_size, name, seq, count)`,
if `err_notifer` is not null, where:

* `ch_size` is equal to `sizeof(SrcCharT)`
* `name` is the name of the source character encoding (__e.g.__, `"UTF-8"`)
* `seq` points to the first character of the invalid sequence.
* `count` is number of code units of the invalid sequence
**  Note: The value of both following expression shall be `true`:
+
----
(const SrcCharT*)seq >= src
----
+
----
(const SrcCharT*)seq + count <= src_end
----

After that, if `flags` has the bit flag `stop_on_invalid_sequence`, then the function shall
stop and return a value with `<<transcode_result,stop_reason>>` equal to
`transcode_stop_reason::invalid_sequence`. Otherwise, the function shall write a
replacement character (which is U+FFFD or `'?'`, depending on the destination encoding)
and continue the iteration after the invalid sequence. Note: the presence of a
surrogate codepoint ( that is considered to be and invalid sequence )
shall not be considered an invalid sequence if the flag
`transcode_flags::lax_surrogate_policy` is set in `flags`.

Similarly, when the function reads a codepoint that is not supported by the destination
encoding but also not equal U+FFFD, it calls (if `err_notifier` is not null)
`err_notifier\-><<transcoding_error_notifier,unsupported_codepoint>>(dst_charset_name, code)`,
where `dst_charset_name` is the name of the destination character encoding,
and `code` is such codepoint.

After that, if `flags` has the flag `stop_on_unsupported_codepoint`, then the function shall
stop and return a value with `<<transcode_result,stop_reason>>` equal to
`transcode_stop_reason::unsupported_codepoint`. Otherwise, the function shall write a
replacement character (which is U+FFFD or `'?'`, depending on the destination encoding)
and continue the iteration after the usupported codepoint.

If the input contains the U+FFFD codepoint then it should not be treated as unsupported
even if it is. This means that `err_notifier\->unsupported_codepoint`
shall not be called in this case, nor should this cause the interation to stop.
Instead, the function should just write `'?'` when the destination encoding
does not support U+FFFD

`transcode_stop_reason::insufficient_output_space` should only be returned if
there is still something to be written but there is no space left
(__i.e.__, the distance `(dst_end - dst)` is too small).
For instance, if the input starts with an invalid sequence and
`flags` has `stop_on_invalid_sequence` set, then, even if
`dst_end` is equal to `dst` the returned `stop_reason` shall **not** be
`transcode_stop_reason::insufficient_space`; it should instead be
shall be `transcode_stop_reason::invalid_sequence`.
--

Return value:: A value `res` such that
+
* `res.**stop_reason**` is `transcode_stop_reason::completed` unless for
   any of the cases explained above.
* `res.**src_ptr**` points immediately after the last element in the range `[src, src_end)`
           that has been transcoded.
* `res.**dst_ptr**` points immediately after the last element in the range `[dst, dst_end)`
           that has been written
====

[[Transcoder_unsafe_transcode]]
====
[source,cpp]
----
x.unsafe_transcode(src, src_end, dst, dst_end, err_notifier, flags)
----
Preconditions::

* The input has no invalid sequence
* `x.unsafe_transcode_() != nullptr` is `true`

Return type:: `{transcode_result}`

Effect:: Exactly the same as `x.transcode(src, src_end, dst, dst_end, err_notifier, flags)`,
except that the behaviour is undefined if the input contains any
invalid sequence.
+
Note that if the flag `transcode_flags::lax_surrogate_policy` is set
in `flags`, then the presence of a surrogate codepoint in `[src, src_end)`
is not to be considered as an invalid sequence, and thus shall **not** cause
undefined behaviour.

====
[[Transcoder_transcode_size]]
====
[source,cpp]
----
x.transcode_size(src, src_end, limit, flags)
----
Precondition:: `x.transcode_func() != nullptr` is `true`
Return type:: `{transcode_size_result}`
Return value:: A value `res` such that
+
--
* `res.**src_ptr**` is equal to `__tr_res__.src_ptr` ( see below )
* `res.**stop_reason**` is equal to `__tr_res__.stop_reason`
* `res.**ssize**` equals to `__tr_res__.dst_ptr - dst`

, where `__tr_res__` is the value that
`x.transcode(src, src_end, dst, dst + limit, nullptr, flags)`
would return, assuming `[dst, dst + limit)` is a valid memory area.
--
====
[[Transcoder_unsafe_transcode_size]]
====
[source,cpp]
----
x.unsafe_transcode_size(src, src_end, limit, flags)
----
[horizontal]
Precondition::
* The input has no invalid sequence
* `x.unsafe_transcode_() != nullptr` is `true`
Return type:: `{transcode_size_result}`

Effect:: Exactly the same as `x.transcode_size(src, src_end, limit, flags)`,
except that the behaviour is undefined if the input contains any
invalid sequence.
+
Note that if the flag `transcode_flags::lax_surrogate_policy` is set
in `flags`, then the presence of a surrogate codepoint in `[src, src_end)`
is not to be considered as an invalid sequence, and thus shall **not** cause
undefined behaviour.
====




[[Transcoder_transcode_func]]
====
[source,cpp]
----
x.transcode_func()
----
[horizontal]
Return type:: `{transcode_f}<SrcCharT, DstCharT>`
Return value:: A function pointer such that
   `x.transcode_func() (src, src_end, dst, dst_end, derr_notifier, flags)`
   has the same effect as
   `x.<<Transcoder_transcode,transcode>>(src, src_end, dst, dst_end, err_notifier, flags)`.
====

[[Transcoder_unsafe_transcode_func]]
====
[source,cpp]
----
x.unsafe_transcode_func()
----
[horizontal]
Return type:: `{unsafe_transcode_f}<SrcCharT, DstCharT>`
Return value:: A function pointer such that
   `x.unsafe_transcode_func() (src, src_end, dst, dst_end, err_notifier, flags)`
   has the same effect as
   `x.<<Transcoder_unsafe_transcode,unsafe_transcode>>(src, src_end, dst, dst_end, err_notifier, flags)`.
====

[[Transcoder_transcode_size_func]]
====
[source,cpp]
----
x.transcode_size_func()
----
[horizontal]
Return type:: `{transcode_size_f}<SrcCharT>`
Return value:: A function pointer such that
               `x.transcode_size_func() (src, src_end, limit, flags)` has the same
               effect as `x.<<Transcoder_transcode_size,transcode_size>>(src, src_end, limit, flags)`.
====
[[Transcoder_unsafe_transcode_size_func]]
====
[source,cpp]
----
x.unsafe_transcode_size_func()
----
[horizontal]
Return type:: `{unsafe_transcode_size_f}<SrcCharT>`
Return value:: A function pointer such that
               `x.unsafe_transcode_size_func() (src, src_end, limit, flags)` has the same
               effect as `x.<<Transcoder_unsafe_transcode_size,unsafe_transcode_size>>(src, src_end, limit, flags)`.
====

'''
[[Transcoder_null]]
====
.Definition
A *null transcoder* is an object of an __Transcoder__
type where the `transcode_func` function returns `nullptr`.
====

NOTE: There are two class templates that satisfy _Transcoder_:
      `{static_transcoder}` and `{dynamic_transcoder}`.

=== Type requirement _Charset_ [[Charset]]

An object whose type is a _Charset_ represents a character encoding.
In this documentation the terms _charset_, _encoding_ and
_character encoding_ are used interchangeably.

Given

* `CharT`, one of the follwoing types: `char`, `char8_t`, `char16_t`, `char32_t` or `wchar_t`
* `OtherCharT`, one of the folowing types : `char`, `char8_t`, `char16_t` or `wchar_t`
* `X`, a _Charset_ type for type `CharT`
* `x`, an expression of type `X` or `const X`
* `ptr`, a value of type `CharT{asterisk}`
* `src`, a value of type `const CharT{asterisk}`
* `src_end`, a value of type `const SrcCharT*` pointing immediately after
             the last character of the string that begins at `str`
* `dest`, an lvalue reference of type `{transcode_dest}<CharT>`
* `src_size`, a value of type `std::ptrdiff_t` equal to the size of
              the array pointed by `src`
* `count`, a value of type `std::ptrdiff_t`
* `max_count`, a value of type `std::ptrdiff_t`
* `ch32`, a value of type `char32_t`
* `ch`, a value of type `CharT`
* `cs_id`, value of type `{charset_id}`

The following must hold:

* `X` is either an instance of the `{static_transcoder}` or `{dynamic_charset}` class template
* `X` is https://en.cppreference.com/w/cpp/named_req/CopyConstructible[CopyConstructible]
* `{facet_category}<X>` must be `{charset_c}<CharT>`
* `X` satisfies the following syntax and semantics:

[[Charset_code_unit]]
====
[source,cpp]
----
X::code_unit
----
Type alias to `CharT`
====
[[Charset_id]]
====
[source,cpp]
----
x.id()
----
[horizontal]
Return type:: `{charset_id}`
Return value:: The `{charset_id}` that corresponds to this encoding.
====

[[Charset_name]]
====
[source,cpp]
----
x.name()
----
[horizontal]
Return type:: `const char*`
Return value:: The name of this encoding. Examples: `"UTF-8"`, `"ASCII"`, `"ISO-8859-1"`, `"windows-1252"`.
====

[[Charset_replacement_char]]
====
[source,cpp]
----
x.replacement_char()
----
[horizontal]
Return type:: `char32_t`
Return value:: The character used to signalize an error. Usually it is the https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character[replacement character &#xFFFD;] if it is supported by this encoding, or the question mark `'?'` otherwise.
====
====
[source,cpp]
----
x.write_replacement_char(dest)
----
[horizontal]
Effect:: Writes into `dest` the codepoint returned by `x.replacement_char()` encoded in this charset.
Return type:: `void`
====
====
[source,cpp]
----
x.replacement_char_size()
----
[horizontal]
Return type:: `int`
Return value:: The number of characters that `x.write_replacement_char(dest)` writes into `dest`.
====
====
[source,cpp]
----
x.encoded_char_size(ch32)
----
[horizontal]
Return type:: `int`
Return value:: The size of the string containing the UTF-32 character `ch32`,
               if `ch32` is supported in this encoding. Otherwise,
               `x.replacement_char_size()`.
Postcondition:: The return value must be greater than zero.
Note:: This function does not check whether `ch32` is a legal code point, only if
       it is possible to write it in this encoding. For example, if this is encoding
       is UTF-32, this function considers as valid any value for `ch32` ( even if
       is is greater than `0x10FFFF` ). Surrogates characters are also not sanitized.
====
====
[source,cpp]
----
x.validate(ch32)
----
[horizontal]
Return type:: `int`
Return value:: The size of the string encoding `ch32`,
               if `ch32` is a valid codepoint and supported in this encoding. Otherwise, `-1`.
====
====
[source,cpp]
----
x.encode_char(ptr, ch32)
----
[horizontal]
Effect:: Encodes into `ptr` the UTF-32 character `ch32`, without sanitizing.
         If this encoding is not able to encode `ch32`,
         then encodes instead the return of `x.replacement_char()`.
Return type:: `CharT*`
Postcondition:: `x.encode_char(ptr, ch32) - ptr == x.encoded_char_size(ch32)` is `true`.
Return value:: The position just after the last writen character.
Note:: This function does not check whether `ch32` is a legal code point, only if
       it is possible to write it in this encoding. For example, if this is encoding
       is UTF-32, this function considers as valid any value for `ch32` ( even if
       is is greater than `0x10FFFF` ). Surrogates characters are also not sanitized.
====
====
[source,cpp]
----
x.encode_fill(dest, count, ch32)
----
[horizontal]
Effect:: Writes `count` times into `dest` the UTF-32 character `ch32` encoded into
         this encoding, if it is supported. Otherwise writes `x.replacement_char()`
         instead.
Return type:: `void`
Note:: `encode_fill` does not check whether `ch32` is a legal code point, only if
       it is possible to write it in this encoding. For example, if this is encoding
       is UTF-32, `encode_fill` considers as valid any value for `ch32` ( even if
       is is greater than `0x10FFFF` ). Surrogates characters are also not sanitized.
====
[[Charset_count_codepoints_fast]]
====
[source,cpp]
----
x.count_codepoints_fast(src, src_end, max_count)
----
[horizontal]
Return type:: `{count_codepoints_result}<CharT>`
Return value:: `{c, ptr}`, where:

* `c` is the number of Unicode code points in `src`,
  if such value is less than `max_count`.
  Otherwise, `c` is equal to `max_count`.
* `ptr` is the greatest pointer not greater than `src_end` such that
   `x.count_codepoints_fast(src, ptr, std::numeric_limits<std::ptrdiff_t>::max()).count`
   is equal to `c`.

Posconditions::

* `c \<= max_count` is `true`
* `ptr \<= src_end` is `true`

Note::
If the input is non-conformant to the corresponding character encoding,
this function may return an incorrect value. For instance, for UTF-8
this function may simply count the bytes that are not continuation bytes.
====
[[Charset_count_codepoints]]
====
[source,cpp]
----
x.count_codepoints(src, src_end, max_count)
----
[horizontal]
Effect:: Counts the codepoints until it is equal to `max_count`.

Return type:: `{count_codepoints_result}<CharT>`
Return value:: `{c, ptr}`, where:
* `c` is equal to `std::min(max_count, u32len)`, where `u32len` is the
   length of the UTF-32 string that would be generated by converting
   `src` from this encoding to UTF-32.
* `ptr` is the greatest pointer not greater than `src_end` such that
  `x.count_codepoints(src, ptr, std::numeric_limits<std::ptrdiff_t>::max()).count`
   is equal to `c`.
Posconditions::
* `c \<= max_count` is `true`
* `ptr \<= src_end` is `true`

====
[[Charset_decode_unit]]
====
[source,cpp]
----
x.decode_unit(ch)
----
[horizontal]
Effect:: Decodes `ch` from this encoding to UTF-32.
         If `ch` is an invalid character that is not a surrogate, returns U'\uFFFD'
         ( surrogates codepoints as not sanitized ).
Return type:: `char32_t`
====

====
[source,cpp]
----
x.encode_char_func()
----
[horizontal]
Return type:: `{encode_char_f}<CharT>`
Return value:: A function pointer such that `x.encode_char_func() (ch32)` has
               the same effect as `x.encode_char(ch32)`.
====
====
[source,cpp]
----
x.encode_fill_func()
----
[horizontal]
Return type:: `{encode_fill_f}<CharT>`
Return value:: A function pointer such that `x.encode_fill_func() (dest, count, ch32)`
               has the same effect as `x.encode_fill(dest, count, ch32)`.
====
====
[source,cpp]
----
x.write_replacement_char_func()
----
[horizontal]
Return type:: `{write_replacement_char_f}<CharT>`
Return value:: A function pointer such that `x.write_replacement_char_func() (dest)`
               has the same effect as `x.write_replacement_char(dest)`
====
====
[source,cpp]
----
x.validate_func()
----
[horizontal]
Return type:: `{validate_f}`
Return value:: A function pointer such that `x.validate_func() (ch32)`
               returns the same value as `x.validate(ch32)`
====
[[Charset_from_u32]]
====
[source,cpp]
----
x.from_u32()
----
[horizontal]
Return type:: A __{Transcoder}__ type `T`, such that
              `T::<<Transcoder_src_code_unit,src_code_unit>>` is `char32_t` and
              `T::<<Transcoder_dst_code_unit,dst_code_unit>>` is `CharT`
Return value:: A transcoder that converts UTF-32 to this encoding.
====
[[Charset_to_u32]]
====
[source,cpp]
----
x.to_u32()
----
[horizontal]
Return type:: A __{Transcoder}__ type `T`, such that
              `T::<<Transcoder_src_code_unit,src_code_unit>>` is `CharT` and
              `T::<<Transcoder_dst_code_unit,dst_code_unit>>` is `char32_t`
Return value:: A transcoder that converts this encoding to UTF-32.
====
[[Charset_sanitizer]]
====
[source,cpp]
----
x.sanitizer()
----
[horizontal]
Return type:: A __{Transcoder}__ from `CharT` to `CharT`
Return value:: A transcoder that converts this encoding to this encoding,
               __i.e.__ a sanitizer of this encoding.
====
[[Charset_find_transcoder_to]]
====
.( Optional )
[source,cpp,subs=normal]
----
x.find_transcoder_to({tag}<OtherCharT>, cs_id)
----
[horizontal]
Return type:: `{dynamic_transcoder}<CharT, OtherCharT>`
Return value:: A transcoder that converts this encoding to the encoding
               corresponding to `cs_id`, or an
               <<Transcoder_null,null transcoder>>.
====

[[Charset_find_transcoder_from]]
====
.( Optional )
[source,cpp,subs=normal]
----
x.find_transcoder_from({tag}<OtherCharT>, cs_id)
----
[horizontal]
Return type:: `{dynamic_transcoder}<OtherCharT, CharT>`
Return value:: A transcoder that converts the encoding corresponding to
               `cs_id` to this encoding, or an
               <<Transcoder_null,null transcoder>>.
====

[[Charset_to_dynamic]]
====
[source,cpp,subs=normal]
----
x.to_dynamic()
----
[horizontal]
Return type:: `{dynamic_transcoder}<CharT>`
Return value:: A `{dynamic_charset}<CharT>` object equivalent to this one.
====



IMPORTANT: You shall not create an _Charset_ for `char32_t`, since `char32_t`
           is reserved for UTF-32.
           The library internaly assumes in many occasions that the encoding
           is UTF-32 when `CharT` is `char32_t`.

=== Class template `static_transcoder` [[static_transcoder]]

[source,cpp,subs=normal]
----
template <class SrcCharT, class DstCharT, {charset_id} Src, {charset_id} Dest>
class static_transcoder;

// sanitizers
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_ascii, scid_ascii>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_1, scid_iso_8859_1>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_2, scid_iso_8859_2>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_3, scid_iso_8859_3>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_4, scid_iso_8859_4>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_5, scid_iso_8859_5>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_6, scid_iso_8859_6>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_7, scid_iso_8859_7>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_8, scid_iso_8859_8>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_9, scid_iso_8859_9>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_10, scid_iso_8859_10>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_11, scid_iso_8859_11>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_13, scid_iso_8859_13>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_14, scid_iso_8859_14>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_15, scid_iso_8859_15>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_16, scid_iso_8859_16>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1250, scid_windows_1250>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1251, scid_windows_1251>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1252, scid_windows_1252>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1253, scid_windows_1253>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1254, scid_windows_1254>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1255, scid_windows_1255>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1256, scid_windows_1256>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1257, scid_windows_1257>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1258, scid_windows_1258>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf8, scid_utf8>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf16, scid_utf16>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_utf32>;

// to UTF-32
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_ascii, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_1, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_2, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_3, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_4, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_5, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_6, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_7, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_8, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_9, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_10, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_11, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_13, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_14, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_15, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_iso_8859_16, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1250, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1251, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1252, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1253, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1254, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1255, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1256, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1257, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_windows_1258, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf8, scid_utf32>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf16, scid_utf32>;

// from UTF-32
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_ascii>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_1>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_2>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_3>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_4>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_5>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_6>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_7>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_8>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_9>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_10>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_11>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_13>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_14>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_15>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_iso_8859_16>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_windows_1250>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_windows_1251>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_windows_1252>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_windows_1253>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_windows_1254>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_windows_1255>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_windows_1256>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_windows_1257>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_windows_1258>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_utf8>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf32, scid_utf16>;

// others
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf8, scid_utf16>;
template <class SrcCharT, class DstCharT>
class static_transcoder<SrcCharT, DstCharT, scid_utf16, scid_utf8>;
----
`static_transcoder` class template has no generic implementation.
Instead, the library provides the template specializations listed above.
All of them are empty classes, and are __{Transcoder}__, and their
member functions `<<Transcoder_transcode_func, transcode_func>>`
and `<<Transcoder_transcode_size_func,transcode_size_func>>`
never return `nullptr`.

=== Class template `static_charset` [[static_charset]]

[source,cpp,subs=normal]
----
template <class CharT, {charset_id}>
class static_charset;

template <class CharT> class static_charset<CharT, scid_ascii>;
template <class CharT> class static_charset<CharT, scid_iso_8859_1>;
template <class CharT> class static_charset<CharT, scid_iso_8859_2>;
template <class CharT> class static_charset<CharT, scid_iso_8859_3>;
template <class CharT> class static_charset<CharT, scid_iso_8859_4>;
template <class CharT> class static_charset<CharT, scid_iso_8859_5>;
template <class CharT> class static_charset<CharT, scid_iso_8859_6>;
template <class CharT> class static_charset<CharT, scid_iso_8859_7>;
template <class CharT> class static_charset<CharT, scid_iso_8859_8>;
template <class CharT> class static_charset<CharT, scid_iso_8859_9>;
template <class CharT> class static_charset<CharT, scid_iso_8859_10>;
template <class CharT> class static_charset<CharT, scid_iso_8859_11>;
template <class CharT> class static_charset<CharT, scid_iso_8859_13>;
template <class CharT> class static_charset<CharT, scid_iso_8859_14>;
template <class CharT> class static_charset<CharT, scid_iso_8859_15>;
template <class CharT> class static_charset<CharT, scid_iso_8859_16>;
template <class CharT> class static_charset<CharT, scid_windows_1250>;
template <class CharT> class static_charset<CharT, scid_windows_1251>;
template <class CharT> class static_charset<CharT, scid_windows_1252>;
template <class CharT> class static_charset<CharT, scid_windows_1253>;
template <class CharT> class static_charset<CharT, scid_windows_1254>;
template <class CharT> class static_charset<CharT, scid_windows_1255>;
template <class CharT> class static_charset<CharT, scid_windows_1256>;
template <class CharT> class static_charset<CharT, scid_windows_1257>;
template <class CharT> class static_charset<CharT, scid_windows_1258>;
template <class CharT> class static_charset<CharT, scid_utf8>;
template <class CharT> class static_charset<CharT, scid_utf16>;
template <class CharT> class static_charset<CharT, scid_utf32>;
----

`static_charset` class template has no generic implementation.
Instead, the library provides the template specializations listed above.
All of them are empty classes, and are __{Charset}__.

=== Class template `dynamic_transcoder` [[dynamic_transcoder]]

[source,cpp,subs=normal]
----
namespace strf {

template <class SrcCharT, class DstCharT>
class dynamic_transcoder {
public:
    constexpr dynamic_transcoder() noexcept;

    constexpr dynamic_transcoder
        ( const dynamic_transcoder& other) noexcept = default;

    template <{charset_id} SrcCh, {charset_id} DstCh>
    constexpr explicit dynamic_transcoder
        ( {static_transcoder}<SrcCh, DestCh> st );

    {transcode_result}<SrcCharT, DstCharT> transcode
        ( const SrcCharT{asterisk} src
        , const SrcCharT{asterisk} src_end
        , DstCharT* dst
        , DstCharT* dst_end
        , {transcoding_error_notifier}{asterisk} err_notifier
        , {transcode_flags} flags ) const;

    {transcode_result}<SrcCharT, DstCharT> unsafe_transcode
        ( const SrcCharT{asterisk} src
        , const SrcCharT{asterisk} src_end
        , DstCharT* dst
        , DstCharT* dst_end
        , {transcoding_error_notifier}{asterisk} err_notifier
        , {transcode_flags} flags ) const;

    {transcode_size_result}<SrcCharT> transcode_size
        ( const SrcCharT{asterisk} src
        , const SrcCharT{asterisk} src_end
        , std::ptrdiff_t limit
        , {transcode_flags} flags ) const;

    {transcode_size_result}<SrcCharT> unsafe_transcode_size
        ( const SrcCharT{asterisk} src
        , const SrcCharT{asterisk} src_end
        , std::ptrdiff_t limit
        , {transcode_flags} flags ) const;

    constexpr {transcode_f}<SrcCharT, DstCharT> transcode_func() const noexcept;
    constexpr {transcode_size_f}<SrcCharT> transcode_size_func() const noexcept;
};

} // namespace strf
----

====
[source,cpp,subs=normal]
----
constexpr dynamic_transcoder() noexcept;
----
Default constructor
[horizontal]
Postconditions::
* `transcode_func() == nullptr`
* `transcode_size_func() == nullptr`
====

====
[source,cpp,subs=normal]
----
constexpr dynamic_transcoder
    ( const dynamic_transcoder& other) noexcept;
----
Trivial copy constructor
[horizontal]
Postconditions::
* `transcode_func() == other.transcode_func()`
* `transcode_size_func() == other.transcode_size_func()`
====

====
[source,cpp,subs=normal]
----
template <{charset_id} Src, {charset_id} Dest>
constexpr explicit dynamic_transcoder
    ( {static_transcoder}<Src, Dest> other );
----
[horizontal]
Postconditions::
* `transcode_func() == other.transcode_func()`
* `transcode_size_func() == other.transcode_size_func()`
====

====
[source,cpp,subs=normal]
----
{transcode_result}<SrcCharT, DstCharT> transcode
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , DstCharT{asterisk} dst
    , DstCharT{asterisk} dst_end
    , {transcoding_error_notifier}{asterisk} err_notifier
    , {transcode_flags} flags ) const;
----
[horizontal]
Effect:: Calls `transcode_func()(src, src_end, dst, dst_end, err_notifier, flags)`
====

====
[source,cpp,subs=normal]
----
{transcode_result}<SrcCharT, DstCharT> unsafe_transcode
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , DstCharT{asterisk} dst
    , DstCharT{asterisk} dst_end
    , {transcoding_error_notifier}{asterisk} err_notifier
    , {transcode_flags} flags ) const;
----
[horizontal]
Effect:: Calls `unsafe_transcode_func()(src, src_end, dst, dst_end, err_notifier, flags)`
====

====
[source,cpp,subs=normal]
----
{transcode_size_result}<SrcCharT> transcode_size
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , std::ptrdiff_t limit
    , {transcode_flags} flags ) const;
----
[horizontal]
Effect:: Calls `transcode_size_func()(src, src_end, limit, flags)`
====
====
[source,cpp,subs=normal]
----
{transcode_size_result}<SrcCharT> unsafe_transcode_size
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , std::ptrdiff_t limit
    , {transcode_flags} flags ) const;
----
[horizontal]
Effect:: Calls `unsafe_transcode_size_func()(src, src_end, limit, flags)`
====



=== Struct template `dynamic_charset_data` [[dynamic_charset_data]]

[source,cpp,subs=normal]
----
template <class CharT>
struct dynamic_charset_data {
    const char* name;
    {charset_id} id;
    char32_t replacement_char;
    int replacement_char_size;
    {validate_f} validate_func;
    {encoded_char_size_f} encoded_char_size_func;
    {encode_char_f}<CharT> encode_char_func;
    {encode_fill_f}<CharT> encode_fill_func;
    {count_codepoints_fast_f}<CharT> count_codepoints_fast_func;
    {count_codepoints_f}<CharT> count_codepoints_func;

    {write_replacement_char_f}<CharT> write_replacement_char_func;
    {decode_unit_f}<CharT> decode_unit_func;

    {dynamic_transcoder}<CharT, CharT> sanitizer;
    {dynamic_transcoder}<char32_t, CharT> from_u32;
    {dynamic_transcoder}<CharT, char32_t> to_u32;

    {find_transcoder_f}<wchar_t, CharT> find_transcoder_from_wchar;
    {find_transcoder_f}<CharT, wchar_t> find_transcoder_to_wchar;

    {find_transcoder_f}<char16_t, CharT> find_transcoder_from_char16;;
    {find_transcoder_f}<CharT, char16_t> find_transcoder_to_char16;

    {find_transcoder_f}<char, CharT> find_transcoder_from_char;
    {find_transcoder_f}<CharT, char> find_transcoder_to_char;

#if defined (__cpp_char8_t)
    {find_transcoder_f}<char8_t, CharT> find_transcoder_from_char8;
    {find_transcoder_f}<CharT, char8_t> find_transcoder_to_char8;
#else
    void* find_transcoder_from_char8 = nullptr;
    void* find_transcoder_to_char8 = nullptr;
#endif

};
----
=== Class template `dynamic_charset` [[dynamic_charset]]
[source,cpp,subs=normal]
----
template <class CharT>
class dynamic_charset {
public:

    using code_unit = CharT;

    explicit dynamic_charset(const dynamic_charset& other) = default;

    explicit dynamic_charset(const {dynamic_charset_data}<CharT>& d );

    template <charset_id CharsetID>
    explicit dynamic_charset(const {static_charset}<CharT, CharsetID>& d );

    dynamic_charset& operator=(const dynamic_charset& other) noexcept;

    bool operator==(const dynamic_charset& other) const noexcept;

    bool operator!=(const dynamic_charset& other) const noexcept;

    void swap(dynamic_charset& other) noexcept;

    dynamic_charset to_dynamic() const noexcept;

    const char{asterisk} name() const noexcept;

    constexpr {charset_id} id() const noexcept;

    constexpr char32_t replacement_char() const noexcept;

    constexpr int replacement_char_size() const noexcept;

    constexpr int validate(char32_t ch) const; // noexcept

    constexpr int encoded_char_size(char32_t ch) const; // noexcept

    code_unit{asterisk} encode_char(code_unit{asterisk} dest, char32_t ch) const; // noexcept

    void encode_fill
        ( {transcode_dest}<CharT>& dest, std::ptrdiff_t count, char32_t ch ) const;

    std::ptrdiff_t count_codepoints_fast
        ( const code_unit{asterisk} src, const code_unit{asterisk} src_end
        , std::ptrdiff_t max_count ) const;

    std::ptrdiff_t count_codepoints
        ( const code_unit{asterisk} src, const code_unit{asterisk} src_end
        , std::ptrdiff_t max_count ) const;

    void write_replacement_char({transcode_dest}<CharT>& dest) const;

    char32_t decode_unit(code_unit ch) const;

    {encode_char_f}<CharT> encode_char_func() const noexcept;

    {encode_fill_f}<CharT> encode_fill_func() const noexcept;

    {write_replacement_char_f}<CharT> write_replacement_char_func() const noexcept;

    {dynamic_transcoder}<char32_t, CharT> from_u32() const;

    {dynamic_transcoder}<CharT, char32_t> to_u32() const;

    {dynamic_transcoder}<CharT, CharT> sanitizer() const;

    {dynamic_transcoder}<CharT, wchar_t> find_transcoder_to
        ( {tag}<wchar_t>, {charset_id} id) const;

    {dynamic_transcoder}<wchar_t, CharT> find_transcoder_from
        ( {tag}<wchar_t>, {charset_id} id) const;

    {dynamic_transcoder}<CharT, char16_t> find_transcoder_to
        ( {tag}<char16_t>, {charset_id} id) const;

    {dynamic_transcoder}<char16_t, CharT> find_transcoder_from
        ( {tag}<char16_t>, {charset_id} id) const;

    {dynamic_transcoder}<CharT, char> find_transcoder_to
        ( {tag}<char>, {charset_id} id) const;

    {dynamic_transcoder}<char, CharT> find_transcoder_from
        ( {tag}<char>, {charset_id} id) const;

#if defined (__cpp_char8_t)
    {dynamic_transcoder}<CharT, char8_t> find_transcoder_to
        ( {tag}<char8_t>, {charset_id} id) const;

    {dynamic_transcoder}<char8_t, CharT> find_transcoder_from
        ( {tag}<char8_t>, {charset_id} id) const;
#endif

private:

    const {dynamic_charset_data}{asterisk} data; // exposition only
};
----

====
[source,cpp,subs=normal]
----
dynamic_charset(const dynamic_charset& other);
----
Trivial copy constructor.
[horizontal]
Effect:: `this\->data = other.data`
====
====
[source,cpp,subs=normal]
----
dynamic_charset(const {dynamic_charset_data}<CharT>& d);
----
[horizontal]
Effect:: `this\->data = d`
====
====
[source,cpp,subs=normal]
----
template <charset_id CharsetID>
dynamic_charset(const {static_charset}<CharT, CharsetID>& cs);
----
Equivalent to `dynamic_charset(cs.to_dynamic())`
====
====
[source,cpp,subs=normal]
----
dynamic_charset& operator=(const dynamic_charset& other) noexcept
----
[horizontal]
Effect:: `this\->data = other.data`
====
====
[source,cpp,subs=normal]
----
bool operator==(const dynamic_charset& other) const noexcept;
----
[horizontal]
Return value:: `this\->data == other.data`
====
====
[source,cpp,subs=normal]
----
bool operator!=(const dynamic_charset& other) const noexcept;
----
[horizontal]
Return value:: `this\->data != other.data`
====
====
[source,cpp,subs=normal]
----
void swap(dynamic_charset& other) noexcept;
----
[horizontal]
Effect:: Equivalent to `std::swap(this\->data, other.data)`
====
====
[source,cpp]
----
dynamic_charset to_dynamic() const noexcept;
----
[horizontal]
Return value:: `*this`
====
====
[source,cpp,subs=normal]
----
const char* name() const noexcept;
----
[horizontal]
Return value:: `this\->data\->name`
====
====
[source,cpp,subs=normal]
----
constexpr {charset_id} id() const noexcept;
----
[horizontal]
Return value:: `this\->data\->id`
====
====
[source,cpp,subs=normal]
----
constexpr char32_t replacement_char() const noexcept;
----
[horizontal]
Return value:: `this\->data\->replacement_char`
====
====
[source,cpp,subs=normal]
----
constexpr int replacement_char_size() const noexcept;
----
[horizontal]
Return value:: `this\->data\->replacement_char_size`
====
====
[source,cpp,subs=normal]
----
constexpr int validate(char32_t ch) const; // noexcept
----
[horizontal]
Effect:: Calls and returns `this\->data\->validate_func(ch)`.
====
====
[source,cpp,subs=normal]
----
constexpr int encoded_char_size(char32_t ch) const; // noexcept
----
[horizontal]
Effect:: Calls and returns `this\->data\->encoded_char_size_func(ch)`.
====
====
[source,cpp,subs=normal]
----
code_unit* encode_char(code_unit* dest, char32_t ch) const; // noexcept
----
[horizontal]
Effect:: Calls and returns `this\->data\->encoded_char_func(ch)`.
====
====
[source,cpp,subs=normal]
----
void encode_fill
    ( {transcode_dest}<CharT>& dest, std::ptrdiff_t count, char32_t ch ) const;
----
[horizontal]
Effect:: Calls and returns
       `this\->data\->encode_fill_func(dest, count, ch)`.
====
====
[source,cpp,subs=normal]
----
std::ptrdiff_t count_codepoints_fast
    ( const code_unit{asterisk} src, const code_unit{asterisk} src_end
    , std::ptrdiff_t max_count ) const;
----
[horizontal]
Effect:: Calls and returns `this\->data\->count_codepoints_fast_func(src, src_end, max_count)`.
====
====
[source,cpp,subs=normal]
----
std::ptrdiff_t count_codepoints
    ( const code_unit{asterisk} src, const code_unit{asterisk} src_end
    , std::ptrdiff_t max_count ) const;
----
[horizontal]
Effect:: Calls and returns
        `this\->data\->count_codepoints_func(src, src_end, max_count)`.
====
====
[source,cpp,subs=normal]
----
void write_replacement_char({transcode_dest}<CharT>& dest) const;
----
[horizontal]
Effect:: Calls `this\->data\->write_replacement_char_func(dest)`.
====
====
[source,cpp,subs=normal]
----
char32_t decode_unit(code_unit ch) const;
----
[horizontal]
Effect:: Calls and returns `this\->data\->decode_unit_func(ch)`.
====
====
[source,cpp,subs=normal]
----
{encode_char_f}<CharT> encode_char_func() const noexcept;
----
====
====
[source,cpp,subs=normal]
----
{encode_fill_f}<CharT> encode_fill_func() const noexcept;
----
[horizontal]
Return value:: `this\->data\->encode_fill_func`.
====
====
[source,cpp,subs=normal]
----
{write_replacement_char_f}<CharT> write_replacement_char_func() const noexcept;
----
[horizontal]
Return value:: `this\->data\->write_replacement_char_func`.
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<char32_t, CharT> from_u32() const;
----
[horizontal]
Return value:: `this\->data\->from_u32`.
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<CharT, char32_t> to_u32() const;
----
[horizontal]
Return value:: `this\->data\->to_u32`.
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<CharT, CharT> sanitizer() const;
----
[horizontal]
Return value:: `this\->data\->sanitizer`.
====

====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<CharT, char> find_transcoder_to
    ( {tag}<char>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_to_char(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<CharT, char>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<char, CharT> find_transcoder_from
    ( {tag}<char>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_from_char(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<char, CharT>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<CharT, char8_t> find_transcoder_to
    ( {tag}<char8_t>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_to_char8(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<CharT, char8_t>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<char8_t, CharT> find_transcoder_from
    ( {tag}<char8_t>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_from_char8(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<char8_t, CharT>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<CharT, char16_t> find_transcoder_to
    ( {tag}<char16_t>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_to_char16(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<CharT, char16_t>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<char16_t, CharT> find_transcoder_from
    ( {tag}<char16_t>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_from_char16(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<char16_t, CharT>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<CharT, wchar_t> find_transcoder_to
    ( {tag}<wchar_t>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_to_wchar(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<CharT, wchar_t>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<wchar_t, CharT> find_transcoder_from
    ( {tag}<wchar_t>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_from_wchar(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<wchar_t, CharT>{}`
====


=== Function template `find_transcoder` [[find_transcoder]]

[source,cpp,subs=normal]
----
template <class SrcCharset, class DstCharset>
auto find_transcoder(SrcCharset src, DstCharset dest);
----
Requirements:: `SrcCharset` and `DstCharset` are __{Charset}__ types.
Return type:: A type that is __{Transcoder}__
//-
Return value::
* Returns the default value of `{static_transcoder}<SrcID, DestID>`
  if such template instantiation is defined and
  `SrcCharset` is ( or derives from ) `{static_charset}<SrcID>` and
  `DstCharset` is ( or derives from ) `{static_charset}<DestID>`;
* otherwise, returns `src.<<Charset_sanitizer,sanitizer>>()` if
  `src.<<Charset_id,id>>()` is equal to `dest.<<Charset_id,id>>()`
  and `SrcCharset::{code_unit}` is the same type as `DstCharset::{code_unit}`;
* otherwise, returns `src.<<Charset_to_u32,to_u32>>()`
  if `DstCharset::{code_unit}` is `char32_t`;
* otherwise, returns `dest.<<Charset_from_u32,from_u32>>()`
  if `SrcCharset::{code_unit}` is `char32_t`;
* otherwise, returns
  `src.<<Charset_find_transcoder_to,find_transcoder_to>>(dest_ch, dest.id())`
  if such expression
  is well-formed and returns a <<Transcoder_null,non null transcoder>>
  , where `dest_ch` is `{tag}<DstCharset::{code_unit}>{}`
* otherwise, returns
  `dest.<<Charset_find_transcoder_from,find_transcoder_from>>(src_ch, src.id())`
   if such expression is well-formed, where `src_sh` is `{tag}<SrcCharset::{code_unit}>{}`
* otherwise returns `{dynamic_transcoder}<SrcCharset::{code_unit}, DstCharset::{code_unit}>{}`,
  __i.e.__ an <<Transcoder_null,null transcoder>>.

NOTE: When `find_transcoder` returns an <<Transcoder_null,null transcoder>>
, you still can use `{decode_encode}` and `decode_encode_size`.


=== Struct template `decode_encode_result` [[decode_encode_result]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT>
struct decode_encode_result {
    const CharT* stale_src_ptr;
    DstCharT* dst_ptr;
    std::int32_t u32dist;
    {transcode_stop_reason} stop_reason;
};

} // namespace strf
----

=== Struct template `decode_encode_size_result` [[decode_encode_size_result]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT>
struct decode_encode_size_result {
    std::ptrdiff_t ssize;
    const CharT* stale_src_ptr;
    std::int32_t u32dist;
    {transcode_stop_reason} stop_reason;
};

} // namespace strf
----

=== Function template `decode_encode`  [[decode_encode]]

The purpose of the following function templates
( `decode_encode`, `decode_encode_size`,
  `unsafe_decode_encode`, `unsafe_decode_encode_size` ) is to
  compensate the fact that the library does not provide a
  specialization of `static_transcoder`
  for every combination of two character encodings and that
  ( as a consequence ) `{find_transcoder}` may return a null transcoder.

`decode_encode` transcodes from one encoding to another using a pivot
buffer; __i.e.__ it transcodes the input string to UTF-32 and then
from UTF-32 to the destination encoding.
The performance is naturally worse than an specialized algorithm
that would transcode directly ( which is what an specialization of
`static_transcoder` is expected to do ).

// All the following overloads of `decode_encode` do the same thing:
// to transcode the input string ( the `src` parameter ) to UTF-32
// and then from UTF-32 to another enconding, writing into `dst`.
//
// They all guarantee to not call `dst.recycle()` if `dst.space()`
// is not less then the amount of character to be written.
//
// However, it better to use the functions of `static_transcoder`
// if this is possible, since they provide better performance.



====
[source,cpp,subs=normal]
----
namespace strf {

template <typename SrcCharT, typename DstCharT>
{decode_encode_result}<SrcCharT> decode_encode
    ( {transcode_f}<SrcCharT, char32_t> to_u32
    , {transcode_f}<char32_t, DstCharT> from_u32
    , const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Preconditions::
* `to_u32` is the value returned by
   `src_charset.<<Charset_to_u32,to_u32>>().{transcode_func}()`,
   where `src_charset` is a __{Charset}__ object that represents the
   source character encoding.
* `from_u32` is the value returned by
   `dst_charset.<<Charset_from_u32,from_u32>>().{transcode_func}()` or
   `dst_charset.<<Charset_from_u32,from_u32>>().{unsafe_transcode_func}()`,
   where `dst_charset` is a __{Charset}__ object that represents the
   destination character encoding.
* All the preconditions of
  `src_charset.<<Charset_to_u32,to_u32>>().{transcode_func}()`

Effect::
+
--
`decode_encode` has the same effects as calling
`__T__::<<Transcoder_transcode,transcode>>(src, src_end, dst, dst_end, notifier, flags)`,
if `__T__` were a __{Transcoder}__ class that transcodes from the source
character encoding to the destination character encoding.
--

Return value:: A `{decode_encode_result}` value `res`, such that
+
--
* `res.**stop_reason**` ( see `{transcode_stop_reason}`)
* `res.**stale_src_ptr**` is **not** the pointer past the last read element in the input range `[src, src_end)`. Instead, it points `res.**u32dist**` codepoints before that.
+
The pointer past the last read element would actually be:
+
[source,subs=normal]
----
 __src_charset__ .<<Charset_to_u32,to_u32>>() .{transcode_size}
     (res.**stale_ptr**, src_end, res.**u32dist**, flags)
     .<<transcode_size_result, src_ptr>>
----
+
, where:

** `__src_charset__` is a __{Charset}__ object that describes the source character encoding
--
====

====
[source,cpp,subs=normal]
----
namespace strf {

template <typename SrcCharT, typename DstCharT>
{decode_encode_result}<SrcCharT> decode_encode
    ( {transcode_f}<SrcCharT, char32_t> to_u32
    , {transcode_f}<char32_t, DstCharT> from_u32
    , std::basic_string_view<SrcCharT> src3
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Equivalent to:
----
decode_encode( to_u32, from_32, src.data(), src.data() + src.size()
             , dst, dst_end, notifier, flags)
----
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT >
{decode_encode_result}<SrcCharT> decode_encode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect::
Equivalent to
----
decode_encode
    ( src_charset.{to_u32}().{transcode_func}()
    , dst_charset.{from_u32}().{transcode_func}()
    , src, src_end, dst, dst_end, err_notifier, flags )
----
Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
- `DstCharset::code_unit` is the same type as `DstCharT`
====


====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT >
{decode_encode_result}<SrcCharT> decode_encode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , std::basic_string_view<SrcCharT> src
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect and postconditions::
Equivalent to
----
decode_encode
    ( src_charset, dst_charset, src.data(), src.data() + src.size()
    , dst, dst_end, err_notifier, flags )
----
Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
- `DstCharset::code_unit` is the same type as `DstCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , template <class> class DstCharsetTmpl
         , typename SrcCharT
         , typename DstCharT >
{decode_encode_result}<SrcCharT> decode_encode
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----

Effect and postconditions::
Equivalent to
----
decode_encode
    ( SrcCharsetTmpl<SrcCharT>(), DstCharsetTmpl<DstCharT>()
    , src, src_end, dst, dst_end, err_notifier, flags )
----
Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `DstCharsetTmpl<DstCharT>` is an instance of `{static_charset}`
- `SrcCharsetTmpl<SrcCharT>::code_unit` is `SrcCharT`
- `DstCharsetTmpl<DstCharT>::code_unit` is `DstCharT`
====


====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , template <class> class DstCharsetTmpl
         , typename SrcCharT
         , typename DstCharT >
{decode_encode_result}<SrcCharT> decode_encode
    ( std::basic_string_view<SrcCharT> src
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Equivalent to
----
decode_encode<SrcCharsetTmpl, DstCharsetTmpl>
    (src.data(), src.data() + src.size(), dst, dst_end, err_notifier, flags )
----
====


=== Function template `decode_encode_size` [[decode_encode_size]]

`decode_encode_size` is used to calculate the ammount of
characters that `decode_encode` writes.

====
[source,cpp,subs=normal]
----
namespace strf {

template <typename SrcCharT>
{decode_encode_size_result}<SrcCharT> decode_encode_size
    ( {transcode_f}<SrcCharT, char32_t> to_u32
    , {transcode_size_f}<char32_t> size_calc_func
    , const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Preconditions::
+
--
* `to_u32` is the value returned by
   `src_charset.<<Charset_to_u32,to_u32>>().{transcode_func}()`,
   where `src_charset` is a __{Charset}__ object that represents the
   source character encoding.
* `size_calc_func` is the value returned by
  `dst_charset.<<Charset_from_u32,from_u32>>().{transcode_size_func}()` or
  `dst_charset.<<Charset_from_u32,from_u32>>().{unsafe_transcode_size_func}()`
   where `dst_charset` is a __{Charset}__ object that represents the
   destination character encoding.
* All the preconditions of
  `src_charset.<<Charset_to_u32,to_u32>>().{transcode_func}()`
--
Return value:: A `{decode_encode_result}` value `res`, such that
+
--
* `res.**ssize**` is equal to `__res2__.ssize`
* `res.**stop_reason**` is equal to `__res2__.stop_reason`
* `res.**stale_src_ptr**` is **not** the pointer past the last read element in the input range `[src, src_end)`. Instead, it points `res.**u32dist**` codepoints before that.

, where `__res2__` is the value that would be returned by
`__T__::<<Transcoder_transcode_size,transcode_size>>(src, src_end, limit, flags)`,
it `__T__` were a __{Transcoder}__ class that transcodes from the
source character encoding to the destination character encoding.
--
====

====
[source,cpp,subs=normal]
----
namespace strf {

template <typename SrcCharT>
{decode_encode_size_result}<SrcCharT> decode_encode_size
    ( {transcode_f}<SrcCharT, char32_t> to_u32
    , {transcode_size_f}<char32_t> size_calc_func
    , std::basic_string_view<SrcCharT> src
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Return value::
Same as:
----
decode_encode_size
    ( to_32, size_calc_func, src.data(), src.data() + src.size(), limit, flags )
----
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset, typename SrcCharT >
{decode_encode_size_result}<SrcCharT> decode_encode_size
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Return value::
Same as:

[source,cpp,subs=normal]
----
decode_encode_size
    ( src_charset.{to_u32}().{transcode_func}()
    , dst_charset.{from_u32}().{transcode_size_func}()
    , src, src_end, limit, flags )
----
Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset, typename SrcCharT >
{decode_encode_size_result}<SrcCharT> decode_encode_size
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , std::basic_string_view<SrcCharT> src
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Return value::
Same as:
----
decode_encode_size
    ( src_charset, dst_charset, src.data(), src.data() + src.size(), limit, flags )
----
Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , typename DstCharset
         , typename SrcCharT >
{decode_encode_size_result}<SrcCharT> decode_encode_size
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----

Return value::
Same as:
----
decode_encode_size
    ( SrcCharsetTmpl<SrcCharT>(), DstCharset(), src, src_end, limit, flags )
----
Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `SrcCharset::code_unit` is the same type as `SrcCharT`
- `DstCharset` satisfy __{Charset}__
====

====

[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , typename DstCharset
         , typename SrcCharT >
{decode_encode_size_result}<SrcCharT> decode_encode_size
    ( std::basic_string_view<SrcCharT> src
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Return value::
Same as:
----
decode_encode_size<SrcCharsetTmpl, DstCharset>
    ( src.data(), src.data() + src.size(), limit, flags )
----
Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `SrcCharset::code_unit` is the same type as `SrcCharT`
- `DstCharset` satisfy __{Charset}__
====

=== Function template `unsafe_decode_encode`  [[unsafe_decode_encode]]

====
[source,cpp,subs=normal]
----
namespace strf {

1template <typename SrcCharT, typename DstCharT>
{decode_encode_result}<SrcCharT> unsafe_decode_encode
    ( {unsafe_transcode_f}<SrcCharT, char32_t> to_u32
    , {unsafe_transcode_f}<char32_t, DstCharT> from_u32
    , const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Preconditions::
--
* `to_u32` is the value returned by
   `src_charset.<<Charset_to_u32,to_u32>>().{unsafe_transcode_func}()`,
   where `src_charset` is a __{Charset}__ object that represents the
   sournce character encoding.
* `from_u32` is the value returned by
   `dst_charset.<<Charset_from_u32,from_u32>>().{unsafe_transcode_func}()`,
   where `dst_charset` is a __{Charset}__ object that represents the
   destination character encoding.
*  All the perconditions of
   `src_charset.<<Charset_to_u32,to_u32>>().{unsafe_transcode_func}()`.
--

Effect::
--
`unsafe_decode_encode` has the same effects as calling
`__T__::{unsafe_transcode}(src, src_end, dst, dst_end, notifier, flags)`,
if `__T__` were a __{Transcoder}__ class that transcodes from
the source character encoding to the destination character encoding.
--

Return value:: A `{decode_encode_result}` value `res`, such that
+
--
* `res.**stop_reason**` is equal to `__res2__.ssize`
* `res.**dst_ptr**` is equal to `__res2__.dst_ptr`
* `res.**stale_src_ptr**` is **not** the pointer past the last read element in the input range `[src, src_end)`. Instead, it points `res.**u32dist**` codepoints before that.

, where `__res2__` is the value that would be returned by
`__T__::{unsafe_transcode}(src, src_end, dst, dst_end, notifier, flags)`,
if `__T__` were a __{Transcoder}__ class that transcodes from
the source character encoding to the destination character encoding.
--
====

====
[source,cpp,subs=normal]
----
namespace strf {

template <typename SrcCharT, typename DstCharT>
{decode_encode_result}<SrcCharT> unsafe_decode_encode
    ( {unsafe_transcode_f}<SrcCharT, char32_t> to_u32
    , {unsafe_transcode_f}<char32_t, DstCharT> from_u32
    , std::basic_string_view<SrcCharT> src
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Equivalent to
----
unsafe_decode_encode(to_u32, from_32, src.data(), src.data() + src.size(), dst, dst_end, notifier, flags)
----
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT >
{decode_encode_result}<SrcCharT> unsafe_decode_encode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect::
Equivalent to
[source,cpp,subs=normal]
----
unsafe_decode_encode
    ( src_charset.{to_u32}().{unsafe_transcode_func}()
    , dst_charset.{from_u32}().{unsafe_transcode_func}()
    , src, src_end, dst, dst_end, err_notifier, flags )
----
Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
- `DstCharset::code_unit` is the same type as `DstCharT`
====


====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT >
{decode_encode_result}<SrcCharT> unsafe_decode_encode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , std::basic_string_view<SrcCharT> src
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect and postconditions::
Equivalent to
----
unsafe_decode_encode
    ( src_charset, dst_charset, src.data(), src.data() + src.size()
    , dst, dst_end, err_notifier, flags )
----
Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
- `DstCharset::code_unit` is the same type as `DstCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , template <class> class DstCharsetTmpl
         , typename SrcCharT
         , typename DstCharT >
{decode_encode_result}<SrcCharT> unsafe_decode_encode
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----

Effect and postconditions::
Equivalent to
----
unsafe_decode_encode
    ( SrcCharsetTmpl<SrcCharT>(), DstCharsetTmpl<DstCharT>()
    , src, src_end, dst, dst_end, err_notifier, flags )
----
Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `DstCharsetTmpl<DstCharT>` is an instance of `{static_charset}`
- `SrcCharsetTmpl<SrcCharT>::code_unit` is `SrcCharT`
- `DstCharsetTmpl<DstCharT>::code_unit` is `DstCharT`
====


====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , template <class> class DstCharsetTmpl
         , typename SrcCharT
         , typename DstCharT >
{decode_encode_result}<SrcCharT> unsafe_decode_encode
    ( std::basic_string_view<SrcCharT> src
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Equivalent to
----
unsafe_decode_encode<SrcCharsetTmpl, DstCharsetTmpl>
    (src.data(), src.data() + src.size(), dst, dst_end, err_notifier, flags )
----
====

=== Function template `unsafe_decode_encode_size` [[unsafe_decode_encode_size]]

`unsafe_decode_encode_size` is used to calculate the ammount of
characters that `unsafe_decode_encode` writes.

====
[source,cpp,subs=normal]
----

namespace strf {
template <typename SrcCharT>
{decode_encode_size_result}<SrcCharT> unsafe_decode_encode_size
    ( {unsafe_transcode_f}<SrcCharT, char32_t> to_u32
    , {unsafe_transcode_size_f}<char32_t> size_calc_func
    , const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Preconditions::
--
* `to_u32` is the value returned by
   `src_charset.<<Charset_to_u32,to_u32>>().{unsafe_transcode_func}()`,
   where `src_charset` is a __{Charset}__ object that represents the
   source character encoding.
* `size_calc_func` is the value returned by
  `dst_charset.<<Charset_from_u32,from_u32>>().{unsafe_transcode_size_func}()`
   where `dst_charset` is a __{Charset}__ object that represents the
   destination character encoding.
* All the preconditions of
  `src_charset.<<Charset_to_u32,to_u32>>().{unsafe_transcode_func}()`
--

Return value:: A `{decode_encode_result}` value `res`, such that
+
--
* `res.**ssize**` is equal to `__res2__.ssize`
* `res.**stop_reason**` is equal to `__res2__.stop_reason`
* `res.**stale_ptr**` is **not** the pointer past the last read element in the input range `[src, src_end)`. Instead, it points `res.**u32dist**` codepoints before that.

, where `__res2__` is the value that would be returned by
`__T__::<<Transcoder_transcode_size,unsafe_transcode_size>>(src, src_end, limit, flags)`,
if `__T__` were a __{Transcoder}__ class that transcodes from the source
character encoding to the destination character encoding.
--
====

====
[source,cpp,subs=normal]
----
namespace strf {

template <typename SrcCharT>
{decode_encode_size_result}<SrcCharT> unsafe_decode_encode_size
    ( {unsafe_transcode_f}<SrcCharT, char32_t> to_u32
    , {unsafe_transcode_size_f}<char32_t> size_calc_func
    , std::basic_string_view<SrcCharT> src
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Return value::
Same as:
----
unsafe_decode_encode_size
    ( to_32, size_calc_func, src.data(), src.data() + src.size(), flags )
----
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset, typename SrcCharT >
{decode_encode_size_result}<SrcCharT> unsafe_decode_encode_size
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Return value::
Same as:
[source,cpp,subs=normal]
----
unsafe_decode_encode_size
    ( src_charset.{to_u32}().{unsafe_transcode_func}()
    , dst_charset.{from_u32}().{unsafe_transcode_size_func}()
    , src, src_end, limit, flags )
----
Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset, typename SrcCharT >
{decode_encode_size_result}<SrcCharT> unsafe_decode_encode_size
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , std::basic_string_view<SrcCharT> src
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Return value::
Same as:
----
unsafe_decode_encode_size
    ( src_charset, dst_charset, src.data(), src.data() + src.size(), limit, flags )
----
Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , typename DstCharset
         , typename SrcCharT >
{decode_encode_size_result}<SrcCharT> unsafe_decode_encode_size
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----

Return value::
Same as:
----
unsafe_decode_encode_size
    ( SrcCharsetTmpl<SrcCharT>(), DstCharset(), src, src_end, limit, flags )
----
Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `SrcCharset::code_unit` is the same type as `SrcCharT`
- `DstCharset` satisfy __{Charset}__
====

====

[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , typename DstCharset
         , typename SrcCharT >
{decode_encode_size_result}<SrcCharT> unsafe_decode_encode_size
    ( std::basic_string_view<SrcCharT> src
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Return value::
Same as:
----
unsafe_decode_encode_size<SrcCharsetTmpl, DstCharset>
    ( src.data(), src.data() + src.size(), limit, flags )
----
Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `SrcCharset::code_unit` is the same type as `SrcCharT`
- `DstCharset` satisfy __{Charset}__
====


=== Function template `transcode` [[transcode]]

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT >
{decode_encode_result}<SrcCharT> transcode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* err_notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect::
[source,cpp,subs=normal]
----
auto func = {find_transcoder}(src_charset, dst_charset).{transcode_func}()
if (func != nullptr) {
    auto result = func(src, src_end, dst, dst_end, err_notifier, flags);
    return {result.ptr, result.dst_ptr, 0, result.stop_reason};
}
return {decode_encode} ( src_charset, dst_charset, src, src_end
                     , dst, dst_end, err_notifier, flags );

----

Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
- `DstCharset::code_unit` is the same type as `DstCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT >
{decode_encode_result}<SrcCharT> transcode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , std::basic_string_view<SrcCharT> src
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* err_notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect::
Same as:
----
transcode
    ( src_charset, dst_charset, src.data(), src.data() + src.size()
    , dst, dst_end, err_notifier, flags );
----

Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
- `DstCharset::code_unit` is the same type as `DstCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , template <class> class DstCharsetTmpl
         , typename SrcCharT, typename DstCharT >
{decode_encode_result}<SrcCharT> transcode
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* err_notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect::
Same as:
----
transcode
    ( SrcCharsetTmpl<SrcCharT>()
    , DstCharsetTmpl<DstCharT>()
    , src, src_end, dst, dst_end, err_notifier, flags );
----

Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `DstCharsetTmpl<DstCharT>` is an instance of `{static_charset}`
- `SrcCharsetTmpl<SrcCharT>::code_unit` is `SrcCharT`
- `DstCharsetTmpl<DstCharT>::code_unit` is `DstCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , template <class> class DstCharsetTmpl
         , typename SrcCharT, typename DstCharT >
{decode_encode_result}<SrcCharT> transcode
    ( std::basic_string_view<SrcCharT> src
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* err_notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Same as:
----
transcode <SrcCharsetTmpl, DstCharsetTmpl>
    ( src.data(), src.data() + src.size(), dst, dst_end, err_notifier, flags );
----
Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `DstCharsetTmpl<DstCharT>` is an instance of `{static_charset}`
- `SrcCharsetTmpl<SrcCharT>::code_unit` is `SrcCharT`
- `DstCharsetTmpl<DstCharT>::code_unit` is `DstCharT`
====

=== Function template `transcode_size` [[transcode_size]]

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset, typename SrcCharT >
{decode_encode_size_result}<SrcCharT> transcode_size
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , std::ptrdiff_t limit
    , strf::transcode_flags flags = transcode_flags::none );

}
----
Effect and Return value::
[source,cpp,subs=normal]
----
auto func = {find_transcoder}(src_charset, dst_charset).{transcode_size_func}()
if (func != nullptr) {
    auto result = func(src, src_end, limit, flags);
    return {result.ssize, result.src_ptr, 0, result.stop_reason};
}
return {decode_encode_size} (src_charset, dst_charset, src, src_end, limit, flags);
----

Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset, typename SrcCharT >
{decode_encode_size_result}<SrcCharT> transcode_size
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , std::basic_string_view<SrcCharT> src
    , std::ptrdiff_t limit
    , strf::transcode_flags flags = transcode_flags::none );

}
----
Effect and Return value::
Same as
----
transcode_size
    ( src_charset, dst_charset
    , src.data(), src.data() + src.size(), limit, flags)
----

Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , typename DstCharset
         , typename SrcCharT >
{decode_encode_size_result}<SrcCharT> transcode_size
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , std::ptrdiff_t limit
    , strf::transcode_flags flags = transcode_flags::none );

}
----
Effect and Return value::
Same as
----
transcode_size
    ( SrcCharsetTmpl<SrcCharT>(), DstCharset(), src, src_end, limit, flags )
----

Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `DstCharset` is an instance of `{static_charset}`
- `SrcCharsetTmpl<SrcCharT>::code_unit` is `SrcCharT`
====



====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , typename DstCharset
         , typename SrcCharT >
{decode_encode_size_result}<SrcCharT> transcode_size
    ( std::basic_string_view<SrcCharT> src
    , std::ptrdiff_t limit
    , strf::transcode_flags flags = transcode_flags::none );

}
----
Effect and Return value::
Same as
----
transcode_size <SrcCharsetTmpl, DstCharset>
    ( src.data(), src.data() + src.size(), limit, flags )
----

Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `DstCharset` is an instance of `{static_charset}`
- `SrcCharsetTmpl<SrcCharT>::code_unit` is `SrcCharT`
====

=== Function template `unsafe_transcode` [[unsafe_transcode]]

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT >
void unsafe_transcode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* err_notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect::
[source,cpp,subs=normal]
----
auto func = {find_transcoder}(src_charset, dst_charset).{unsafe_transcode_func}()
if (func != nullptr) {
    auto res = func(src, src_end, dst, dst_end, err_notifier);
    return {res.src_ptr, res.dst_ptr, 0, res.stop_reason};
}
return {unsafe_decode_encode}
        ( src_charset, dst_charset, src, src_end, dst, dst_end, err_notifier, flags );
----

Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
- `DstCharset::code_unit` is the same type as `DstCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT >
void unsafe_transcode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , std::basic_string_view<SrcCharT> src
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* err_notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect::
Same as:
----
unsafe_transcode
    ( src_charset, dst_charset, src.data(), src.data() + src.size()
    , dst, dst_end, err_notifier, flags );
----

Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
- `DstCharset::code_unit` is the same type as `DstCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , template <class> class DstCharsetTmpl
         , typename SrcCharT, typename DstCharT >
void unsafe_transcode
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* err_notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect::
Same as:
----
unsafe_transcode
    ( SrcCharsetTmpl<SrcCharT>()
    , DstCharsetTmpl<DstCharT>()
    , src, src_end, dst, dst_end, err_notifier, flags );
----

Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `DstCharsetTmpl<DstCharT>` is an instance of `{static_charset}`
- `SrcCharsetTmpl<SrcCharT>::code_unit` is `SrcCharT`
- `DstCharsetTmpl<DstCharT>::code_unit` is `DstCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , template <class> class DstCharsetTmpl
         , typename SrcCharT, typename DstCharT >
void unsafe_transcode
    ( std::basic_string_view<SrcCharT> src
    , DstCharT* dst
    , DstCharT* dst_end
    , {transcoding_error_notifier}* err_notifier = nullptr
    , {transcode_flags} flags = transcode_flags::none );

}
----
Same as:
----
unsafe_transcode <SrcCharsetTmpl, DstCharsetTmpl>
    ( src.data(), src.data() + src.size(), dst, dst_end, err_notifier, flags );
----
Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `DstCharsetTmpl<DstCharT>` is an instance of `{static_charset}`
- `SrcCharsetTmpl<SrcCharT>::code_unit` is `SrcCharT`
- `DstCharsetTmpl<DstCharT>::code_unit` is `DstCharT`
====

=== Function template `unsafe_transcode_size` [[unsafe_transcode_size]]

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset, typename SrcCharT >
std::ptrdiff_t unsafe_transcode_size
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect and Return value::
[source,cpp,subs=normal]
----
auto func = {find_transcoder}(src_charset, dst_charset).{unsafe_transcode_size_func}()
if (func != nullptr) {
    auto res = func(src, src_end, limit, flags);
    return {res.ssize, res.src_ptr, 0, res.stop_reason}
}
return {unsafe_decode_encode_size} (src_charset, dst_charset, src, src_end, limit, flags);
----

Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < typename SrcCharset, typename DstCharset, typename SrcCharT >
std::ptrdiff_t unsafe_transcode_size
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , std::basic_string_view<SrcCharT> src
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect and Return value::
Same as
----
unsafe_transcode_size
    ( src_charset, dst_charset
    , src.data(), src.data() + src.size(), limit, flags )
----

Compile-time requirements::
- `SrcCharset` and `DstCharset` satisfy __{Charset}__
- `SrcCharset::code_unit` is the same type as `SrcCharT`
====

====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , typename DstCharset
         , typename SrcCharT >
std::ptrdiff_t unsafe_transcode_size
    ( const SrcCharT{asterisk} src
    , const SrcCharT{asterisk} src_end
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect and Return value::
Same as
----
unsafe_transcode_size
    ( SrcCharsetTmpl<SrcCharT>(), DstCharset(), src, src_end, limit, flags )
----

Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `DstCharset` is an instance of `{static_charset}`
- `SrcCharsetTmpl<SrcCharT>::code_unit` is `SrcCharT`
====



====
[source,cpp,subs=normal]
----
namespace strf {

template < template <class> class SrcCharsetTmpl
         , typename DstCharset
         , typename SrcCharT >
std::ptrdiff_t unsafe_transcode_size
    ( std::basic_string_view<SrcCharT> src
    , std::ptrdiff_t limit
    , {transcode_flags} flags = transcode_flags::none );

}
----
Effect and Return value::
Same as
----
unsafe_transcode_size <SrcCharsetTmpl, DstCharset>
    ( src.data(), src.data() + src.size(), limit, flags )
----

Compile-time requirements::
- `SrcCharsetTmpl<SrcCharT>` is an instance of `{static_charset}`
- `DstCharset` is an instance of `{static_charset}`
- `SrcCharsetTmpl<SrcCharT>::code_unit` is `SrcCharT`
====


=== Type aliases for charsets [[static_charset_aliases]]

[source,cpp,subs=normal]
----
namespace strf {

template <class CharT>
using ascii_t = static_charset<CharT, scid_ascii>;

template <class CharT>
using iso_8859_1_t = static_charset<CharT, scid_iso_8859_1>;

template <class CharT>
using iso_8859_2_t = static_charset<CharT, scid_iso_8859_2>;

template <class CharT>
using iso_8859_3_t = static_charset<CharT, scid_iso_8859_3>;

template <class CharT>
using iso_8859_4_t = static_charset<CharT, scid_iso_8859_4>;

template <class CharT>
using iso_8859_5_t = static_charset<CharT, scid_iso_8859_5>;

template <class CharT>
using iso_8859_6_t = static_charset<CharT, scid_iso_8859_6>;

template <class CharT>
using iso_8859_7_t = static_charset<CharT, scid_iso_8859_7>;

template <class CharT>
using iso_8859_8_t = static_charset<CharT, scid_iso_8859_8>;

template <class CharT>
using iso_8859_9_t = static_charset<CharT, scid_iso_8859_9>;

template <class CharT>
using iso_8859_10_t = static_charset<CharT, scid_iso_8859_10>;

template <class CharT>
using iso_8859_11_t = static_charset<CharT, scid_iso_8859_11>;

template <class CharT>
using iso_8859_13_t = static_charset<CharT, scid_iso_8859_13>;

template <class CharT>
using iso_8859_14_t = static_charset<CharT, scid_iso_8859_14>;

template <class CharT>
using iso_8859_15_t = static_charset<CharT, scid_iso_8859_15>;

template <class CharT>
using iso_8859_16_t = static_charset<CharT, scid_iso_8859_16>;

template <class CharT>
using windows_1250_t = static_charset<CharT, scid_windows_1250>;

template <class CharT>
using windows_1251_t = static_charset<CharT, scid_windows_1251>;

template <class CharT>
using windows_1252_t = static_charset<CharT, scid_windows_1252>;

template <class CharT>
using windows_1253_t = static_charset<CharT, scid_windows_1253>;

template <class CharT>
using windows_1254_t = static_charset<CharT, scid_windows_1254>;

template <class CharT>
using windows_1255_t = static_charset<CharT, scid_windows_1255>;

template <class CharT>
using windows_1256_t = static_charset<CharT, scid_windows_1256>;

template <class CharT>
using windows_1257_t = static_charset<CharT, scid_windows_1257>;

template <class CharT>
using windows_1258_t = static_charset<CharT, scid_windows_1258>;

template <class CharT>
using utf8_t = static_charset<CharT, scid_utf8>;

template <class CharT>
using utf16_t = static_charset<CharT, scid_utf16>;

template <class CharT>
using utf32_t = static_charset<CharT, scid_utf32>;

template <class CharT>
using utf_t = /* see below */;

} // namespace strf
----

[[utf_t]]
====
[source,cpp]
----
template <class CharT>
using utf_t = /* ... */;
----
`utf_t<CharT>` is an alias to `utf8_t<CharT>`, `utf16_t<CharT>` or `utf32_t<CharT>`,
depending on the value of `sizeof(CharT)`.
====

=== Template variable for charsets [[static_charset_constexpr]]

[source,cpp,subs=normal]
----
namespace strf {

template <class CharT> constexpr ascii_t<CharT>         ascii = {};

template <class CharT> constexpr iso_8859_1_t<CharT>    iso_8859_1 = {};
template <class CharT> constexpr iso_8859_2_t<CharT>    iso_8859_2 = {};
template <class CharT> constexpr iso_8859_3_t<CharT>    iso_8859_3 = {};
template <class CharT> constexpr iso_8859_4_t<CharT>    iso_8859_4 = {};
template <class CharT> constexpr iso_8859_5_t<CharT>    iso_8859_5 = {};
template <class CharT> constexpr iso_8859_6_t<CharT>    iso_8859_6 = {};
template <class CharT> constexpr iso_8859_7_t<CharT>    iso_8859_7 = {};
template <class CharT> constexpr iso_8859_8_t<CharT>    iso_8859_8 = {};
template <class CharT> constexpr iso_8859_9_t<CharT>    iso_8859_9 = {};
template <class CharT> constexpr iso_8859_10_t<CharT>   iso_8859_10 = {};
template <class CharT> constexpr iso_8859_11_t<CharT>   iso_8859_11 = {};
template <class CharT> constexpr iso_8859_13_t<CharT>   iso_8859_13 = {};
template <class CharT> constexpr iso_8859_14_t<CharT>   iso_8859_14 = {};
template <class CharT> constexpr iso_8859_15_t<CharT>   iso_8859_15 = {};
template <class CharT> constexpr iso_8859_16_t<CharT>   iso_8859_16 = {};

template <class CharT> constexpr windows_1250_t<CharT>  windows_1250 = {};
template <class CharT> constexpr windows_1251_t<CharT>  windows_1251 = {};
template <class CharT> constexpr windows_1252_t<CharT>  windows_1252 = {};
template <class CharT> constexpr windows_1253_t<CharT>  windows_1253 = {};
template <class CharT> constexpr windows_1254_t<CharT>  windows_1254 = {};
template <class CharT> constexpr windows_1255_t<CharT>  windows_1255 = {};
template <class CharT> constexpr windows_1256_t<CharT>  windows_1256 = {};
template <class CharT> constexpr windows_1257_t<CharT>  windows_1257 = {};
template <class CharT> constexpr windows_1258_t<CharT>  windows_1258 = {};

template <class CharT> constexpr utf8_t<CharT>          utf8 = {};
template <class CharT> constexpr utf16_t<CharT>         utf16 = {};
template <class CharT> constexpr utf32_t<CharT>         utf32 = {};
template <class CharT> constexpr {utf_t}<CharT>           utf = {};

} // namespace strf
----
