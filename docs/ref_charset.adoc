////
Copyright (C) (See commit logs on github.com/robhz786/strf)
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
////

== Character encodings

:transcoding_error_notifier: <<transcoding_error_notifier,transcoding_error_notifier>>
:transcoding_error_notifier_c: <<transcoding_error_notifier_c,transcoding_error_notifier_c>>
:transcoding_error_notifier_nullptr: <<transcoding_error_notifier_nullptr,transcoding_error_notifier_nullptr>>
:TranscodingErrorNotifierPtr: <<TranscodingErrorNotifierPtr,TranscodingErrorNotifierPtr>>

:surrogate_policy: <<surrogate_policy,surrogate_policy>>
:surrogate_policy_c: <<surrogate_policy,surrogate_policy_c>>

:charset_id: <<charset_id,charset_id>>
:scid_utf8:         <<charset_id,scid_utf8>>
:scid_utf16:        <<charset_id,scid_utf16>>
:scid_utf32:        <<charset_id,scid_utf32>>
:scid_ascii:        <<charset_id,scid_ascii>>
:scid_iso_8859_1:   <<charset_id,scid_iso_8859_1>>
:scid_iso_8859_3:   <<charset_id,scid_iso_8859_3>>
:scid_iso_8859_15:  <<charset_id,scid_iso_8859_15>>
:scid_windows_1252: <<charset_id,scid_windows_1252>>

:transcode_dest: <<transcode_dest,transcode_dest>>
:invalid_char_len: <<charset_function_pointers,invalid_char_len>>
:transcode_f: <<charset_function_pointers,transcode_f>>
:transcode_size_f: <<charset_function_pointers,transcode_size_f>>
:write_replacement_char_f: <<charset_function_pointers,write_replacement_char_f>>
:validate_f: <<charset_function_pointers,validate_f>>
:encoded_char_size_f: <<charset_function_pointers,encoded_char_size_f>>
:encode_fill_f: <<charset_function_pointers,encode_fill_f>>
:decode_unit_f: <<charset_function_pointers,decode_unit_f>>
:encode_char_f: <<charset_function_pointers,encode_char_f>>
:encode_fill_f: <<charset_function_pointers,encode_fill_f>>
:codepoints_count_result: <<charset_function_pointers,codepoints_count_result>>
:count_codepoints_fast_f: <<charset_function_pointers,count_codepoints_fast_f>>
:count_codepoints_f: <<charset_function_pointers,count_codepoints_f>>
:decode_unit_f: <<charset_function_pointers,decode_unit_f>>
:find_transcoder_f: <<charset_function_pointers,find_transcoder_f>>
:facet_traits: <<facet_traits,facet_tratis>>
:facet_category: <<facet_category,facet_category>>


:static_transcoder: <<static_transcoder,static_transcoder>>
:static_charset: <<static_charset,static_charset>>
:static_charset: <<static_charset,static_charset>>

:dynamic_transcoder: <<dynamic_transcoder,dynamic_transcoder>>
:dynamic_charset_data: <<dynamic_charset_data,dynamic_charset_data>>
:dynamic_charset: <<dynamic_charset,dynamic_charset>>
:dynamic_charset: <<dynamic_charset,dynamic_charset>>

:find_transcoder: <<find_transcoder,find_transcoder>>
:decode_encode: <<decode_encode,decode_encode>>
:decode_encode_size: <<decode_encode_size,decode_encode_size>>

:Transcoder: <<Transcoder,Transcoder>>
:Charset: <<Charset,Charset>>
:code_unit: <<Charset_code_unit,code_unit>>
:charset_c: <<charset_c,charset_c>>

:utf_t: <<utf_t,utf_t>>
:utf: <<static_charset_constexpr,utf>>

=== Enumeration `charset_id` [[charset_id]]

[source,cpp]
----
namespace strf {
enum class charset_id : unsigned { };

constexpr charset_id  scid_ascii        = /* ... */;
constexpr charset_id  scid_utf8         = /* ... */;
constexpr charset_id  scid_utf16        = /* ... */;
constexpr charset_id  scid_utf32        = /* ... */;
constexpr charset_id  scid_iso_8859_1   = /* ... */;
constexpr charset_id  scid_iso_8859_2   = /* ... */;
constexpr charset_id  scid_iso_8859_3   = /* ... */;
constexpr charset_id  scid_iso_8859_4   = /* ... */;
constexpr charset_id  scid_iso_8859_5   = /* ... */;
constexpr charset_id  scid_iso_8859_6   = /* ... */;
constexpr charset_id  scid_iso_8859_7   = /* ... */;
constexpr charset_id  scid_iso_8859_8   = /* ... */;
constexpr charset_id  scid_iso_8859_9   = /* ... */;
constexpr charset_id  scid_iso_8859_10  = /* ... */;
constexpr charset_id  scid_iso_8859_11  = /* ... */;
constexpr charset_id  scid_iso_8859_13  = /* ... */;
constexpr charset_id  scid_iso_8859_14  = /* ... */;
constexpr charset_id  scid_iso_8859_15  = /* ... */;
constexpr charset_id  scid_iso_8859_16  = /* ... */;

constexpr charset_id  scid_windows_1250 = /* ... */;
constexpr charset_id  scid_windows_1251 = /* ... */;
constexpr charset_id  scid_windows_1252 = /* ... */;
constexpr charset_id  scid_windows_1253 = /* ... */;
constexpr charset_id  scid_windows_1254 = /* ... */;
constexpr charset_id  scid_windows_1255 = /* ... */;
constexpr charset_id  scid_windows_1256 = /* ... */;
constexpr charset_id  scid_windows_1257 = /* ... */;
constexpr charset_id  scid_windows_1258 = /* ... */;

} // namespace strf
----

=== Facet category `transcoding_error_notifier_c` [[transcoding_error_notifier_c]]

A facet of the `transcoding_error_notifier_c` category must satisfy the
__{TranscodingErrorNotifierPtr}__ type requirements.

[source,cpp,subs=normal]
----
namespace strf {
struct transcoding_error_notifier_c {
    static constexpr bool constrainable = false;
    static constexpr {transcoding_error_notifier_nullptr} get_default() noexcept {
        return {};
    }
};
} // namespace strf
----


==== Type requirement __TranscodingErrorNotifierPtr__ [[TranscodingErrorNotifierPtr]]

Given

* `X`, a __TranscodingErrorNotifierPtr__ type
* `x`, a const value of type `X`

The following must hold:

* `{facet_category}<X>` is a type alias to `transcoding_error_notifier_c`
* `X` is __MoveConstructible__

====
[source,cpp]
----
x.get()
----
[horizontal]
Return type:: `{transcoding_error_notifier}{asterisk}`
====

==== Struct `transcoding_error_notifier_nullptr` [[transcoding_error_notifier_nullptr]]

[source,cpp]
----
namespace strf {

struct transcoding_error_notifier_nullptr {
    using category = transcoding_error_notifier_c;

    constexpr transcoding_error_notifier* get() const { return nullptr; }
};

} // namespace strf
----

==== Struct `transcoding_error_notifier_ptr` [[transcoding_error_notifier_ptr]]

[source,cpp]
----
namespace strf {

struct transcoding_error_notifier_ptr {
    using category = transcoding_error_notifier_c;

    constexpr transcoding_error_notifier* get() const { return ptr; }

    transcoding_error_notifier* ptr = nullptr;
};

} // namespace strf
----

==== Class transcoding_error_notifier [[transcoding_error_notifier]]
[source,cpp,subs=normal]
----
namespace strf {

class transcoding_error_notifier {
public:
    virtual ~transcoding_error_notifier() {}

    virtual void invalid_sequence
        ( std::size_t code_unit_size
        , const char* source_charset_name
        , const void* sequence_ptr
        , std::size_t code_units_count )
    {
    }

    virtual void unsupported_codepoint
        ( const char* destination_charset_name
        , unsigned codepoint )
    {
    }
};

} // namespace strf

----

=== Facet category `surrogate_policy_c` [[surrogate_policy]]

[source,cpp,subs=normal]
----
enum class surrogate_policy : bool { strict = false, lax = true };

struct surrogate_policy_c {
    static constexpr bool constrainable = false;
    static constexpr surrogate_policy get_default() noexcept {
        return surrogate_policy::strict;
    }
};

template <>
class facet_traits<surrogate_policy> {
public:
    using category = surrogate_policy_c;
    static constexpr bool store_by_value = true;
};
----
==== Semantics

This facet enables you to choose whether a nonconformant presence of a
surrogate character shall be treated as invalid.


=== Facet category template `charset_c` [[charset_c]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT>
struct charset_c {
    static constexpr bool constrainable = false;
    static constexpr {utf}<CharT> get_default() noexcept;
};

template <typename CharT, {charset_id} CSId>
struct {facet_traits}<{static_charset}<CharT, CSId>>
{
    using category = charset_c<CharT>;
};

template <typename CharT>
struct {facet_traits}<{dynamic_charset}<CharT>>
{
    using category = charset_c<CharT>;
};
} // namespace strf
----

For a type to be a facet of `charset_c<CharT>` it has
to be a _{Charset}_ type for `CharT`. The library provides
two class templates that satisfy that: `{static_charset}`
and `{dynamic_charset}`

=== Type alias template `transcode_dest` [[transcode_dest]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT>
using transcode_dest = {output_buffer}<CharT, 3>;

} // namespace strf
----

=== Aliases for pointers to functions [[charset_function_pointers]]

[source,cpp,subs=normal]
----
namespace strf {

constexpr std::size_t invalid_char_len = (std::size_t)-1;

template <typename SrcCharT, typename DestCharT>
using transcode_f = void ({asterisk})
    ( {transcode_dest}<DestCharT>& dest
    , const SrcCharT{asterisk} src
    , std::size_t src_size
    , {transcoding_error_notifier}{asterisk} err_notifier
    , {surrogate_policy} surr_poli );

template <typename SrcCharT>
using transcode_size_f = std::size_t ({asterisk})
    ( const SrcCharT{asterisk} src
    , std::size_t src_size
    , {surrogate_policy} surr_poli );

template <typename CharT>
using write_replacement_char_f = void({asterisk})( {transcode_dest}<CharT>& );

using validate_f = std::size_t ({asterisk})(char32_t ch);

using encoded_char_size_f = std::size_t ({asterisk}) (char32_t ch);

template <typename CharT>
using encode_char_f = CharT{asterisk}({asterisk}) (CharT{asterisk} dest, char32_t ch);

template <typename CharT>
using encode_fill_f = void ({asterisk})
    ( {transcode_dest}<CharT>&
    , std::size_t count
    , char32_t ch );

struct count_codepoints_result {
    std::size_t count;
    std::size_t pos;
};

template <typename CharT>
using count_codepoints_fast_f = count_codepoints_result ({asterisk})
    ( const CharT{asterisk} src
    , std::size_t src_size
    , std::size_t max_count );

template <typename CharT>
using count_codepoints_f = count_codepoints_result ({asterisk})
    ( const CharT{asterisk} src
    , std::size_t src_size
    , std::size_t max_count
    , {surrogate_policy} surr_poli );

template <typename CharT>
using decode_unit_f = char32_t ({asterisk}) ( CharT );

template <typename SrcCharT, typename DestCharT>
using find_transcoder_f = {dynamic_transcoder}<SrcCharT, DestCharT> ({asterisk})
    ( {charset_id} );

} // namespace strf
----

=== Type requirement _Transcoder_ [[Transcoder]]

Given

* `SrcCharT`, one of the types: `char`, `char8_t`, `char16_t`, `char32_t` or `wchar_t`
* `DestCharT`, one of the types: `char`, `char8_t`, `char16_t`, `char32_t` or `wchar_t`
* `X`, a _Transcoder_ type from `SrcCharT` to `DestCharT`
* `x`, an expression of type `X` or `const X`
* `dest`, an lvalue reference of type `{transcode_dest}<DestCharT>`
* `src`, a value of type `const SrcCharT*`
* `src_size`, a value of type `std::size_t` equal to the size of
              the array pointed by `src`
* `err_notifier`, is a pointer of type `{transcoding_error_notifier}`
* `surr_poli`, a value of type `{surrogate_policy}`

The following must hold:

* `X` is https://en.cppreference.com/w/cpp/named_req/CopyConstructible[CopyConstructible].
* `X` supports the following syntax and semantics:

====
[source,cpp]
----
x.transcode_size(src, src_size, surr_poli)
----
[horizontal]
Return type:: `std::size_t`
Return value:: The number of character that
  `x.transcode(dest, src, src_size, nullptr, surr_poli)`
  would write into `dest`, or a value a greater than that if such exact calculation is
  difficult ( but ideally not much greater ).
Precondition:: `x.transcode_func() != nullptr` is `true`
====
[[Transcoder_transcode]]
====
[source,cpp]
----
x.transcode(dest, src, src_size, err_notifier, surr_poli)
----
[horizontal]
Effect:: Converts the content of `src` from one encoding to another writing
the result to `dest`.
+
--
Each sequence in `src` that is invalid ( non-conformant to the
source character encoding ) shall be
translated to the replacement character ( that is returned by
`dest_sc.<<Charset_replacement_char, replacement_char()>>`,
where `dest_sc` represents the destination encoding ).
Each time that happens,
`err_notifier\-><<transcoding_error_notifier,invalid_sequence>>(ch_size, name, seq, count)`
shall be called if `err_notifer` is not null, where:

* `name` is the return of `src_sc.name()`, `src_sc` represents the source character encoding.
* `seq` points to the first character of the invalid sequence
* `count` is number of characters in the invalid sequence
* `ch_size` is `sizeof(SrcCharT)`
--
+
Note that a surrogate codepoint shall not be considered invalid
if `surr_poli` is equall to `surrogate_policy::lax`.
+
Each codepoint in `src` that is not supported by the destintation
character encoding shall be translated to the replacement character ( that is returned by
`dest_sc.<<Charset_replacement_char, replacement_char()>>`,
where `dest_sc` represents the destination encoding ).
Each time that happens,
`err_notifier\-><<transcoding_error_notifier,unsupported_codepoint>>(dest_sc.<<Charset_name,name()>>, code)`
shall be called if `err_notifier` is not null and `code` ( which is the
unsupported codepoint ) is not `0xFFFD`.


Precondition:: `x.transcode_func() != nullptr` is `true`
Postconditions:: `dest.recycle()` is not called() if
        `dest.buffer_space() >= x.transcode_size(src, src_size, surr_poli)` is `true`.
====
[[Transcoder_transcode_size_func]]
====
[source,cpp]
----
x.transcode_size_func()
----
[horizontal]
Return type:: `{transcode_size_f}<SrcCharT>`
Return value:: A function pointer such that
               `x.transcode_size_func() (src, src_size, surr_poli)` has the same
               effect as `x.transcode_size(src, src_size, surr_poli)`.
====
[[Transcoder_transcode_func]]
====
[source,cpp]
----
x.transcode_func()
----
[horizontal]
Return type:: `{transcode_f}<SrcCharT, DestCharT>`
Return value:: A function pointer such that
   `x.transcode_func() (dest, src, src_size, err_notifier, surr_poli)`
   has the same effect as
   `x.transcode(dest, src, src_size, err_notifier, surr_poli)`.
====
'''
[[Transcoder_null]]
====
.Definition
A *null transcoder* is an object of an __Transcoder__
type where the `transcode_func` function returns `nullptr`.
====

NOTE: There are two class templates that satisfy _Transcoder_:
      `{static_transcoder}` and `{dynamic_transcoder}`.

=== Type requirement _Charset_ [[Charset]]

An object whose type is a _Charset_ represents a character encoding.
In this documentation the term _charset_ is used interchangeably with
_encoding_ and _character encoding_.

Given

* `CharT`, one of the follwoing types: `char`, `char8_t`, `char16_t`, `char32_t` or `wchar_t`
* `X`, a _Charset_ type for type `CharT`
* `x`, an expression of type `X` or `const X`
* `OtherCharT`, one of the folowing types : `char`, `char8_t`, `char16_t` or `wchar_t`
* `ptr`, a value of type `CharT{asterisk}`
* `src`, a value of type `const CharT{asterisk}`
* `src_size`, a value of type `std::size_t` equal to the size of
              the array pointed by `src`
* `count`, a value of type `std::size_t`
* `max_count`, a value of type `std::size_t`
* `ch32`, a value of type `char32_t`
* `ch`, a value of type `CharT`
* `dest`, an lvalue reference of type `{transcode_dest}<CharT>`
* `cs_id`, value of type `{charset_id}`

The following must hold:

* `X` is either an instance of the `{static_transcoder}` or `{dynamic_charset}` class template
* `X` is https://en.cppreference.com/w/cpp/named_req/CopyConstructible[CopyConstructible]
* `{facet_category}<X>` must be `{charset_c}<CharT>`
* `X` satisfies the following syntax and semantics:

[[Charset_code_unit]]
====
[source,cpp]
----
X::code_unit
----
Type alias to `CharT`
====
[[Charset_id]]
====
[source,cpp]
----
x.id()
----
[horizontal]
Return type:: `{charset_id}`
Return value:: The `{charset_id}` that corresponds to this encoding.
====

[[Charset_name]]
====
[source,cpp]
----
x.name()
----
[horizontal]
Return type:: `const char*`
Return value:: The name of this encoding. Examples: `"UTF-8"`, `"ASCII"`, `"ISO-8859-1"`, `"windows-1252"`.
====

[[Charset_replacement_char]]
====
[source,cpp]
----
x.replacement_char()
----
[horizontal]
Return type:: `char32_t`
Return value:: The character used to signalize an error. Usually it is the https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character[replacement character &#xFFFD;] if it is supported by this encoding, or the question mark `'?'` otherwise.
====
====
[source,cpp]
----
x.write_replacement_char(dest)
----
[horizontal]
Return type:: Writes into `dest` the codepoint returned by `x.replacement_char()` encoded in this charset.
====
====
[source,cpp]
----
x.replacement_char_size()
----
[horizontal]
Return type:: `std::size_t`
Return value:: The number of characters that `x.write_replacement_char(dest)` writes into `dest`.
====
====
[source,cpp]
----
x.encoded_char_size(ch32)
----
[horizontal]
Return type:: `std::size_t`
Return value:: The size of the string containing the UTF-32 character `ch32`,
               if `ch32` is supported in this encoding. Otherwise,
               `x.replacement_char_size()`.
Postcondition:: The return value must be greater than zero.
Note:: This function does not check whether `ch32` is a legal code point, only if
       it is possible to write it in this encoding. For example, if this is encoding
       is UTF-32, this function considers as valid any value for `ch32` ( even if
       is is greater than `0x10FFFF` ). Surrogates characters are also not sanitized.
====
====
[source,cpp]
----
x.validate(ch32)
----
[horizontal]
Return type:: `std::size_t`
Return value:: The size of the string containing the UTF-32 character `ch32`,
               if `ch32` is supported in this encoding. Otherwise, `(std::size_t)-1`.
Postcondition:: The return value must be greater than zero.
====
====
[source,cpp]
----
x.encode_char(ptr, ch32)
----
[horizontal]
Effect:: Writes into `ptr` the UTF-32 character `ch32` encoded into this encoding,
         adopting the policy of `{surrogate_policy}::lax`,
         __i.e.__ if `ch32` is a surrogate, treat it as if it were a valid codepoint.
         If this encoding is not able to encode `ch32`,
         then encode instead the return of `x.replacement_char()`.
Return type:: `CharT*`
Postcondition:: `x.encode_char(ptr, ch32) - ptr == x.encoded_char_size(ch32)` is `true`.
Return value:: The position just after the last writen character.
Note:: This function does not check whether `ch32` is a legal code point, only if
       it is possible to write it in this encoding. For example, if this is encoding
       is UTF-32, this function considers as valid any value for `ch32` ( even if
       is is greater than `0x10FFFF` ). Surrogates characters are also not sanitized.
====
====
[source,cpp]
----
x.encode_fill(dest, count, ch32)
----
[horizontal]
Effect:: Writes `count` times into `dest` the UTF-32 character `ch32` encoded into
         this encoding, if it is supported. Otherwise writes `x.replacement_char()`
         instead.
Return type:: `void`
Note:: `encode_fill` does not check whether `ch32` is a legal code point, only if
       it is possible to write it in this encoding. For example, if this is encoding
       is UTF-32, `encode_fill` considers as valid any value for `ch32` ( even if
       is is greater than `0x10FFFF` ). Surrogates characters are also not sanitized.
====
[[Charset_count_codepoints_fast]]
====
[source,cpp]
----
x.count_codepoints_fast(src, src_size, max_count)
----
[horizontal]
Return type:: `{count_codepoints_result}`
Return value:: `{c, pos}`, where:

* `c` is the number of Unicode code points in `src`,
  if such value is less than `max_count`.
  Otherwise, `c` is equal to `max_count`.
* `pos` is the greatest value not greater than `src_size` such that
   `x.count_codepoints_fast(src, pos, (std::size_t)-1).count`
   is equal to `c`.

Posconditions::

* `c \<= max_count` is `true`
* `pos \<= src_size` is `true`

Note::
If the input is non-conformant to the corresponding character encoding,
this function may return an incorrect value. For instance, for UTF-8
this function may simply count the bytes that are not continuation bytes.
====
[[Charset_count_codepoints]]
====
[source,cpp]
----
x.count_codepoints(src, src_size, max_count, surr_poli)
----
[horizontal]
Effect:: Counts the codepoints until is equal to `max_count`.

Return type:: `{count_codepoints_result}`
Return value:: `{c, pos}`, where:
* `c` is equal to `std::min(max_count, u32len)`, where `u32len` is the
   length of the UTF-32 string that would be generated by converting
   `src` from this encoding to UTF-32,
   <<surrogate_policy, according to `surr_poli`>>.
* `pos` is the greatest value not greater than `src_size` such that
  `x.count_codepoints(src, pos, (std::size_t)-1, surr_poli).count`
   is equal to `c`.
Posconditions::
* `c \<= max_count` is `true`
* `pos \<= src_size` is `true`

====
[[Charset_decode_unit]]
====
[source,cpp]
----
x.decode_unit(ch)
----
[horizontal]
Effect:: Decodes `ch` from this encoding to UTF-32
         assuming the policy of `<<surrogate_policy, surrogate_policy::lax>>`.
         If `ch` is an invalid character, returns U'\uFFFD'.
Return type:: `char32_t`
====

====
[source,cpp]
----
x.encode_char_func()
----
[horizontal]
Return type:: `{encode_char_f}<CharT>`
Return value:: A function pointer such that `x.encode_char_func() (ch32)` has
               the same effect as `x.encode_char(ch32)`.
====
====
[source,cpp]
----
x.encode_fill_func()
----
[horizontal]
Return type:: `{encode_fill_f}<CharT>`
Return value:: A function pointer such that `x.encode_fill_func() (dest, count, ch32)`
               has the same effect as `x.encode_fill(dest, count, ch32)`.
====
====
[source,cpp]
----
x.write_replacement_char_func()
----
[horizontal]
Return type:: `{write_replacement_char_f}<CharT>`
Return value:: A function pointer such that `x.write_replacement_char_func() (dest)`
               has the same effect as `x.write_replacement_char(dest)`
====
====
[source,cpp]
----
x.validate_func()
----
[horizontal]
Return type:: `{validate_f}`
Return value:: A function pointer such that `x.validate_func() (ch32)`
               returns the same value as `x.validate(ch32)`
====
[[Charset_from_u32]]
====
[source,cpp]
----
x.from_u32()
----
[horizontal]
Return type:: A __{Transcoder}__ from `char32_t` to `CharT`
Return value:: A transcoder that converts UTF-32 to this encoding.
====
[[Charset_to_u32]]
====
[source,cpp]
----
x.to_u32()
----
[horizontal]
Return type:: A __{Transcoder}__ from `CharT` to `char32_t`
Return value:: A transcoder that converts this encoding to UTF-32.
====
[[Charset_sanitizer]]
====
[source,cpp]
----
x.sanitizer()
----
[horizontal]
Return type:: A __{Transcoder}__ from `CharT` to `CharT`
Return value:: A transcoder that converts this encoding to this encoding,
               __i.e.__ a sanitizer of this encoding.
====
[[Charset_find_transcoder_to]]
====
.( Optional )
[source,cpp,subs=normal]
----
x.find_transcoder_to({tag}<OtherCharT>, cs_id)
----
[horizontal]
Return type:: `{dynamic_transcoder}<CharT, OtherCharT>`
Return value:: A transcoder that converts this encoding to the encoding
               corresponding to `cs_id`, or an
               <<Transcoder_null,null transcoder>>.
====

[[Charset_find_transcoder_from]]
====
.( Optional )
[source,cpp,subs=normal]
----
x.find_transcoder_from({tag}<OtherCharT>, cs_id)
----
[horizontal]
Return type:: `{dynamic_transcoder}<OtherCharT, CharT>`
Return value:: A transcoder that converts the encoding corresponding to
               `cs_id` to this encoding, or an
               <<Transcoder_null,null transcoder>>.
====

IMPORTANT: You shall not create an _Charset_ for `char32_t`, since `char32_t`
           is reserved for UTF-32.
           The library internaly assumes in many occasions that the encoding
           is UTF-32 when `CharT` is `char32_t`.

=== Class template `static_transcoder` [[static_transcoder]]

[source,cpp,subs=normal]
----
template <class SrcCharT, class DestCharT, {charset_id} Src, {charset_id} Dest>
class static_transcoder;

// sanitizers
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_ascii, scid_ascii>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_1, scid_iso_8859_1>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_2, scid_iso_8859_2>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_3, scid_iso_8859_3>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_4, scid_iso_8859_4>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_5, scid_iso_8859_5>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_6, scid_iso_8859_6>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_7, scid_iso_8859_7>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_8, scid_iso_8859_8>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_9, scid_iso_8859_9>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_10, scid_iso_8859_10>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_11, scid_iso_8859_11>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_13, scid_iso_8859_13>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_14, scid_iso_8859_14>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_15, scid_iso_8859_15>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_16, scid_iso_8859_16>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1250, scid_windows_1250>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1251, scid_windows_1251>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1252, scid_windows_1252>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1253, scid_windows_1253>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1254, scid_windows_1254>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1255, scid_windows_1255>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1256, scid_windows_1256>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1257, scid_windows_1257>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1258, scid_windows_1258>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf8, scid_utf8>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf16, scid_utf16>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_utf32>;

// to UTF-32
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_ascii, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_1, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_2, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_3, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_4, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_5, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_6, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_7, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_8, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_9, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_10, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_11, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_13, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_14, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_15, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_iso_8859_16, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1250, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1251, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1252, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1253, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1254, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1255, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1256, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1257, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_windows_1258, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf8, scid_utf32>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf16, scid_utf32>;

// from UTF-32
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_ascii>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_1>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_2>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_3>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_4>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_5>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_6>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_7>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_8>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_9>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_10>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_11>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_13>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_14>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_15>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_iso_8859_16>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_windows_1250>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_windows_1251>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_windows_1252>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_windows_1253>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_windows_1254>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_windows_1255>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_windows_1256>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_windows_1257>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_windows_1258>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_utf8>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf32, scid_utf16>;

// others
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf8, scid_utf16>;
template <class SrcCharT, class DestCharT>
class static_transcoder<SrcCharT, DestCharT, scid_utf16, scid_utf8>;
----
`static_transcoder` class template has no generic implementation.
Instead, the library provides the template specializations listed above.
All of them are empty classes, and are __{Transcoder}__, and their
member functions `<<Transcoder_transcode_func, transcode_func>>`
and `<<Transcoder_transcode_size_func,transcode_size_func>>`
never return `nullptr`.

=== Class template `static_charset` [[static_charset]]

[source,cpp,subs=normal]
----
template <class CharT, {charset_id}>
class static_charset;

template <class CharT> class static_charset<CharT, scid_ascii>;
template <class CharT> class static_charset<CharT, scid_iso_8859_1>;
template <class CharT> class static_charset<CharT, scid_iso_8859_2>;
template <class CharT> class static_charset<CharT, scid_iso_8859_3>;
template <class CharT> class static_charset<CharT, scid_iso_8859_4>;
template <class CharT> class static_charset<CharT, scid_iso_8859_5>;
template <class CharT> class static_charset<CharT, scid_iso_8859_6>;
template <class CharT> class static_charset<CharT, scid_iso_8859_7>;
template <class CharT> class static_charset<CharT, scid_iso_8859_8>;
template <class CharT> class static_charset<CharT, scid_iso_8859_9>;
template <class CharT> class static_charset<CharT, scid_iso_8859_10>;
template <class CharT> class static_charset<CharT, scid_iso_8859_11>;
template <class CharT> class static_charset<CharT, scid_iso_8859_13>;
template <class CharT> class static_charset<CharT, scid_iso_8859_14>;
template <class CharT> class static_charset<CharT, scid_iso_8859_15>;
template <class CharT> class static_charset<CharT, scid_iso_8859_16>;
template <class CharT> class static_charset<CharT, scid_windows_1250>;
template <class CharT> class static_charset<CharT, scid_windows_1251>;
template <class CharT> class static_charset<CharT, scid_windows_1252>;
template <class CharT> class static_charset<CharT, scid_windows_1253>;
template <class CharT> class static_charset<CharT, scid_windows_1254>;
template <class CharT> class static_charset<CharT, scid_windows_1255>;
template <class CharT> class static_charset<CharT, scid_windows_1256>;
template <class CharT> class static_charset<CharT, scid_windows_1257>;
template <class CharT> class static_charset<CharT, scid_windows_1258>;
template <class CharT> class static_charset<CharT, scid_utf8>;
template <class CharT> class static_charset<CharT, scid_utf16>;
template <class CharT> class static_charset<CharT, scid_utf32>;
----

`static_charset` class template has no generic implementation.
Instead, the library provides the template specializations listed above.
All of them are empty classes, and are __{Charset}__.

=== Class template `dynamic_transcoder` [[dynamic_transcoder]]

[source,cpp,subs=normal]
----
namespace strf {

template <class SrcCharT, class DestCharT>
class dynamic_transcoder {
public:
    constexpr dynamic_transcoder() noexcept;

    constexpr dynamic_transcoder
        ( const dynamic_transcoder& other) noexcept = default;

    template <{charset_id} Src, {charset_id} Dest>
    constexpr explicit dynamic_transcoder
        ( {static_transcoder}<Src, Dest> st );

    void transcode
        ( {transcode_dest}<DestCharT>& dest
        , const SrcCharT* src
        , std::size_t src_size
        , {transcoding_error_notifier}{asterisk} err_notifier
        , {surrogate_policy} surr_poli ) const;

    std::size_t transcode_size
        ( const SrcCharT* src
        , std::size_t src_size
        , {surrogate_policy} surr_poli ) const;

    constexpr {transcode_f}<SrcCharT, DestCharT> transcode_func() const noexcept;
    constexpr {transcode_size_f}<SrcCharT> transcode_size_func() const noexcept;
};

} // namespace strf
----

====
[source,cpp,subs=normal]
----
constexpr dynamic_transcoder() noexcept;
----
Default constructor
[horizontal]
Postconditions::
* `transcode_func() == nullptr`
* `transcode_size_func() == nullptr`
====

====
[source,cpp,subs=normal]
----
constexpr dynamic_transcoder
    ( const dynamic_transcoder& other) noexcept;
----
Trivial copy constructor
[horizontal]
Postconditions::
* `transcode_func() == other.transcode_func()`
* `transcode_size_func() == other.transcode_size_func()`
====

====
[source,cpp,subs=normal]
----
template <{charset_id} Src, {charset_id} Dest>
constexpr explicit dynamic_transcoder
    ( {static_transcoder}<Src, Dest> other );
----
[horizontal]
Postconditions::
* `transcode_func() == other.transcode_func()`
* `transcode_size_func() == other.transcode_size_func()`
====

====
[source,cpp,subs=normal]
----
void transcode
    ( {transcode_dest}<DestCharT>& dest
    , const SrcCharT* src
    , std::size_t src_size
    , {transcoding_error_notifier}{asterisk} err_notifier
    , {surrogate_policy} surr_poli ) const;
----
[horizontal]
Effect:: Calls `transcode_func()(dest, src, src_size, err_notifier, surr_poli)`
====
====
[source,cpp,subs=normal]
----
std::size_t transcode_size
    ( const SrcCharT* src
    , std::size_t src_size
    , {surrogate_policy} surr_poli ) const;
----
[horizontal]
Effect:: Calls `transcode_size_func()(src, src_size, surr_poli)`
====

=== Struct template `dynamic_charset_data` [[dynamic_charset_data]]

[source,cpp,subs=normal]
----
template <class CharT>
struct dynamic_charset_data {
    const char* name;
    {charset_id} id;
    char32_t replacement_char;
    std::size_t replacement_char_size;
    {validate_f} validate_func;
    {encoded_char_size_f} encoded_char_size_func;
    {encode_char_f}<CharT> encode_char_func;
    {encode_fill_f}<CharT> encode_fill_func;
    {count_codepoints_fast_f}<CharT> count_codepoints_fast_func;
    {count_codepoints_f}<CharT> count_codepoints_func;

    {write_replacement_char_f}<CharT> write_replacement_char_func;
    {decode_unit_f}<CharT> decode_unit_func;

    {dynamic_transcoder}<CharT, CharT> sanitizer;
    {dynamic_transcoder}<char32_t, CharT> from_u32;
    {dynamic_transcoder}<CharT, char32_t> to_u32;

    {find_transcoder_f}<wchar_t, CharT> find_transcoder_from_wchar;
    {find_transcoder_f}<CharT, wchar_t> find_transcoder_to_wchar;

    {find_transcoder_f}<char16_t, CharT> find_transcoder_from_char16;;
    {find_transcoder_f}<CharT, char16_t> find_transcoder_to_char16;

    {find_transcoder_f}<char, CharT> find_transcoder_from_char;
    {find_transcoder_f}<CharT, char> find_transcoder_to_char;

#if defined (__cpp_char8_t)
    {find_transcoder_f}<char8_t, CharT> find_transcoder_from_char8;
    {find_transcoder_f}<CharT, char8_t> find_transcoder_to_char8;
#else
    void* find_transcoder_from_char8 = nullptr;
    void* find_transcoder_to_char8 = nullptr;
#endif

};
----
=== Class template `dynamic_charset` [[dynamic_charset]]
[source,cpp,subs=normal]
----
template <class CharT>
class dynamic_charset {
public:

    using code_unit = CharT;

    dynamic_charset(const dynamic_charset& other) = default;

    dynamic_charset
        ( const {dynamic_charset_data}<CharT>& d );

    dynamic_charset& operator=(const dynamic_charset& other) noexcept;

    bool operator==(const dynamic_charset& other) const noexcept;

    bool operator!=(const dynamic_charset& other) const noexcept;

    void swap(dynamic_charset& other) noexcept;

    const char* name() const noexcept;

    constexpr {charset_id} id() const noexcept;

    constexpr char32_t replacement_char() const noexcept;

    constexpr std::size_t replacement_char_size() const noexcept;

    constexpr std::size_t validate(char32_t ch) const; // noexcept

    constexpr std::size_t encoded_char_size(char32_t ch) const; // noexcept

    code_unit* encode_char(code_unit* dest, char32_t ch) const; // noexcept

    void encode_fill
        ( {transcode_dest}<CharT>& dest, std::size_t count, char32_t ch ) const;

    std::size_t count_codepoints_fast
        ( const code_unit* src, std::size_t src_size
        , std::size_t max_count ) const;

    std::size_t count_codepoints
        ( const code_unit* src, std::size_t src_size
        , std::size_t max_count, {surrogate_policy} surr_poli ) const;

    void write_replacement_char({transcode_dest}<CharT>& dest) const;

    char32_t decode_unit(code_unit ch) const;

    {encode_char_f}<CharT> encode_char_func() const noexcept;

    {encode_fill_f}<CharT> encode_fill_func() const noexcept;

    {write_replacement_char_f}<CharT> write_replacement_char_func() const noexcept;

    {dynamic_transcoder}<char32_t, CharT> from_u32() const;

    {dynamic_transcoder}<CharT, char32_t> to_u32() const;

    {dynamic_transcoder}<CharT, CharT> sanitizer() const;

    {dynamic_transcoder}<CharT, wchar_t> find_transcoder_to
        ( {tag}<wchar_t>, {charset_id} id) const;

    {dynamic_transcoder}<wchar_t, CharT> find_transcoder_from
        ( {tag}<wchar_t>, {charset_id} id) const;

    {dynamic_transcoder}<CharT, char16_t> find_transcoder_to
        ( {tag}<char16_t>, {charset_id} id) const;

    {dynamic_transcoder}<char16_t, CharT> find_transcoder_from
        ( {tag}<char16_t>, {charset_id} id) const;

    {dynamic_transcoder}<CharT, char> find_transcoder_to
        ( {tag}<char>, {charset_id} id) const;

    {dynamic_transcoder}<char, CharT> find_transcoder_from
        ( {tag}<char>, {charset_id} id) const;

#if defined (__cpp_char8_t)
    {dynamic_transcoder}<CharT, char8_t> find_transcoder_to
        ( {tag}<char8_t>, {charset_id} id) const;

    {dynamic_transcoder}<char8_t, CharT> find_transcoder_from
        ( {tag}<char8_t>, {charset_id} id) const;
#endif

private:

    const {dynamic_charset_data}* data; // exposition only
};
----

====
[source,cpp,subs=normal]
----
dynamic_charset(const dynamic_charset& other);
----
Trivial copy constructor.
[horizontal]
Effect:: `this\->data = other.data`
====
====
[source,cpp,subs=normal]
----
dynamic_charset(const {dynamic_charset_data}<CharT>& d);
----
[horizontal]
Effect:: `this\->data = d`
====
====
[source,cpp,subs=normal]
----
dynamic_charset& operator=(const dynamic_charset& other) noexcept
----
[horizontal]
Effect:: `this\->data = other.data`
====
====
[source,cpp,subs=normal]
----
bool operator==(const dynamic_charset& other) const noexcept;
----
[horizontal]
Return value:: `this\->data == other.data`
====
====
[source,cpp,subs=normal]
----
bool operator!=(const dynamic_charset& other) const noexcept;
----
[horizontal]
Return value:: `this\->data != other.data`
====
====
[source,cpp,subs=normal]
----
void swap(dynamic_charset& other) noexcept;
----
[horizontal]
Effect:: Equivalent to `std::swap(this\->data, other.data)`
====
====
[source,cpp,subs=normal]
----
const char* name() const noexcept;
----
[horizontal]
Return value:: `this\->data\->name`
====
====
[source,cpp,subs=normal]
----
constexpr {charset_id} id() const noexcept;
----
[horizontal]
Return value:: `this\->data\->id`
====
====
[source,cpp,subs=normal]
----
constexpr char32_t replacement_char() const noexcept;
----
[horizontal]
Return value:: `this\->data\->replacement_char`
====
====
[source,cpp,subs=normal]
----
constexpr std::size_t replacement_char_size() const noexcept;
----
[horizontal]
Return value:: `this\->data\->replacement_char_size`
====
====
[source,cpp,subs=normal]
----
constexpr std::size_t validate(char32_t ch) const; // noexcept
----
[horizontal]
Effect:: Calls and returns `this\->data\->validate_func(ch)`.
====
====
[source,cpp,subs=normal]
----
constexpr std::size_t encoded_char_size(char32_t ch) const; // noexcept
----
[horizontal]
Effect:: Calls and returns `this\->data\->encoded_char_size_func(ch)`.
====
====
[source,cpp,subs=normal]
----
code_unit* encode_char(code_unit* dest, char32_t ch) const; // noexcept
----
[horizontal]
Effect:: Calls and returns `this\->data\->encoded_char_func(ch)`.
====
====
[source,cpp,subs=normal]
----
void encode_fill
    ( {transcode_dest}<CharT>& dest, std::size_t count, char32_t ch ) const;
----
[horizontal]
Effect:: Calls and returns
       `this\->data\->encode_fill_func(dest, count, ch)`.
====
====
[source,cpp,subs=normal]
----
std::size_t count_codepoints_fast
    ( const code_unit* src, std::size_t src_size
    , std::size_t max_count ) const;
----
[horizontal]
Effect:: Calls and returns `this\->data\->count_codepoints_fast_func(src, src_size, max_count)`.
====
====
[source,cpp,subs=normal]
----
std::size_t count_codepoints
    ( const code_unit* src, std::size_t src_size
    , std::size_t max_count, {surrogate_policy} surr_poli ) const;
----
[horizontal]
Effect:: Calls and returns
        `this\->data\->count_codepoints_func(src, src_size, max_count, surr_poli)`.
====
====
[source,cpp,subs=normal]
----
void write_replacement_char({transcode_dest}<CharT>& dest) const;
----
[horizontal]
Effect:: Calls `this\->data\->write_replacement_char_func(dest)`.
====
====
[source,cpp,subs=normal]
----
char32_t decode_unit(code_unit ch) const;
----
[horizontal]
Effect:: Calls and returns `this\->data\->decode_unit_func(ch)`.
====
====
[source,cpp,subs=normal]
----
{encode_char_f}<CharT> encode_char_func() const noexcept;
----
====
====
[source,cpp,subs=normal]
----
{encode_fill_f}<CharT> encode_fill_func() const noexcept;
----
[horizontal]
Return value:: `this\->data\->encode_fill_func`.
====
====
[source,cpp,subs=normal]
----
{write_replacement_char_f}<CharT> write_replacement_char_func() const noexcept;
----
[horizontal]
Return value:: `this\->data\->write_replacement_char_func`.
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<char32_t, CharT> from_u32() const;
----
[horizontal]
Return value:: `this\->data\->from_u32`.
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<CharT, char32_t> to_u32() const;
----
[horizontal]
Return value:: `this\->data\->to_u32`.
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<CharT, CharT> sanitizer() const;
----
[horizontal]
Return value:: `this\->data\->sanitizer`.
====

====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<CharT, char> find_transcoder_to
    ( {tag}<char>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_to_char(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<CharT, char>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<char, CharT> find_transcoder_from
    ( {tag}<char>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_from_char(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<char, CharT>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<CharT, char8_t> find_transcoder_to
    ( {tag}<char8_t>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_to_char8(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<CharT, char8_t>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<char8_t, CharT> find_transcoder_from
    ( {tag}<char8_t>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_from_char8(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<char8_t, CharT>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<CharT, char16_t> find_transcoder_to
    ( {tag}<char16_t>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_to_char16(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<CharT, char16_t>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<char16_t, CharT> find_transcoder_from
    ( {tag}<char16_t>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_from_char16(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<char16_t, CharT>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<CharT, wchar_t> find_transcoder_to
    ( {tag}<wchar_t>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_to_wchar(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<CharT, wchar_t>{}`
====
====
[source,cpp,subs=normal]
----
{dynamic_transcoder}<wchar_t, CharT> find_transcoder_from
    ( {tag}<wchar_t>, {charset_id} id ) const;
----
[horizontal]
Return value:: `this\->data\->transcoder_finder_from_wchar(id)` if such function pointer
is not null. Otherwise returns `{dynamic_transcoder}<wchar_t, CharT>{}`
====


=== Function template `find_transcoder` [[find_transcoder]]

[source,cpp,subs=normal]
----
template <class SrcCharset, class DestCharset>
auto find_transcoder(SrcCharset src, DestCharset dest);
----
Requirements:: `SrcCharset` and `DestCharset` are __{Charset}__ types.
Return type:: A type that is __{Transcoder}__
//-
Return value::
* Returns the default value of `{static_transcoder}<SrcID, DestID>`
  if such template instantiation is defined and
  `SrcCharset` is ( or derives from ) `{static_charset}<SrcID>` and
  `DestCharset` is ( or derives from ) `{static_charset}<DestID>`;
* otherwise, returns `src.<<Charset_sanitizer,sanitizer>>()` if
  `src.<<Charset_id,id>>()` is equal to `dest.<<Charset_id,id>>()`
  and `SrcCharset::{code_unit}` is the same type as `DestCharset::{code_unit}`;
* otherwise, returns `src.<<Charset_to_u32,to_u32>>()`
  if `DestCharset::{code_unit}` is `char32_t`;
* otherwise, returns `dest.<<Charset_from_u32,from_u32>>()`
  if `SrcCharset::{code_unit}` is `char32_t`;
* otherwise, returns
  `src.<<Charset_find_transcoder_to,find_transcoder_to>>(dest_ch, dest.id())`
  if such expression
  is well-formed and returns a <<Transcoder_null,non null transcoder>>
  , where `dest_ch` is `{tag}<DestCharset::{code_unit}>{}`
* otherwise, returns
  `dest.<<Charset_find_transcoder_from,find_transcoder_from>>(src_ch, src.id())`
   if such expression is well-formed, where `src_sh` is `{tag}<SrcCharset::{code_unit}>{}`
* otherwise returns `{dynamic_transcoder}<SrcCharset::{code_unit}, DestCharset::{code_unit}>{}`.

NOTE: When `find_transcoder` returns an <<Transcoder_null,null transcoder>>
, you still can use `{decode_encode}` and `decode_encode_size`.

=== Function template `decode_encode`  [[decode_encode]]

[source,cpp,subs=normal]
----
namespace strf {

template<class SrcCharT, class DestCharT>
void decode_encode
    ( {transcode_dest}<DestCharT>& dest
    , {transcode_f}<SrcCharT, char32_t> to_u32
    , {transcode_f}<char32_t, DestCharT> from_u32
    , const SrcCharT* src
    , std::size_t src_size
    , {transcoding_error_notifier}{asterisk} err_notifier
    , {surrogate_policy} surr_poli );

} // namespace strf
----

Converts the content in `src` to UTF-32 using `to_u32`,
then writes the result to `dest` using `from_u32`.

[horizontal]
Postcondition:: `dest.<<destination_hpp#output_buffer_recycle,recycle>>()` is not called if
`dest.<<destination_hpp#output_buffer_buffer_space,buffer_space>>()` is not less then the value returned by
`{decode_encode_size}(to_u32, size_calc_func, src, src_size, err_notifier, surr_poli)`,
where `size_calc_func` is the return value of
`dest_enc.<<Charset_from_u32,from_u32>>().<<Transcoder_transcode_size_func, transcode_size_func>>()`,
where `dest_enc` is the __Charset__ object such that the return value of
`dest_enc.<<Charset_to_u32,to_u32>>().<<Transcoder_transcode_func,transcode_func>>()`
is equal to `to_u32`.

=== Function template `decode_encode_size` [[decode_encode_size]]

[source,cpp,subs=normal]
----
namespace strf {

template<class SrcCharT>
std::size_t decode_encode_size
    ( {transcode_f}<SrcCharT, char32_t> to_u32
    , {transcode_size_f}<char32_t> size_calc_func
    , const SrcCharT* src
    , std::size_t src_size
    , {transcoding_error_notifier}{asterisk} err_notifier
    , {surrogate_policy} surr_poli );

} // namespace strf
----
[horizontal]
Return value::
The return of `size_calc_func` called over the UTF-32 content obtained
by passing `src` to `to_u32`.

=== Type aliases for charsets [[static_charset_aliases]]

[source,cpp,subs=normal]
----
namespace strf {

template <class CharT>
using ascii_t = static_charset<CharT, scid_ascii>;

template <class CharT>
using iso_8859_1_t = static_charset<CharT, scid_iso_8859_1>;

template <class CharT>
using iso_8859_2_t = static_charset<CharT, scid_iso_8859_2>;

template <class CharT>
using iso_8859_3_t = static_charset<CharT, scid_iso_8859_3>;

template <class CharT>
using iso_8859_4_t = static_charset<CharT, scid_iso_8859_4>;

template <class CharT>
using iso_8859_5_t = static_charset<CharT, scid_iso_8859_5>;

template <class CharT>
using iso_8859_6_t = static_charset<CharT, scid_iso_8859_6>;

template <class CharT>
using iso_8859_7_t = static_charset<CharT, scid_iso_8859_7>;

template <class CharT>
using iso_8859_8_t = static_charset<CharT, scid_iso_8859_8>;

template <class CharT>
using iso_8859_9_t = static_charset<CharT, scid_iso_8859_9>;

template <class CharT>
using iso_8859_10_t = static_charset<CharT, scid_iso_8859_10>;

template <class CharT>
using iso_8859_11_t = static_charset<CharT, scid_iso_8859_11>;

template <class CharT>
using iso_8859_13_t = static_charset<CharT, scid_iso_8859_13>;

template <class CharT>
using iso_8859_14_t = static_charset<CharT, scid_iso_8859_14>;

template <class CharT>
using iso_8859_15_t = static_charset<CharT, scid_iso_8859_15>;

template <class CharT>
using iso_8859_16_t = static_charset<CharT, scid_iso_8859_16>;

template <class CharT>
using windows_1250_t = static_charset<CharT, scid_windows_1250>;

template <class CharT>
using windows_1251_t = static_charset<CharT, scid_windows_1251>;

template <class CharT>
using windows_1252_t = static_charset<CharT, scid_windows_1252>;

template <class CharT>
using windows_1253_t = static_charset<CharT, scid_windows_1253>;

template <class CharT>
using windows_1254_t = static_charset<CharT, scid_windows_1254>;

template <class CharT>
using windows_1255_t = static_charset<CharT, scid_windows_1255>;

template <class CharT>
using windows_1256_t = static_charset<CharT, scid_windows_1256>;

template <class CharT>
using windows_1257_t = static_charset<CharT, scid_windows_1257>;

template <class CharT>
using windows_1258_t = static_charset<CharT, scid_windows_1258>;

template <class CharT>
using utf8_t = static_charset<CharT, scid_utf8>;

template <class CharT>
using utf16_t = static_charset<CharT, scid_utf16>;

template <class CharT>
using utf32_t = static_charset<CharT, scid_utf32>;

template <class CharT>
using utf_t = /* see below */;

} // namespace strf
----

[[utf_t]]
====
[source,cpp]
----
template <class CharT>
using utf_t = /* ... */;
----
`utf_t<CharT>` is an alias to `utf8_t<CharT>`, `utf16_t<CharT>` or `utf32_t<CharT>`,
depending on the value of `sizeof(CharT)`.
====

=== Template variable for charsets [[static_charset_constexpr]]

[source,cpp,subs=normal]
----
namespace strf {

template <class CharT> constexpr ascii_t<CharT>         ascii = {};

template <class CharT> constexpr iso_8859_1_t<CharT>    iso_8859_1 = {};
template <class CharT> constexpr iso_8859_2_t<CharT>    iso_8859_2 = {};
template <class CharT> constexpr iso_8859_3_t<CharT>    iso_8859_3 = {};
template <class CharT> constexpr iso_8859_4_t<CharT>    iso_8859_4 = {};
template <class CharT> constexpr iso_8859_5_t<CharT>    iso_8859_5 = {};
template <class CharT> constexpr iso_8859_6_t<CharT>    iso_8859_6 = {};
template <class CharT> constexpr iso_8859_7_t<CharT>    iso_8859_7 = {};
template <class CharT> constexpr iso_8859_8_t<CharT>    iso_8859_8 = {};
template <class CharT> constexpr iso_8859_9_t<CharT>    iso_8859_9 = {};
template <class CharT> constexpr iso_8859_10_t<CharT>   iso_8859_10 = {};
template <class CharT> constexpr iso_8859_11_t<CharT>   iso_8859_11 = {};
template <class CharT> constexpr iso_8859_13_t<CharT>   iso_8859_13 = {};
template <class CharT> constexpr iso_8859_14_t<CharT>   iso_8859_14 = {};
template <class CharT> constexpr iso_8859_15_t<CharT>   iso_8859_15 = {};
template <class CharT> constexpr iso_8859_16_t<CharT>   iso_8859_16 = {};

template <class CharT> constexpr windows_1250_t<CharT>  windows_1250 = {};
template <class CharT> constexpr windows_1251_t<CharT>  windows_1251 = {};
template <class CharT> constexpr windows_1252_t<CharT>  windows_1252 = {};
template <class CharT> constexpr windows_1253_t<CharT>  windows_1253 = {};
template <class CharT> constexpr windows_1254_t<CharT>  windows_1254 = {};
template <class CharT> constexpr windows_1255_t<CharT>  windows_1255 = {};
template <class CharT> constexpr windows_1256_t<CharT>  windows_1256 = {};
template <class CharT> constexpr windows_1257_t<CharT>  windows_1257 = {};
template <class CharT> constexpr windows_1258_t<CharT>  windows_1258 = {};

template <class CharT> constexpr utf8_t<CharT>          utf8 = {};
template <class CharT> constexpr utf16_t<CharT>         utf16 = {};
template <class CharT> constexpr utf32_t<CharT>         utf32 = {};
template <class CharT> constexpr {utf_t}<CharT>           utf = {};

} // namespace strf
----
