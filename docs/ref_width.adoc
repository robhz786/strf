////
Copyright (C) (See commit logs on github.com/robhz786/strf)
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
////

:WidthCalculator: <<WidthCalculator,WidthCalculator>>
:width_calculator_c: <<width_calculator_c,width_calculator_c>>
:width_and_pos: <<width_and_pos,width_and_pos>>
:fast_width: <<fast_width,fast_width>>
:width_as_u32len: <<width_as_u32len,width_as_u32len>>
:width_as_fast_u32len: <<width_as_fast_u32len,width_as_fast_u32len>>
:fast_width_t: <<fast_width,fast_width>>
:width_as_u32len_t: <<width_as_u32len,width_as_u32len>>
:width_as_fast_u32len_t: <<width_as_fast_u32len,width_as_fast_u32len>>
:make_width_calculator: <<make_width_calculator,make_width_calculator>>
:width_t: <<width_t,width_t>>
:code_unit: <<Charset_code_unit,code_unit>>

== Width Calculation

=== Facet category `width_calculator_c` [[width_calculator_c]]

[source,cpp,subs=normal]
----
namespace strf {

struct width_calculator_c
{
    static constexpr bool constrainable = true;

    static constexpr {width_as_u32len} get_default() noexcept;
};

} // namespace strf
----

For a type to be a facet of the `width_calculator_c` category, it has to
satisfy the __{WidthCalculator}__ requirements.

==== Type requirement _WidthCalculator_ [[WidthCalculator]]

Given

* `CharT`, one of the types: `char`, `char8_t`, `char16_t`, `char32_t` or `wchar_t`
* `CharsetT`, a __{Charset}__ type for type `CharT`
* `charset`, a value of type `CharsetT`
* `ch` a value of type `CharT`
* `limit`, a value of type `{width_t}`
* `str`, a value of type `const CharT*`
        pointing to a string encoded according to `charset`.
* `str_len`, a value of type `std::ptrdiff_t` equal to the length of string `str`.
* `surr_poli`, a value of type `{surrogate_policy}`

For a type `X` to be a _WidthCalculator_, given an object `x` of type `X`,
the following syntax and requirements have to be satisfied:
====
[source,cpp]
----
X::category
----
A type alias to `{width_calculator_c}`.
====
====
[source,cpp]
----
x.char_width(charset, ch)
----
[horizontal]
Return type:: `{width_t}`
Return value:: The width of `ch` when encoded according to `charset`.
====
====
[source,cpp,subs=normal]
----
x.str_width(charset, limit, str, str_len, surr_poli)
----
[horizontal]
Return type::: `{width_t}`
Return value::: The width of the string `str` if it is less than `limit`.
               Otherwise, it can be any value that is greater than or
               equal to `limit`.
====
====
[source,cpp]
----
x.str_width_and_pos(charset, limit, str, str_len, surr_poli)
----
[horizontal]
Effect::: Calculates the width of `str`. If such value is less than
         `limit`, then calculates the size of the substring of `str`
         whose width is equal to `limit`.
Return type::: `{width_and_pos}`
Return value::: A value `ret` of type `{width_and_pos}`, such that
* `ret.pos` is the greatest value that is less than or equal to `str_len`
  such that `x.width(charset, width_max, str, ret.pos, surr_poli).width`
  is less than or equal to `limit`.
* `ret.width` is the width of the substring of `str` with size `ret.pos`
  that starts at the same position of `str`.
====

NOTE: The library provides three classes that
      satisfy _WidthCalculator_: `{fast_width_t}`, `{width_as_fast_u32len_t}`,
      `{width_as_u32len_t}`.

////
What "width" of a string means is up to each _WidthCalculator_ type.
It doesn't have to be accurate, after all that would require to
      consider the font in which the string is displayed, which is
      usually impractical.
      However it is expected the width to be a
      https://en.wikipedia.org/wiki/Monotonic_function[monotonically
      increasing function] in relation to be size
////
==== Struct `width_and_pos` [[width_and_pos]]

[source,cpp,subs=normal]
----
struct width_and_pos {
    {width_t} width;
    std::ptrdiff_t pos;
};
----

=== Class `fast_width_t` [[fast_width]]

Class `fast_width_t` is a facet of the category `{width_calculator_c}`
that evaluates the width of a string as its size.

[source,cpp,subs=normal]
----
class fast_width_t final
{
public:
    using category = {width_calculator_c};

    template <typename Charset>
    constexpr {width_t} <<fast_width_char_width,char_width>>
        ( Charset
        , typename Charset::{code_unit} ) const noexcept;

    template <typename Charset>
    constexpr {width_t} <<fast_width_str_width,str_width>>
        ( Charset
        , {width_t} limit
        , const typename Charset::{code_unit}*
        , std::ptrdiff_t str_len
        , {surrogate_policy} ) const noexcept;

    template <typename Charset>
    {width_and_pos} <<fast_width_str_width_and_pos,str_width_and_pos>>
        ( Charset
        , {width_t} limit
        , const typename Charset::{code_unit}*
        , std::ptrdiff_t str_len
        , {surrogate_policy} ) const noexcept;
};

constexpr fast_width_t fast_width {};
----
[[fast_width_char_width]]
====
[source,cpp,subs=normal]
----
template <typename Charset>
constexpr {width_t} char_width
    ( Charset
    , typename Charset::{code_unit} ) const noexcept;
----
[horizontal]
Return value:: `1`
====
[[fast_width_str_width]]
====
[source,cpp,subs=normal]
----
template <typename Charset>
constexpr {width_t} str_width
    ( Charset
    , {width_t} limit
    , const typename Charset::{code_unit}*
    , std::ptrdiff_t str_len
    , {surrogate_policy} ) const noexcept;
----
[horizontal]
Return value:::
* `str_len`, if `str_len` is less than or equal to `limit.floor()`
*  otherwise, `limit`
====
[[fast_width_str_width_and_pos]]
====
[source,cpp,subs=normal]
----
template <typename Charset>
{width_and_pos} str_width_and_pos
    ( Charset
    , {width_t} limit
    , const typename Charset::{code_unit}*
    , std::ptrdiff_t str_len
    , {surrogate_policy} ) const noexcept;
----
[horizontal]
Return value::: The return value `ret` is such that

* if `limit \<= 0` is `true`, then `ret.width` and `ret.pos` are `0`;
* otherwise, if `limit.floor()` is less than `str_len`, then
`ret.width` and `ret.pos` are equal to `limit.floor()`;
* otherwise, `ret.width` and `ret.pos` are equal to `str_len`.
====


=== Class `width_as_fast_u32len_t` [[width_as_fast_u32len]]

Class `width_as_fast_u32len_t` is a facet of the category `{width_calculator_c}`.
It evaluates the width of a string as the number of Unicode code points.
However, to gain performance, differently from `{width_as_u32len}`,
it assumes that the string is totally conformant to its encoding.
For example, if the charset is UTF-8 then `str_width`
may simply return the number of bytes whose bit pattern does not
characterizes it as a https://en.wikipedia.org/wiki/UTF-8#Encoding[continuation byte]
( `10xxxxxx` ).

[source,cpp,subs=normal]
----
class width_as_fast_u32len_t final
{
public:
    using category = {width_calculator_c};

    template <typename Charset>
    constexpr {width_t} <<width_as_fast_u32len_char_width,char_width>>
        ( Charset cs
        , typename Charset::{code_unit} ) const noexcept;

    template <typename Charset>
    {width_t} <<width_as_fast_u32len_str_width,str_width>>
        ( Charset cs
        , {width_t} limit
        , const typename Charset::{code_unit}* str
        , std::ptrdiff_t str_len
        , {surrogate_policy} ) const noexcept;

    template <typename Charset>
    {width_and_pos} <<width_as_fast_u32len_str_width_and_pos,str_width_and_pos>>
        ( Charset cs
        , {width_t} limit
        , const typename Charset::{code_unit}* str
        , std::ptrdiff_t str_len
        , {surrogate_policy} ) const noexcept;
};

constexpr width_as_fast_u32len_t width_as_fast_u32len {};
----
[[width_as_fast_u32len_char_width]]
====
[source,cpp,subs=normal]
----
template <typename Charset>
constexpr {width_t} char_width
    ( Charset
    , typename Charset::{code_unit} ) const noexcept;
----
[horizontal]
Return value::: `1`
====
[[width_as_fast_u32len_str_width]]
====
[source,cpp,subs=normal]
----
template <typename Charset>
{width_t} str_width
    ( Charset cs
    , {width_t} limit
    , const typename Charset::{code_unit}* str
    , std::ptrdiff_t str_len
    , {surrogate_policy} ) const noexcept;
----
[horizontal]
Return value:::
* `0`, if `limit \<= 0` is `true`
* otherwise, `cs.<<Charset_count_codepoints_fast,count_codepoints_fast>>(str, str_len, limit.floor()).count`.
====
[[width_as_fast_u32len_str_width_and_pos]]
====
[source,cpp,subs=normal]
----
template <typename Charset>
{width_and_pos} str_width_and_pos
    ( Charset cs
    , {width_t} limit
    , const typename Charset::{code_unit}* str
    , std::ptrdiff_t str_len
    , {surrogate_policy} ) const noexcept;
----
[horizontal]
Return value::: The return value `ret` is such that

* If `limit \<= 0` is `true`, then then `ret.width` and `ret.pos` are `0`;
* otherwise, `ret.width` is equal to `ret2.count` and `ret.pos` is equal
  to `cs.<<Charset_count_codepoints_fast,count_codepoints_fast>>(str, str_len, lim).pos`
====

=== Class `width_as_u32len_t` [[width_as_u32len]]

Class `width_as_fast_u32len_t` is a facet of the category `{width_calculator_c}`.
It evaluates the width of a string as the number of Unicode code points,
assuming that any non-conformity to its corresponding charset is replaced
by one codepoint ( since it should be replaced by the
https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character[replacement character `"\uFFFD"` (&#65533;) ] ).

[source,cpp,subs=normal]
----
class width_as_u32len_t final
{
public:
    using category = {width_calculator_c};

    template <typename Charset>
    constexpr {width_t} <<width_as_u32len_char_width,char_width>>
        ( Charset cs
        , typename Charset::{code_unit} ) const noexcept;

    template <typename Charset>
    {width_t} <<width_as_u32len_str_width,str_width>>
        ( Charset cs
        , {width_t} limit
        , const typename Charset::{code_unit}* str
        , std::ptrdiff_t str_len
        , {surrogate_policy} ) const noexcept;

    template <typename Charset>
    {width_and_pos} <<width_as_u32len_str_width_and_pos,str_width_and_pos>>
        ( Charset cs
        , {width_t} limit
        , const typename Charset::{code_unit}* str
        , std::ptrdiff_t str_len
        , {surrogate_policy} ) const noexcept;
};

constexpr width_as_u32len_t width_as_u32len = {};
----
[[width_as_u32len_char_width]]
====
[source,cpp,subs=normal]
----
template <typename Charset>
constexpr {width_t} char_width
    ( Charset
    , typename Charset::{code_unit} ) const noexcept;
----
[horizontal]
Return value:: `1`
====
[[width_as_u32len_str_width]]
====
[source,cpp,subs=normal]
----
template <typename Charset>
{width_t} str_width
    ( Charset cs
    , {width_t} limit
    , const typename Charset::{code_unit}* str
    , std::ptrdiff_t str_len
    , {surrogate_policy} ) const noexcept;
----
[horizontal]
Return value:::
* `0`, if `limit \<= 0` is `true`
* otherwise, `cs.<<Charset_count_codepoints,count_codepoints>>(str, str_len, limit.floor()).count`.
====
[[width_as_u32len_str_width_and_pos]]
====
[source,cpp,subs=normal]
----
template <typename Charset>
{width_and_pos} str_width_and_pos
    ( Charset cs
    , {width_t} limit
    , const typename Charset::{code_unit}* str
    , std::ptrdiff_t str_len
    , {surrogate_policy} ) const noexcept;
----
[horizontal]
Return value::: The return value `ret` is such that

* If `limit \<= 0` is `true`, then then `ret.width` and `ret.pos` are `0`;
* otherwise, `ret.width` is equal to `ret2.count` and `ret.pos` is equal to
  `cs.<<Charset_count_codepoints,count_codepoints>>(str, str_len, lim).pos`
====

=== Class `std_width_calc` [[std_width_calc]]

The facet `std_width_calc` calculates the width just as
http://eel.is/c++draft/format.string.std#11[specified] to `std::format`.


[source,cpp,subs=normal]
----
class std_width_calc {
public:
    using category = {width_calculator_c};

    template <typename Charset>
    static {width_t} <<std_width_calc_char_width,char_width>>
        ( Charset cs
        , typename Charset::{code_unit} ) const;

    template <typename Charset>
    static {width_t} <<std_width_calc_str_width,str_width>>
        ( Charset cs
        , {width_t} limit
        , const typename Charset::{code_unit}* str
        , std::ptrdiff_t str_len
        , {surrogate_policy} ) const;

    template <typename Charset>
    static {width_and_pos} <<std_width_calc_str_width_and_pos,str_width_and_pos>>
        ( Charset cs
        , {width_t} limit
        , const typename Charset::{code_unit}* str
        , std::ptrdiff_t str_len
        , {surrogate_policy} ) const;
};
----
==== Member functions

[[std_width_calc_char_width]]
====
[source,cpp,subs=normal]
----
template <typename Charset>
static {width_t} char_width
    ( Charset cs
    , typename Charset::{code_unit} ch) const;
----
[horizontal]
Return value::
----
 (  (0x1100 <= ch32 && ch32 <= 0x115F)
||  (0x2329 <= ch32 && ch32 <= 0x232A)
||  (0x2E80 <= ch32 && ch32 <= 0x303E)
||  (0x3040 <= ch32 && ch32 <= 0xA4CF)
||  (0xAC00 <= ch32 && ch32 <= 0xD7A3)
||  (0xF900 <= ch32 && ch32 <= 0xFAFF)
||  (0xFE10 <= ch32 && ch32 <= 0xFE19)
||  (0xFE30 <= ch32 && ch32 <= 0xFE6F)
||  (0xFF00 <= ch32 && ch32 <= 0xFF60)
||  (0xFFE0 <= ch32 && ch32 <= 0xFFE6)
|| (0x1F300 <= ch32 && ch32 <= 0x1F64F)
|| (0x1F900 <= ch32 && ch32 <= 0x1F9FF)
|| (0x20000 <= ch32 && ch32 <= 0x2FFFD)
|| (0x30000 <= ch32 && ch32 <= 0x3FFFD) )  ? width_t(2) : width_t(1)
----
, where `ch32` is the return value of `cs.decode_unit(ch)`

====
[[std_width_calc_str_width]]
====
[source,cpp,subs=normal]
----
template <typename Charset>
static {width_t} str_width
    ( Charset cs
    , {width_t} limit
    , const typename Charset::{code_unit}* str
    , std::ptrdiff_t str_len
    , {surrogate_policy} surr_poli) const;
----
Return value:: `std::min(limit, w)`, where `w` is the sum of the extimated widths
of the grapheme clusters in the UTF-32 string obtained by converting `str`
to UTF-32 via `cs`, __i.e.__ by calling
+
[source,cpp,subs=normal]
----
cs.<<Charset_to_u32,to_u32>>().<<Transcoder_transcode,transcode>>(..., str, str_len, nullptr, surr_poli )
----
+
The width of each grapheme cluster is assumed to be equal to the width
of its first codepoints `ch32`, which is assumed to equal to
`<<std_width_calc_char_width, char_width>>(<<strf_hpp.html#static_charset_constexpr,utf>><char32_t>, ch32)`.
====


[[std_width_calc_str_width_and_pos]]
====
[source,cpp,subs=normal]
----
template <typename Charset>
static {width_and_pos} str_width_and_pos
    ( Charset cs
    , {width_t} limit
    , const typename Charset::{code_unit}* str
    , std::ptrdiff_t str_len
    , {surrogate_policy} surr_poli) const;
----
Return value:: a value `r` such that
+
* `r.width` is same value returned by `str_width(cs, limit, str, str_len, surr_poli)`
* `r.pos` is greateast value such that the expression below evaluates to `true`:
+
[source,cpp,subs=normal]
----
str_width(cs, strf::width_t::max(), str, r.pos, surr_poli) \<= limit
----
====


=== Class `width_t` [[width_t]]

`width_t` is an signed type that implements
https://en.wikipedia.org/wiki/Q_(number_format)[Q16.16] arithmetics and
is used to represent width of textual content when
<<alignment_format,text alignment formatting>> is used.
The value of `width_t(1)` corresponds to one https://en.wikipedia.org/wiki/En_(typography)[en].

[source,cpp,subs=normal]
----
namespace strf {

class width_t {
public:
    struct from_underlying_tag{};
    constexpr width_t() noexcept;
    constexpr width_t(std::int16_t) noexcept;
    constexpr width_t(const width_t&) noexcept;
    constexpr width_t(from_underlying_tag, std::int32_t) noexcept;

    constexpr width_t& operator=(const width_t& other) noexcept;
    constexpr width_t& operator=(std::int16_t& x) noexcept;

    constexpr bool operator==(const width_t& other) const noexcept;
    constexpr bool operator!=(const width_t& other) const noexcept;
    constexpr bool operator<(const width_t& other) const noexcept;
    constexpr bool operator>(const width_t& other) const noexcept;
    constexpr bool operator\<=(const width_t& other) const noexcept;
    constexpr bool operator>=(const width_t& other) const noexcept;

    constexpr std::int16_t floor() const noexcept;
    constexpr std::int32_t round() const noexcept;

    constexpr width_t operator-() const noexcept;
    constexpr width_t operator+() const noexcept;
    constexpr width_t& operator+=(width_t other) noexcept;
    constexpr width_t& operator-=(width_t other) noexcept;
    constexpr width_t& operator{asterisk}=(std::int16_t m) noexcept;
    constexpr width_t& operator/=(std::int16_t d) noexcept;
    constexpr width_t& operator{asterisk}=(width_t other) noexcept;
    constexpr width_t& operator/=(width_t other) noexcept;

    constexpr std::int32_t underlying_value() const noexcept;
    constexpr static width_t from_underlying(std::int32_t) noexcept;

    constexpr static width_t max() noexcept; // maximum possible value
    constexpr static width_t min() noexcept; // minimum possible value

private:
    std::int32_t _underlying_value; // exposition only
};

constexpr width_max = width_t::max();
constexpr width_min = width_t::min();

constexpr bool operator==(width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator==(std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator!=(width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator!=(std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator< (width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator< (std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator\<=(width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator\<=(std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator> (width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator> (std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator>=(width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator>=(std::int16_t lhs, width_t rhs) noexcept;

constexpr width_t operator+(width_t lhs, width_t rhs) noexcept;
constexpr width_t operator+(std::int16_t lhs, width_t rhs) noexcept;
constexpr width_t operator+(width_t lhs, std::int16_t rhs) noexcept;
constexpr width_t operator-(width_t lhs, width_t rhs) noexcept;
constexpr width_t operator-(std::int16_t lhs, width_t rhs) noexcept;
constexpr width_t operator-(width_t lhs, std::int16_t rhs) noexcept;
constexpr width_t operator{asterisk}(width_t lhs, width_t rhs) noexcept;
constexpr width_t operator{asterisk}(std::int16_t lhs, width_t rhs) noexcept;
constexpr width_t operator{asterisk}(width_t lhs, std::int16_t rhs) noexcept;
constexpr width_t operator/(width_t lhs, width_t rhs) noexcept;
constexpr width_t operator/(std::int16_t lhs, width_t rhs) noexcept;
constexpr width_t operator/(width_t lhs, std::int16_t rhs) noexcept;


constexpr width_t sat_add(width_t, width_t) noexcept;
constexpr width_t sat_add(width_t w, std::integral auto i) noexcept;
constexpr width_t sat_add(std::integral auto i, width_t w) noexcept;

constexpr width_t sat_sub(width_t, width_t) noexcept;
constexpr width_t sat_sub(width_t w, std::integral auto i) noexcept;
constexpr width_t sat_sub(std::integral auto i, width_t w) noexcept;

constexpr width_t sat_mul(width_t, width_t) noexcept;
constexpr width_t sat_mul(width_t w, std::integral auto i) noexcept;
constexpr width_t sat_mul(std::integral auto i, width_t w) noexcept;

constexpr /{asterisk} integral type {asterisk}/ compare(width_t, width_t) noexcept;
constexpr /{asterisk} integral type {asterisk}/ compare(width_t w, std::integral auto i) noexcept;
constexpr /{asterisk} integral type {asterisk}/ compare(std::integral auto i, width_t w) noexcept;

} // namespace strf
----

__to-do__

=== `width_t` literal `_w` [[width_literal]]

[source,cpp,subs=normal]
----
namespace strf {
namespace width_literal {

template <char\...C>
constexpr {width_t} operator "" _w()

} // namespace width_literal
} // namespace strf
----
The suffix `_w` can be aplied in floating-points literals in fixed notations as well
as integer literals.

.Example
[source,cpp,subs=normal]
----
using namespace strf::width_literal;

strf::width_t x = 1.5_w;
x += 0.25_w;
x += 1_w;
assert(x == 2.75_w);
----

