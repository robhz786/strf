////
Copyright (C) (See commit logs on github.com/robhz786/strf)
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
////

:strf-revision: develop
:strf-src-root: https://github.com/robhz786/strf/blob/{strf-revision}
:UnaryTypeTrait: link:https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait[UnaryTypeTrait]

:output_buffer:   <<destination_hpp#output_buffer,output_buffer>>
:destination:   <<destination_hpp#destination,destination>>

:PrintableDef:       <<strf_hpp#PrintableDef,PrintableDef>>
:printable_def:      <<strf_hpp#printable_def_of,printable_def>>
:representative_type:   <<strf_hpp#PrintableDef_representative_type,representative_type>>
:forwarded_type:        <<strf_hpp#PrintableDef_forwarded_type,forwarded_type>>
:format_specifiers:     <<strf_hpp#PrintableDef_format_specifiers,format_specifiers>>
:FormatSpecifier:       <<strf_hpp#FormatSpecifier,FormatSpecifier>>
:printable_overrider_c: <<strf_hpp#printable_overrider_c,printable_overrider_c>>
:dont_override:         <<strf_hpp#dont_override,dont_override>>
:premeasurements:       <<strf_hpp#premeasurements,premeasurements>>
:measure:               <<strf_hpp#measure,measure>>
:printable_with_fmt:    <<strf_hpp#printable_with_fmt,printable_with_fmt>>
:make_printer:          <<strf_hpp#make_printer,make_printer>>
:strf_make_printer:     <<strf_hpp#make_printer,strf::make_printer>>

:alignment_format_specifier:   <<strf_hpp#alignment_format_specifier,alignment_format_specifier>>
:alignment_format_specifier_q: <<strf_hpp#alignment_format_specifier,alignment_format_specifier_q>>
:float_format_specifier:       <<strf_hpp#float_format_specifier,float_format_specifier>>
:get_float_format:      <<strf_hpp#float_format_specifier,get_float_format>>
:set_float_format:      <<strf_hpp#float_format_specifier,set_float_format>>
:get_alignment_format:  <<strf_hpp#alignment_format_specifier_fn_false,get_alignment_format>>
:set_alignment_format:  <<strf_hpp#alignment_format_specifier_fn_false,set_alignment_format>>

:join:            <<quick_reference#join,join>>
:Facet:           <<strf_hpp#Facet,Facet>>
:use_facet:       <<strf_hpp#use_facet,use_facet>>
:facets_pack:     <<strf_hpp#facets_pack,facets_pack>>
:tag:             <<strf_hpp#tag,tag>>

:width_calculator_c:     <<strf_hpp#width_calculator_c,width_calculator_c>>
:charset_c:              <<strf_hpp#charset_c,charset_c>>
:dynamic_charset:        <<strf_hpp#dynamic_charset,dynamic_charset>>
:lettercase_c:           <<strf_hpp#lettercase,lettercase_c>>
:lettercase:             <<strf_hpp#lettercase,lettercase>>
:numpunct_c:             <<strf_hpp#numpunct_c,numpunct_c>>
:numpunct:               <<strf_hpp#numpunct,numpunct>>

:multi:           <<quick_reference#multi,multi>>
:transcode:       <<quick_reference#string_formatting,transcode>>
:unsafe_transcode:       <<quick_reference#string_formatting,unsafe_transcode>>
:utf:             <<quick_reference#static_char_constexpr,utf>>

:middle_dots:     &#183;&#183;&#183;
:four_dots:       &#x2025; &#2025;

= Extending Strf to print other types
:source-highlighter: prettify
:icons: font
:toc: left
:toc-title: Adding printable types

== The customization point

For every printable type, there must be a class or struct satisfying the
__{PrintableDef}__ type requirements.

It can be defined as a specialization of the `{printable_def}` struct
template, which is enough to make the library associate it to your
printable type:

[source,cpp,subs=normal]
----
template <>
struct strf::printable_def<your_type>
{ /{asterisk} \... {asterisk}/ };
----

However, if you also want to match the types that derive from
or are implicitly convertible to `your_type`, then you need
overload the `get_printable_def` function like this:

[source,cpp,subs=normal]
----
namespace strf {

strf::printable_def<your_type> get_printable_def(strf::printable_tag, const your_type&);

}
----

In all modern compilers, it's enough to just declate this overload
without any implementation, since the library actually only cares about
the return type, which it obtains with `decltype`.

== How to implement a __{PrintableDef}__ type [[CreatePrintableDef]]

Here is an example for how to make
https://en.cppreference.com/w/cpp/numeric/complex[`std::complex`]
printable:

[source,cpp]
----
namespace strf {

template <typename FloatT>
struct printable_def<std::complex<FloatT>> {
    using representative_type = std::complex<FloatT>;  // <1>
    using forwarded_type = std::complex<FloatT>;       // <2>

    template <typename CharT, typename Pre, typename FPack>
    static auto make_printer
        ( strf::tag<CharT>           // <3>
        , Pre* pre                   // <4>
        , const FPack& fp            // <5>
        , std::complex<FloatT> arg ) // <6>
    {
        auto arg2 =  strf::join
            ( (CharT)'('
            , arg.real()
            , (CharT)',', (CharT)' '
            , arg.imag()
            , (CharT)')' );

        return strf::make_printer<CharT>(pre, fp, arg2);
    }
};

} // namespace strf
----
<1> This is the type that is tested by the __{UnaryTypeTrait}__s that
    parameterize <<tutorial#constrained_facets,constrained facets>>.
    It is usually the printable type itself.
<2> This is the type the library uses in some situations for argument forwarding.
    Also, {join} objects store values of this type, instead of the printable type.
    The printable type must be implicitly convertible to its
    `representative_type`.
    This is usually the printable type itself or a const reference to it.
<3> This parameter is solely there to make `CharT` deducible.
    If you just need or want to support only one character type, like `char`,
    then use instead `strf::tag<char>`, and remove `CharT`
    from the template parameters list.
<4> `Pre` will always be an instance of the `{premeasurements}` class template.
    `pre` will never be null.
<5> `FPack` will always be an instance of the `{facets_pack}` class template.
     `fp` contains the facet objects.
<6> The last parameter is the value to be printed.

What the above code basically does is to tell the library to handle
`std::complex` values in the same way that it would handle the `arg2`
object created above. That's because the expression:

[source,cpp,subs=normal]
----
{strf_make_printer}<CharT>(__pre__, __fp__, __foo__)
----
is equivalent to

// [source,cpp,subs=normal]
// ----
// __overrider__.make_printer({tag}<CharT>{}, __pre__, __fp__, __foo__)
// ----
// , where `__overrider__` is a facet object of the `{printable_overrider_c}` category.
// If it is the default facet, then such expression is equivalent to:

[source,cpp,subs=normal]
----
__foo_type_traits__::make_printer({tag}<CharT>{}, __pre__, __fp__, __foo__)
----
, where `__foo_type_traits__` would be the __{PrintableDef}__ types
corresponding to `__foo__`

( Actually, `{strf_make_printer}` may call something else
if there is a <<howto_override_printable_types#,overriding>>
facet in `__fp__`. But you don't have to thing about this now. )

WARNING: Pay attention to not create dangling references.
This would happen, for instance, if the `join` of the snippet above
contained a pointer to any local variable.
Note that `make_printer` function does not actually print the value,
it just creates and returns an object that is further used to actually
print the value.

////
The `Pre` template parameter is always an instance of the `pre`
value that is an already printable.
////



If we want the parenthesis to not be printed in the polar form,
we can achieve that using the `{multi}` format function.
It causes a character to be printed __n__ times,
where __n__ in our case is either 0 or 1.

[source,cpp,subs=normal]
----
unsigned has_brackets = form != complex_form::polar;
auto arg2 = strf::join
    ( strf::{multi}(static_cast<CharT>('('), has_brackets)
    /{asterisk} \... {asterisk}/
    , strf::{multi}(static_cast<CharT>(')'), has_brackets) );
----

Note that it is not possible to use instead `__if-else__` blocks like this:

[source,cpp,subs=normal]
----
if (form != complex_form::polar) {
    auto j1 = strf::join
            ( static_cast<CharT>('(')
            , v.first
            , strf::{unsafe_transcode}(middle_string(form), strf::{utf}<char16_t>)
            , v.second
            , static_cast<CharT>(')') );
    return strf::make_printer<CharT>(pre, fp, j1);
}
auto j2 = strf::join
    ( v.first
    , strf::{unsafe_transcode}(middle_string(form), strf::{utf}<char16_t>)
    , v.second );
return strf::make_printer<CharT>(pre, fp, j2); // different return type !
----

That wouldn't compile the two return types above would be different.

At last, we need to select a different middle string for each form.
No big deal here, we just created a fuction `middle_string` to handle that.
But what may have caught your eye is that the string is passed to
the `{unsafe_transcode}` function. The code wouldn't compile
without using `{unsafe_transcode}` or `{transcode}`, unless
when `CharT` is the same as the string's character type, and even
in this case, there is the risk of the destination encoding differing
from the one used in the string ( especially if we were using a `char`
string, instead of a `char16_t` string as we did above ).

[source,cpp,subs=normal]
----
auto arg2 = strf::{join}
    ( /{asterisk} \... {asterisk}/
    , /{asterisk} \... {asterisk}/
    , strf::{unsafe_transcode}(middle_string(form), strf::{utf}<char16_t>)
    , /{asterisk} \... {asterisk}/
    , /{asterisk} \... {asterisk}/ );
----

Now you are ready to go:

[source,cpp]
----
void sample()
{
    auto str = strf::to_string(std::complex<double>(3, 4));
    assert(str == "(3, 4)");

    str = strf::to_string.with(complex_form::algebric) (std::complex<double>(3, 4));
    assert(str == "(3 + i*4)");
}
----

== Adding format functions

Format functions are defined in classes that
comply with the __{FormatSpecifier}__ requirements.
If you want to add format functions
you need to create one and/or
select one or some of those provided by the library.
Then, in your __PrintableDef__ class, you need
to define a member `{format_specifiers}` as a type alias
to `{tag}<Fmts\...>`,
where `Fmts\...` are the __{FormatSpecifier}__ types you want
to enable.

The `{alignment_format_specifier}` and the `{float_format_specifier}`
are two _FormatSpecifier_ types that make sense for `std::complex`:
so let's select them:

[source,cpp,subs=normal]
----
namespace strf {

template <typename FloatT>
struct printable_def<std::complex<FloatT>> {
    // ...
    using {format_specifiers} = strf::{tag}<{alignment_format_specifier}, {float_format_specifier}>;
    // ...
};

} // namespace strf
----

After that, whenever a value `x` is a `std::complex`,
expressions like `+strf::fmt(x)` and `*strf::sci(x) > 20` and `right(x, 20, '_').sci()`
are all well-formed, and the type of `strf::fmt(x)` is
`{printable_with_fmt}<printable_def<std::complex<...>>, Fmts\...>`, where `Fmts\...`
are the types you used in to define the `format_specifiers` type alias.

Though well-formed, they are still not printable.
To make them printable,  we need to overload `make_printer`
member function template:

[source,cpp,subs=normal]
----
namespace strf {

template <typename FloatT>
struct printable_def<std::complex<FloatT>> {

    // \...

    template <typename CharT, typename Pre, typename FPack>
    static auto make_printer
        ( strf::tag<CharT>
        , Pre* pre
        , const FPack& fp
        , std::complex<FloatT> arg)
    {
        // handles value without formatting
        // ( same as before )
    }

    template < typename CharT, typename Pre, typename FPack, typename\... T>
    static auto make_printer
        ( strf::tag<CharT>
        , Pre* pre
        , const FPack& fp
        , strf::{printable_with_fmt}<T\...> arg )
    {
        // handles value with formatting

        auto v = arg.value()
        auto arg2 = strf::join
            ( strf::{multi}(static_cast<CharT>('('), has_brackets)
            , strf::fmt(v.real()).{set_float_format}(arg.{get_float_format}())
            , (CharT)',', (CharT)' '
            , strf::fmt(v.imag()).{set_float_format}(arg.{get_float_format}())
            , strf::{multi}(static_cast<CharT>(')'), has_brackets) );
        auto arg3 = arg2.{set_alignment_format}(arg.{get_alignment_format}());
        return strf::make_printer<CharT>(pre, fp, arg3);
    }
};

} // namespace strf
----



Instead of taking a raw `std::complex<Float>`, the new overload takes a
`{printable_with_fmt}<T\...>` which matches the return type of the format functions.
Note that we need to add that template parameter pack because the __FormatSpecifiers__ types
in `{printable_with_fmt}` may change as some format functions are used. For example:
[source,cpp,subs=normal]
----
std::complex<double> x;

auto arg1 = strf::fmt(x);
auto arg2 = strf::fmt(x).sci();
auto arg3 = strf::fmt(x).sci() > 10;

// arg1, arg2 and arg3 have different types:
static_assert(! std::is_same_v(decltype(arg1), decltype(arg2)));
static_assert(! std::is_same_v(decltype(arg2), decltype(arg3)));
----

We can keep the old `make_printer` ( the one that takes `std::complex`
without formatting ), but we could also remove it. Because when the expression
below is not well-formed:
[source,cpp,subs=normal]
----
__PrintableDef__::make_printer({tag}<CharT>{}, pre, fp, x)
----
, and the type of `x` is not an instance `{printable_with_fmt}`, then
the library invokes the following instead:
[source,cpp,subs=normal]
----
__PrintableDef__::make_printer({tag}<CharT>{}, pre, fp, strf::fmt(x))
----

Anyway, let's examine the new function. You can see there are few changes from
the original. The first one is that we need to use `value()` function
to extract the `std::complex` value:

[source,cpp,subs=normal]
----
        auto v = arg**.value()**;
----

Second, we re-apply the floating-point format the each floating-point value:

[source,cpp,subs=normal]
----
        auto arg2 = strf::join
            ( /{asterisk} ... {asterisk}/
            , strf::fmt(v.real()).{set_float_format}(arg.{get_float_format}())
            , /{asterisk} ... {asterisk}/
            , strf::fmt(v.imag()).{set_float_format}(arg.{get_float_format}())
            , /{asterisk} ... {asterisk}/ );
----

Third, we apply the alignment format to the join:

[source,cpp,subs=normal]
----
        auto arg3 = arg2.{set_alignment_format}(arg.{get_alignment_format}());
----

== Creating format functions

But what if you don't want just to enable existing format functions
to your printable type, but also create new ones ?

This means we need to create a __{FormatSpecifier}__ class, which we will name
here as `std_complex_format_specifier`.
It is required to have a member type template named `fn` where
the format functions are defined. The template parameter is
used in the return type of the format functions:

////
So that when the user doesn't specify the form with format function,
the facet is used.

This means we will create a __{FormatSpecifier}__ class,
which in turns is required to have
a member template type named `fn` where the format functions are
defined. A template argument `T` is expected to derive from `fn<T>`
( yes the https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern[
curiously recurring template pattern] ), and is only actually
used to define the return type of the format function.
////

[source,cpp,subs=normal]
----
enum class complex_form { vector, algebric, polar };

struct std_complex_format_specifier {

    template <class T>
    class fn
    {
    public:

        fn() = default;

        template <class U>
        constexpr fn(const fn<U>& u) noexcept
            : form_(u.form())
        {
        }

        // format functions

        constexpr T&& vector() && noexcept
        {
            form_ = complex_form::vector;
            return static_cast<T&&>(*this);
        }
        constexpr T&& algebric() && noexcept
        {
            form_ = complex_form::algebric;
            return static_cast<T&&>(*this);
        }
        constexpr T&& polar() && noexcept
        {
            form_ = complex_form::polar;
            return static_cast<T&&>(*this);
        }

        // observer

        constexpr complex_form get_complex_form() const
        {
            return form_;
        }

    private:

        complex_form form_ = complex_form::from_facet;
    };
};
----

`vector()`, `algebric()` and `polar()` are the format functions we are creating.

The `static_cast` expressions above work because
`fn<T>` is supposed to be a base class of `T`
( yes, it's the https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern[CRTP] ).
Not only that, `T` is expected to be an instance of `{printable_with_fmt}`
that has `std_complex_format_specifier` as one of its template arguments.

Now let's suppose we want the `complex_form` value to
have the following effect on how the numbers are printed:

[caption=,cols="50,50"]
|===
|`complex_form::vector`   | `(3, 4)`
|`complex_form::algebric` | `(3 + i*4)`
|`complex_form::polar`    | `5∠ 0.9272952180016122`
|===


In our __PrintableDef__ class, there are only two modifications:
First, the `format_specifiers` definition:

[source,cpp,subs=normal]
----
template <typename FloatT>
struct printable_def<std::complex<FloatT>> {
    // \...
    using format_specifiers = strf::tag
        < **std_complex_format_specifier**
        , strf::alignment_format_specifier
        , strf::float_format_specifier >;
    // \...
----

And second, the `make_printer` that has the `printable_with_fmt` param:
[source,cpp]
----
namespace strf {

template <typename FloatT>
struct printable_def<std::complex<FloatT>> {

    // ...

    template < typename CharT, typename Pre, typename FPack, typename... T>
    static auto make_printer
        ( strf::tag<CharT>
        , Pre* pre
        , const FPack& fp
        , strf::printable_with_fmt<T...> arg )
    {
        auto form = arg.get_complex_form();
        auto v = complex_coordinates(arg.value(), form);
        unsigned has_brackets = form != complex_form::polar;

         auto arg2 = strf::join
             ( strf::multi(static_cast<CharT>('('), has_brackets)                // <1>
             , strf::fmt(v.first).set_float_format(arg.get_float_format())
             , strf::unsafe_transcode(middle_string(form), strf::utf<char16_t>)  // <2>
             , strf::fmt(v.second).set_float_format(arg.get_float_format())
             , strf::multi(static_cast<CharT>(')'), has_brackets) );
         auto arg3 = arg2.set_alignment_format(arg.get_alignment_format());
         return strf::make_printer<CharT>(pre, fp, arg3);
    }

    private:  // ( some auxiliar functions )

    static std::pair<FloatT, FloatT> complex_coordinates
        ( std::complex<FloatT> x, complex_form form );

    static const char16_t* middle_string(complex_form form);
};

} // namespace strf
----
<1> If we want the parenthesis to not be printed in the polar form,
we can achieve that using the `{multi}` format function.
It causes a character to be printed __n__ times,
where __n__ in our case is either 0 or 1.
<2> The code wouldn't compile
without using `{unsafe_transcode}` or `{transcode}`, unless
when `CharT` is the same as the string's character type, and even
in this case, there is the risk of the destination encoding differing
from the one used in the string ( especially if we were using a `char`
string, instead of a `char16_t` string as we did above ).


[source,cpp]
----
void sample()
{
    std::complex<double> x{3, 4};

    auto str = strf::to_u16string (x, u" == ", strf::sci(x).p(5).polar() );

    assert(str == u"(3 + i*4) == 5.00000e+00∠ 9.27295e-01");
}
----

However, you may find that `std_complex_format_specifier::fn` is incomplete
because we only create format functions that are non-const
and use the `&&` ref-qualifier. Shouldn't we overload them
for the other cases as well ? They would be necessary
in situation like this:

[source,cpp,subs=normal]
----
const auto fmt1 = strf::fmt(std::complex<double>{3, 4});
auto fmt2 = fmt1.polar(); // error: no polar() for const lvalue
fmt2.algebric();          // error: no algebric() for non-const lvalue
----

So, for the sake of completeness, below goes `polar()` overloaded
for both rvalues and lvalues:

[source,cpp,subs=normal]
----
struct std_complex_format_specifier {
    // \...

    template <class T>
    class fn
    {
    public:

        // \...
        constexpr explicit fn(complex_form_fmt f) noexcept
            : form_(f)
        {
        }

        constexpr T&& polar() && noexcept
        {
            // ( same as before )
        }
        constexpr T& polar() & noexcept
        {
            form_ = complex_form_fmt::polar;
            return static_cast<T&>(*this);
        }
        constexpr T polar() const & noexcept
        {
            return T{ static_cast<const T&>(*this)
                    , strf::tag<std_complex_format_specifier> {}
                    , complex_form_fmt::polar };
        }
        // ( vector and algebric are analogous )

        // \...
    };
};
----

Since the const version of `polar()` can't modify the current object,
it instead returns a new one where each base class subobject is initialized
with (copied from) the correponding base class subobject of this object,
except the `std_complex_format_specifier::fn<T>` one,
which is initialized instead with `complex_form_fmt::polar`.
This is why we also need to add that constructor that has
a `complex_form_fmt` parameter. The `printable_with_fmt` constructor
used above is documented <<strf_hpp#printable_with_fmt_vwf2_t_i,here>>.

And its done! I think is a pretty complete example of how to make
`std::complex` printable. You can see the complete implementation
{strf-src-root}/examples/extend_input_std_complex.cpp[here].

== Creating a facet

Instead of creating the previous format functions, we could just
turn the enumeration `complex_form` into a facet. This would just
require some few lines:

[source,cpp,subs=normal]
----
struct complex_form_c {
    static constexpr complex_form get_default() noexcept {
        return complex_form::vector;
    }
};

template <> struct strf::facet_traits<complex_form> {
    using category = complex_form_c;
};
----

Then, instead of calling `get_complex_form()`,
`make_printer` would start with the line:

[source,cpp,subs=normal]
----
complex_form form = strf::{use_facet}<complex_form_c, std::complex<FloatT>>(fp);
----

`use_facet` is used to extract a facet object from a `{facets_pack}` object.
The first template parameter is the facet category.
The second is the usually printable type and it only has effect when there is
any <<tutorial#constrained_facets,constrained facets>> of the given category
in the the `{facets_pack}` object. The effect is that
`{use_facet}` only returns the value inside a constrained facet when
`Filter<Tag>::value` is `true` ,
where `Filter` is the template parameter of the constrained facet, and `Tag`
is the second template parameter used in `{use_facet}`
( which is `std::complex<FloatT>` in this case ).

This way, the complex form would be specified by passing `complex_form`
value as a facet object, instead of calling a format funcion:

[source,cpp]
----
void sample()
{
    str = strf::to_string.with(complex_form::algebric) (std::complex<double>(3, 4));
    assert(str == "(3 + i*4)");
}
----

