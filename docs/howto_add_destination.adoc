////
Copyright (C) (See commit logs on github.com/robhz786/strf)
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
////

:strf-revision: develop
:strf-src-root: https://github.com/robhz786/strf/blob/{strf-revision}

= How to add a new destination
:source-highlighter: prettify
:icons: font

:destination: <<destination_hpp#destination,destination>>
:print_dest: <<destination_hpp#print_dest,print_dest>>
:recycle_buffer: <<destination_hpp#destination_recycle_buffer,recycle_buffer>>
:flush: <<destination_hpp#destination_flush,flush>>
:good: <<destination_hpp#destination_good,good>>
:buffer_ptr: <<destination_hpp#destination_buffer_ptr,buffer_ptr>>
:buffer_space: <<destination_hpp#destination_buffer_space,buffer_space>>
:set_good: <<destination_hpp#destination_set_good,set_good>>
:set_buffer_ptr: <<destination_hpp#destination_set_buffer_ptr,set_buffer_ptr>>
:to: <<quick_reference#to_destination_ref,to>>

:destination_no_reserve: <<strf_hpp#destination_no_reserve,destination_no_reserve>>
:destination_calc_size: <<strf_hpp#destination_calc_size,destination_calc_size>>
:destination_with_given_size: <<strf_hpp#destination_with_given_size,destination_with_given_size>>
:DestinationCreator: <<strf_hpp#DestinationCreator,DestinationCreator>>
:SizedDestinationCreator: <<strf_hpp#SizedDestinationCreator,SizedDestinationCreator>>
:print_dest_space_after_flush: <<destination_hpp#print_dest,print_dest_space_after_flush>>

== The `print_dest` class template

Creating a new output type involves defining a concrete class
that derives from `{print_dest}`.
Having done that, one can write things to objects
of such type with the `{to}` function template,
using the basic usage `<<tutorial#,syntax>>` of the library:

[source,cpp,subs=normal]
----
strf::print_dest</{asterisk}char type{asterisk}/>& dst = /{asterisk}\...{asterisk}/;
strf::<<quick_reference#to_destination_ref,to>>(dst) (/{asterisk} arguments to be printed {asterisk}/);
----

But before learning how to implement such class,
it makes sense to first undestand how one uses the
`{print_dest}` interface, __i.e.__, how to write things
to it.
`print_dest` is a simple class template: it
contains a boolean &#x2014; which indicates whether
the state is "good" or "bad" &#x2014; and two pointers; one of them points
to the end of buffer, and the other to the position where the
next character shall be written. They are returned by the
`<<destination_hpp#destination_buffer_end,buffer_end>>` and
`<<destination_hpp#destination_buffer_ptr,buffer_ptr>>` functions respectively.
Contrary to what is common in output streams abstractions,
where you need to use high-level functions to insert content ( like
https://en.cppreference.com/w/cpp/io/basic_streambuf/sputc[`sputc`]
in `std::basic_streambuf`, or
https://en.cppreference.com/w/cpp/io/basic_ostream/write[`write`]
in `std::basic_ostream` ), in `{print_dest}`, one can write things directly to
its buffer:

[source,cpp,subs=normal]
----
if (dst.{buffer_space}() < 5) {
    dst.recycle_buffer();
}
memcpy(dst.buffer_ptr(), "hello", 5);
dst.advance(5);
----

As demonstrated above, before writting anything to `buffer_ptr()`, one
must check whether there is enough space,
and if not, one must call the `{recycle_buffer}` function
( or `{flush}`, which calls `recycle_buffer` ).
This is the only pure virtual function in `{print_dest}`;
its job is to flush the content written so far and reset the position of
`buffer_ptr()` and `buffer_end()`. After `{recycle_buffer}` is called,
the buffer's space ( `buffer_end() - buffer_ptr()` ) is
guaranteed to be at least `{print_dest_space_after_flush}`
( which is currently `64` but may be greater in future versions ).
This is a postcondition even when the state is "bad".
The state may change from "good" to "bad" in `{recycle_buffer}`,
but never from "bad" to "good".
The "bad" state implies that writting
anything in the range [`buffer_ptr(), buffer_end()`) has no relevent
side effect, though the behaviour is still defined, __i.e.__
the range must be a valid accessible memory area.
Sometimes, `<<destination_hpp#garbage_buff,garbage_buff>>`
is used to handle the bad state.

// This means it's not necessary to always check the state before
// writting anything to `buffer_ptr()`. At worse, it is waste
// of CPU resource.


After writing to `buffer_ptr()`, it is necessary to advance
the buffer pointer, otherwise the content will be overwritten
next time something is written in `buffer_ptr()`.
This is can be done with the
`<<destination_hpp#destination_advance,advance>>`
or the `<<destination_hpp#destination_advance_to,advance_to>>`
member function, as shown above.


Now, let's see how a typical implementation would look like:

[source,cpp,subs=normal]
----
class my_destination: public strf::print_dest<char> {
public:
    my_destination(/{asterisk}\...{asterisk}/)
        : strf::print_dest<char>{buff, sizeof(buff)}
        // \...
    {
        /{asterisk}\...{asterisk}/
    }

    my_destination(const my_destination&) = delete;
    ~my_destination();

    void recycle_buffer() override;
    void finish();

private:
    bool print(const char* str_begin, const char* str_end)
    { /{asterisk}\...{asterisk}/ }

    char buff[strf::{print_dest_space_after_flush}];
};
----

The `print` member function above represents the code
that would send the content to the actual destination,
whatever it is. If `print` never throws, then
`recycle_buffer` could be implemented like below:

[source,cpp,subs=normal]
----
void my_destination::recycle_buffer()
{
    if ({good}()) {
        bool success = print(buff, {buffer_ptr}());
        {set_good}(success);
    }
    {set_buffer_ptr}(buff);
}
----

Otherwise, it makes more sense to do:

[source,cpp,subs=normal]
----
void my_destination::recycle_buffer()
{
    auto ptr = {buffer_ptr}();
    {set_buffer_ptr}(buff);
    if ({good}()) {
        {set_good}(false);
        bool success = print(buff, ptr);
        {set_good}(success);
    }
}
----

You may want to define a destructor that prints
what is left in the buffer. The issue here is that if `print` throws
we must not propagate the exception ( since
https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-dtor-fail[destructors must not throw] ).

[source,cpp,subs=normal]
----
my_destination::~my_destination()
{
    if({good}()) {
        try {
            print(buff, {buffer_ptr}());
        } catch(...)
        {
        } // Need to silence the exception. Not good
    }
}
----

That's why it might be a good idea to create a member function
to do this final flush:

[source,cpp,subs=normal]
----
void my_destination::finish()
{
    bool is_good = {good}();
    {set_good}(false);
    if (is_good) {
        print(buff, ({buffer_ptr}() - buff));
    }
}
----

`finish()` is supposed to be called after all content is written:

[source,cpp,subs=normal]
----
my_destination dst{ /{asterisk}\...{asterisk}/ };

strf::{to}(dst) (/{asterisk}\...{asterisk}/);
strf::{to}(dst) (/{asterisk}\...{asterisk}/);
some_function(dst);
strf::{to}(dst) (/{asterisk}\...{asterisk}/);

dst.finish();
----
Almost
<<quick_reference#destination_types,all classes of this library that derive from `destination`>>
have a `finish` function ( the only exception is
<<destination_hpp#discarded_destination,discarded_destination>>.
So you may want to follow the convention.
Another reason for creating `finish` is that may return a value,
which is something that destructors can't do.


////
`{set_good}` and `{set_buffer_ptr}` are protected member functions.
////

== How to create destination expression

There are <<quick_reference#destinations,several expressions>> that can be used as
the prefix in the `<<tutorial#,basic usage syntax>>`.
Each of them causes the content to be printed into a different destination.
Perhaps you want to create your own. For example, if you use Qt,
you may want to create a `toQString` "destination",
intended to create a `QString` object ( in the same way as
`<<quick_reference#destinations,to_string>>` creates
`std::string` objects ).
This section explain how you can do that.

The first step, which involves most of the work, is
to create a class that derives from `{print_dest}`.
The previous section provides some assistance on that.
Sometimes it makes sense to actually create two of them;
one having a constructor that receives the size
while the other does not, as explained soon.

The second step is to create a class that satisfies the requirements of
__{DestinationCreator}__ or __{SizedDestinationCreator}__ or both.
It acts as a factory ( or something analogous to that ) of the class(es)
you defined in step 1.
_SizedDestinationCreator_ is for the case when the constructor
of your destination class requires the number of characters to be printed
( because it needs to allocate memory or something ).
_DestinationCreator_ is for when it does not need that information.


The third and final step is to define the "destination expression".
It must be an expression ( a function call or a constexpr value )
whose type is an instance of one the class templates below,
having the class created in step 2 as the template parameter.

* `{destination_no_reserve}`: Its template argument must
be _{DestinationCreator}_, and it has the following effect when
writing the arguments ( when its member function `operator()`
or `tr` is called ):
+
[source,cpp,subs=normal]
----
typename your_destination_creator::destination_type dst{creator.create()};
// \... write content in dst \...
return dst.finish();
----
, where:
+
** `your_destination_creator` is the template argument ( and the
type defined in step 2). It must be be _{DestinationCreator}_.
** `creator` is an object of type `your_destination_creator`.

* `{destination_calc_size}`: Its template argument must
be _{SizedDestinationCreator}_, and it has the following effect when
writing the arguments:
+
[source,cpp,subs=normal]
----
std::size_t size = /{asterisk} calculate size \... {asterisk}/;
typename you_destination_creator::sized_destination_type dst{creator.create(**size**)};
// \... write content in dst \...
return dst.finish();
----

* `{destination_with_given_size}`: the factory must be _{SizedDestinationCreator}_,
and it has the same effect as of `destination_calc_size`, except that the
size is not calculated but is instead passed to its
<<strf_hpp#destination_with_given_size_ctor,the constructor>>.
In most cases, it does't make sense to opt for `destination_with_given_size`.
The reason why it was created is to define the return type
the `<<tutorial#,reserve>>` function.

The sample below illustrates the above steps:

[source,cpp,subs=normal]
----
// some type that is able to receive text
class foo { /{asterisk} \... {asterisk}/ };

// step 1: define your destination class
class foo_writer: strf::{print_dest}<char> {
public:
    explicit foo_writer(foo&);
    void recycle_buffer() override;
    auto finish() \-> /{asterisk} \... {asterisk}/;
    //\...
};

// step 2: define the destination creator
class foo_writer_creator {
public:
    using destination_type = foo_writer;
    using char_type = char;

    foo_writer_creator(foo& f): f_(f) {}
    foo_writer_creator(const foo_writer_creator&) = default;

    foo& create() const { return f_; }

private:
    foo& f_;
}

// step3: define the destination expression
auto to(foo& dst) {
    strf::{destination_no_reserve}<foo_writer_creator> x{dst};
    // x contains a member object of type foo_writer_creator
    // initialized with dst
    return x;
}
----

== Examples

* {strf-src-root}/examples/toQString.cpp[examples/toQString.cpp] defines a
  constexpr value named `toQSting`
  that is analogous to `<<quick_reference#destinations,strf::to_string>>`, except that
  it creates a `QString` ( from Qt framework ) instead of a `std::string`.
* {strf-src-root}/examples/appendQString.cpp[examples/appendQString.cpp] defines
  a function `append` used to append content into a `QString` object

