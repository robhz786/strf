////
Copyright (C) (See commit logs on github.com/robhz786/strf)
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
////

:printer:      <<printer,printer>>
:printer_type: <<printer_type,printer_type>>
:printable_traits:  <<printable_traits,printable_traits>>

:preprinting: <<preprinting, preprinting>>
:facets_pack: <<facets_pack, facets_pack>>
:printable_with_fmt: <<printable_with_fmt, printable_with_fmt>>

:PrintableTraits: <<PrintableTraits,PrintableTraits>>
:Printable: <<Printable,Printable>>
:PrinterInput: <<PrinterInput,PrinterInput>>
:printable_traits_of: <<printable_traits_of,printable_traits_of>>
:printable_overrider_c: <<printable_overrider_c,printable_overrider_c>>
:make_default_printer_input: <<make_default_printer_input,make_default_printer_input>>
:make_printer_input: <<make_printer_input,make_printer_input>>
:representative_of_printable: <<representative_of_printable,representative_of_printable>>
:is_printable_and_overridable: <<is_printable_and_overridable,is_printable_and_overridable>>

:width_decumulator: <<width_decumulator,width_decumulator>>
:size_accumulator: <<size_accumulator,size_accumulator>>

:constrain: <<constrain,constrain>>
:constrained_fpe: <<constrained_fpe,constrained_fpe>>
:use_facet: <<use_facet,use_facet>>
:tag: <<tag,tag>>
:rank: <<rank,rank>>
:join: <<join,join>>

== Requirements of printable types

This section provides what one needs to be known to add a new printable type
or override an existing one.

[[Printable]]
=== Type requirement _Printable_

A type `T` is _Printable_ if:

* `printable_traits_of<T>` is defined and is a  _{PrintableTraits}_ type
* `printable_traits_of<T>::<<PrintableTraits_forwarded_type,forwarded_type>>` is implicitly convertible from `T`

[[printable_traits_of]]
=== Type alias template `printable_traits_of`

[source,cpp,subs=normal]
----
namespace strf {

struct printable_tag;

template <typename T> printable_traits;

template <typename T> using printable_traits_of = /{asterisk} see below\... {asterisk}/;

} // namespace strf
----

`printable_traits_of<T>` is:

*  `printable_traits_of<std::remove_cvref<T>>`, if `T` is a reference type or has any cv-qualifier
*  otherwise, it is `Traits`, when `T` is `{printable_with_fmt}<Traits, /{asterisk}\... {asterisk}/>`
*  otherwise, it is `printable_traits<T>` if such template specialization is defined
*  otherwise, it is `decltype(tag_invoke(printable_tag{}, std::declval<T>()))`

[[PrintableTraits]]
=== Type requirement _PrintableTraits_

Given

* `T`, a _PrintableTraits_ type.
* `P`, a _{Printable}_ type such that `{printable_traits_of}<P>` is `T`.

==== Member types
[[PrintableTraits_forwarded_type]]
====
[source,cpp]
----
T::forwarded_type
----
`forwarded_type` must be implicitly convertible from `P`,
and must be copy-constructible. And its copy-constructor should be fast.
( `forwarded_type` is usually `P` or `const P&` )

`forwarded_type` is used intead of `P` as the storage type in some
situations ( for example, the objects created by `fmt` and `{join}` ).
====

[[PrintableTraits_representative_type]]
====
[source,cpp]
----
T::representative_type
----
The type used as the template argument in `{use_facet}`.
This means it is the type that is tested by the
the __UnaryTypeTrait__ template argument passed to
`{constrain}` or `{constrained_fpe}`.
====

[[PrintableTraits_is_overridable]]
====
.( Optional )
[source,cpp]
----
T::is_overridable
----
A type alias to either `std::true_type` or `std::false_type`.
It influences the behavior of `{make_printer_input}`.
Assumed to be `std::false_type` if not defined.
====

[[PrintableTraits_formatters]]
====
.( Optional )
[source,cpp]
----
T::formatters
----
A type alias to `{tag}<F\...>`, where all types in `F\...` satisfy __<<Formatter,Formatter>>__.
It affects the return type of `<<fmt,fmt>>`.
Assumed to be `{tag}<>` if not defined.
====

[[PrintableTraits_functions]]
==== Member static function templates

Given

* `T`, a _PrintableTraits_ type.
* `CharT`, a character type
* `fpack`, a value of type `{facets_pack}</{asterisk}\... {asterisk}/>`
* `pre`, an lvalue of type `{preprinting}</{asterisk}\... {asterisk}/>`
* `v`, a value of type `T::forwarded_type` or `{printable_with_fmt}<T, F\...>`,
   where `F\...` is such that `T::formatters` is an alias to `{tag}<F\...>`.

The following syntax is satisfied:
====
[source,cpp,subs=normal]
----
T::make_input({tag}<CharT>{}, pre, fpack, v)
----
[horizontal]
Return type:: A _{PrinterInput}_ type.
Return value:: A value `r` such that `&r.pre == &pre`
====

=== Type alias template `representative_of_printable` [[representative_of_printable]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename T>
using representative_of_printable = typename {printable_traits_of}<T>::<<PrintableTraits_representative_type,representative_type>>;

} // namespace strf
----

=== Variable template `is_printable_and_overridable` [[is_printable_and_overridable]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename T>
using is_printable_and_overridable = ... /{asterisk}see below{asterisk}/;

template <typename T>
constexpr bool is_printable_and_overridable_v = is_printable_and_overridable<T>::value;

} // namespace strf
----

`is_printable_and_overridable<T>` is an alias to
`{printable_traits_of}<T>::<<PrintableTraits_is_overridable,is_overridable>>`
if such type is defined, otherwise it is an alias to `std::false_type`.

=== Type alias template `forwarded_printable_type` [[forwarded_printable_type]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename T>
using forwarded_printable_type = typename {printable_traits_of}<T>::<<PrintableTraits_forwarded_type,forwarded_type>>;

} // namespace strf
----


=== Type requirements _PrinterInput_ [[PrinterInput]]

Given

* `CharT`, a character type
* `PrePriting`, an instance of the `{preprinting}` class template
* `X`, a _PrinterInput_ type for types `CharT` and `PrePriting`
* `x`, a value of type `X`

====
[source,cpp,subs=normal]
----
T::char_type
----
A type alias to `CharT`.
====

====
[source,cpp,subs=normal]
----
T::preprinting_type
----
A type alias to `PrePriting`.
====

====
[source,cpp,subs=normal]
----
T::printer_type
----
A type that is constructible from `X` and convertible to `const {printer}<CharT>&`,
such that the sequence:

[source,cpp,subs=normal]
----
auto size_before = x.pre.<<size_accumulator_accumulated_ssize,accumulated_ssize>>();
typename T::printer_type p{x};
auto size_after = x.pre.<<size_accumulator_accumulated_ssize,accumulated_ssize>>();
auto predicted_size = size_after - size_before;
auto dest_buff_space = dest.<<destination_hpp#output_buffer_buffer_space,buffer_space>>();

static_cast<const printer<CharT>&>(p).<<printer,print_to>>(dest);
----
statisfies the following postconditions when `PrePriting::<<preprinting,size_required>>` is `true`:

*  if `predicted_size \<= dest_buff_space` is `true`, then `dest.recycle()` is not called in `print_to`
====

====
[source,cpp,subs=normal]
----
x.pre
----
A lvalue reference of type `PrePriting`.
====

=== Class template `usual_printer_input` [[usual_printer_input]]

`usual_printer_input` is a syntactic sugar to create `PrinterInput` types.

[source,cpp,subs=normal]
----
template <typename CharT, typename PrePriting, typename FPack, typename Arg, typename Printer>
struct usual_printer_input
{
    using char_type = CharT;
    using arg_type = Arg;
    using preprinting_type = PrePriting;
    using fpack_type = FPack;
    using printer_type = Printer;

    preprinting_type& pre;
    FPack facets;
    Arg arg;
};
----
////
Compile-time requirements::
* `PrePriting` is an instance of the `{preprinting}` class template.
////

=== Function template `make_default_printer_input` [[make_default_printer_input]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT, typename Pre, typename FPack, typename Arg>
constexpr auto make_default_printer_input
    ( Pre& pre, const FPack& facets, const Arg& arg)
    noexcept(/{asterisk} see below\... {asterisk}/)
    \-> /{asterisk} see below\... {asterisk}/

} // namespace strf
----

The expression `make_default_printer_input<CharT>(pre, facets, arg)` is equivalent to
[source,cpp,subs=normal]
----
{printable_traits_of}<Arg>::<<PrintableTraits_functions,make_input>>({tag}<CharT>{}, pre, facets, arg);
----

=== Facet category `printable_overrider_c` [[printable_overrider_c]]

This facet category affects the return type and value of `strf::{make_printer_input}`
function template.
It enables the user change how a printable type is printed,
by making the library use an the alternative __{PrinterInput}__ object.
A facet of this category should **aways** be <<constrain,constrained>> to the
printable type intended to be overriden.

[source,cpp,subs=normal]
----
namespace strf {

struct printable_overrider_c {
    static constexpr bool constrainable = true;

    constexpr static <<dont_override,dont_override>> get_default() noexcept {
        return {};
    }
};

} // namespace strf
----

==== Struct `dont_override` [[dont_override]]

`dont_override` is the default facet of `printable_overrider_c` category.

[source,cpp,subs=normal]
----
namespace strf {

struct dont_override {
    using category = printable_overrider_c;

    template <typename CharT, typename Pre, typename FPack, typename Arg>
    constexpr static auto make_input
        ( {tag}<CharT>{}, Pre& pre, const FPack& facets, Arg&& arg )
        noexcept(noexcept({make_default_printer_input}<CharT>(pre, facets, arg)))
    {
        return {make_default_printer_input}<CharT>(pre, facets, arg);
    }
};

} // namespace strf
----

=== Function template `make_printer_input` [[make_printer_input]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT, typename Pre, typename FPack, typename Arg>
constexpr /{asterisk}\...{asterisk}/ make_printer_input(Pre* pre, const FPack& facets, const Arg& arg);

} // namespace strf
----

If `{printable_traits_of}<Arg>::<<PrintableTraits_is_overridable,is_overridable>>::value` is `true`,
`make_printer_input` returns
[source,cpp,subs=normal]
----
{use_facet}< {printable_overrider_c}, {representative_of_printable}<Arg> > (facets)
    .make_input({tag}<CharT>{}, pre, facets, arg);
----

Otherwise, it returns

[source,cpp,subs=normal]
----
{printable_traits_of}<Arg>::make_input({tag}<CharT>{}, pre, facets, arg)
----


=== Type alias template `printer_type` [[printer_type]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT, typename Pre, typename FPack, typename Arg>
using printer_input_type = decltype
    ( {make_printer_input}<CharT>
        ( std::declval<Pre*>()
        , std::declval<const FPack&>()
        , std::declval<Arg>() ) );

template <typename CharT, typename Pre, typename FPack, typename Arg>
using printer_type = typename printer_input_type<CharT, Pre, FPack, Arg>::printer_type;

} // namespace strf
----

[[printer]]
=== Class template `printer`

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT>
class printer {
public:
    using char_type = CharT;
    virtual ~printer() {}
    virtual void print_to({destination}<CharT>&) const = 0;
};

} // namespace strf
----

=== Class template `preprinting` [[preprinting]]

[source,cpp,subs=normal]
----
namespace strf {

enum class precalc_width: bool { no = false, yes = true };
enum class precalc_size : bool { no = false, yes = true };

template <precalc_size PrecalcSize, precalc_width PrecalcWidth>
class preprinting
    : public {size_accumulator}<static_cast<bool>(PrecalcSize)>
    , public {width_decumulator}<static_cast<bool>(PrecalcWidth)>
{
public:

    static constexpr bool size_required = static_cast<bool>(PrecalcSize);
    static constexpr bool width_required = static_cast<bool>(PrecalcWidth);
    static constexpr bool nothing_required = ! size_required && ! width_required;
    static constexpr bool something_required = size_required || width_required;

    constexpr preprinting() noexcept = default;
    constexpr explicit preprinting(<<width_t,width_t>> initial_width) noexcept;

    preprinting(const preprinting&) = delete;
    preprinting(preprinting&&) = delete;
    preprinting& operator=(const preprinting&) = delete;
    preprinting& operator=(preprinting&&) = delete;

    ~preprinting() = default;
};

} // namespace strf
----
==== Constructors
====
[source,cpp,subs=normal]
----
constexpr preprinting() noexcept;
----
[horizontal]
Effect:: Default-construct each of the base classes.
====
====
[source,cpp,subs=normal]
----
constexpr explicit preprinting(<<width_t,width_t>> initial_width) noexcept;
----
Compile-time requirement:: `PrecalcWidth` is `precalc_width::yes`, otherwise this constructor
does not participate in overload resolution.
Effect:: Initializes `{width_decumulator}` base
with `initial_width`.
====
[[size_accumulator]]
=== Class template `size_accumulator`
[source,cpp,subs=normal]
----
namespace strf {
template <bool Active>
class size_accumulator
{
public:
    explicit constexpr size_accumulator() noexcept;
    explicit constexpr size_accumulator(std::integral auto initial_size) noexcept;

    size_accumulator(const size_accumulator&) = delete;
    size_accumulator(size_accumulator&&) = delete;
    size_accumulator& operator=(const size_accumulator&) = delete;
    size_accumulator& operator=(size_accumulator&&) = delete;

    constexpr void add_size(std::integral auto initial_size) noexcept;

    constexpr std::ptrdiff_t accumulated_ssize() const noexcept;
    constexpr std::size_t accumulated_usize() const noexcept;
};
} // namespace strf
----

==== Member functions
====
[source,cpp]
----
explicit constexpr size_accumulator() noexcept;
----
Postcondition:: `accumulated_ssize() == 0`
====
====
[source,cpp]
----
explicit constexpr size_accumulator(std::integral auto initial_size) noexcept;
----
Compile-time requirement:: `Active` is `true`, otherwise this constructor
does not participate in overload resolution.
Postcondition:: `accumulated_ssize() == initial_size >= 0 ? initial_size : 0`
====
[[size_accumulator_add_size]]
====
[source,cpp]
----
constexpr void add_size(std::integral auto s) noexcept;
----
Effects::
When `Active` is `false`::: None
When `Active` is `true` ::: The internally stored size value ( that is returned by `accumulated_ssize()` ) is incremented by the value `(s >= 0 ? s : 0)`.
====

[[size_accumulator_accumulated_usize]]
====
[source,cpp]
----
constexpr std::size_t accumulated_usize() const noexcept;
----
When `Active` is `false`::: `0`
When `Active` is `true` ::: The internally stored size value.
====

[[size_accumulator_accumulated_ssize]]
====
[source,cpp]
----
constexpr std::ptrdiff_t accumulated_ssize() const noexcept;
----
Return value:: static_cast<std::ptrdiff_t>(accumulated_usize())
====


[[width_decumulator]]
=== Class template `width_decumulator`

[source,cpp,subs=normal]
----
namespace strf {
template <bool Active>
class width_decumulator
{
public:
    constexpr width_decumulator() noexcept;

    width_decumulator(const width_decumulator&) = delete;
    width_decumulator(width_decumulator&&) = delete;
    width_decumulator& operator=(const width_decumulator&) = delete;
    width_decumulator& operator=(width_decumulator&&) = delete;

    constexpr explicit width_decumulator(<<width_t,width_t>> initial_width) noexcept;

    constexpr void subtract_width(<<width_t,width_t>>) noexcept;

    constexpr reset_remaining_width(width_t w) noexcept;

    constexpr <<width_t,width_t>> remaining_width() const noexcept;

    constexpr bool has_remaining_width() const noexcept;

    constexpr void zeroize_remaining_width_if_negative() noexcept;

private:
    <<width_t,width_t>> width_; // exposition-only
}
} // namespace strf
----

==== Member functions


====
[source,cpp,subs=normal]
----
constexpr explicit width_decumulator(<<width_t,width_t>> initial_width) noexcept;
----
Compile-time requiment:: `Active` is `true`, otherwise this constructor
does not participate in overload resolution.
Postcondition:: `remaining_width() == initial_width > 0 ? initial_width : 0`
====

====
[source,cpp]
----
constexpr width_decumulator() noexcept;
----
Postcondition:: `remaining_width() == (Active ? <<width_t,width_max>> : 0)`
====

====
[source,cpp,subs=normal]
----
constexpr width_t remaining_width() noexcept;
----
Effect:: calls `zeroize_remaining_width_if_negative()`
Return value:: `width_ > 0 ? width_ : 0`
====

====
[source,cpp,subs=normal]
----
constexpr bool has_remaining_width() noexcept;
----
Effect:: calls `zeroize_remaining_width_if_negative()`
Return value:: `width_ > 0`
====


====
[source,cpp,subs=normal]
----
constexpr void subtract_width(<<width_t,width_t>> w) noexcept;
----
Effect::
None if `Active` is `false`, otherwise does `width_ -= w`
====

====
[source,cpp,subs=normal]
----
constexpr reset_remaining_width(width_t w) noexcept;
----
Compile-time requiment:: `Active` is `true`, otherwise this function
does not participate in overload resolution.
Effect: `width_ = w`;
====

====
[source,cpp,subs=normal]
----
constexpr zeroize_remaining_width_if_negative() noexcept;
----
Effect:: `width_ = 0`
Postcondition:: `remaining_width() == 0`
Note:: Calling `subtract_width(w)` has undefined behavior if `w` is greater than
`(width_ - <<width_t,width_min>>)`.
So calling `zeroize_remaining_width_if_negative` aims to reduce the chances of that to happen.


====


=== Function template `precalculate` [[precalculate]]

[source,cpp,subs=normal]
----
template < typename CharT
         , <<preprinting,precalc_size>> PrecalcSize
         , <<preprinting,precalc_width>> PrecalcWidth
         , typename\... FPE
         , typename\... Args >
void precalculate
    ( {preprinting}<PrecalcSize, PrecalcWidth>* pp
    , const {facets_pack}<FPE\...>& facets
    , const Args&\... args );
----

Calculates the size and/or width of the result of printing the arguments `args\...`

Compile-time requirements::
* All types in `Args\...` are __{Printable}__
* All types in `FPE\...` are __<<FacetsPackElement,FacetsPackElement>>__
  ( since this is a requirement of `{facets_pack}` ).

Effects::
* When `PrecalcSize` is `precalc_size::yes`, for each argument `arg` in `args\...`
  instantiates the correponding `printer` type with `pp`, `facets`, and `arg`.
  This translates into the following
  https://en.cppreference.com/w/cpp/language/fold[fold expression]:
+
[source,cpp,subs=normal]
----
(\..., {printer_type}< CharT
                  , {preprinting}<PrecalcSize, PrecalcWidth>
                  , facets_pack<FPE\...>
                  , Args >  {{make_printer_input}<CharT>(pp, facets, args)} );
----
* When `PrecalcSize` is `precalc_size::no` and `PrecalcWidth` is `precalc_width::yes`,
  for each argument `arg` in `args\...` instantiates the correponding `printer`
  type with `pp`, `facets`, and `arg` ( again, using `{printer_type}`  and
  `{make_printer_input}` ), while `pp-><<width_decumulator,remaining_width>>() > 0`
  is `true`.
  This implies that not necessarily all argument in `arg\...` are used.
* When `PrecalcSize` is `precalc_size::no` and `PrecalcWidth` is `precalc_width::no`,
  does nothing

