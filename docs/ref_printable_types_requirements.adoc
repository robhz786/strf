////
Copyright (C) (See commit logs on github.com/robhz786/strf)
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
////

:printer_type: <<printer_type,printer_type>>
:printable_traits:  <<printable_traits,printable_traits>>

:premeasurements: <<premeasurements, premeasurements>>
:facets_pack: <<facets_pack, facets_pack>>
:printable_with_fmt: <<printable_with_fmt, printable_with_fmt>>

:Printer:      <<Printer,Printer>>
:PrintableTraits: <<PrintableTraits,PrintableTraits>>
:Printable: <<Printable,Printable>>
:PrinterInput: <<PrinterInput,PrinterInput>>
:printable_traits_of: <<printable_traits_of,printable_traits_of>>
:printable_overrider_c: <<printable_overrider_c,printable_overrider_c>>
:make_default_printer: <<make_default_printer,make_default_printer>>
:make_printer: <<make_printer,make_printer>>
:representative_of_printable: <<representative_of_printable,representative_of_printable>>
:is_printable_and_overridable: <<is_printable_and_overridable,is_printable_and_overridable>>

:width_accumulator: <<width_accumulator,width_accumulator>>
:size_accumulator: <<size_accumulator,size_accumulator>>

:constrain: <<constrain,constrain>>
:constrained_fpe: <<constrained_fpe,constrained_fpe>>
:use_facet: <<use_facet,use_facet>>
:tag: <<tag,tag>>
:rank: <<rank,rank>>
:join: <<join,join>>

== Requirements of printable types

This section provides what one needs to be known to add a new printable type
or override an existing one.

[[Printable]]
=== Type requirement _Printable_

A type `T` is _Printable_ if:

* `printable_traits_of<T>` is defined and is a  _{PrintableTraits}_ type
* `printable_traits_of<T>::<<PrintableTraits_forwarded_type,forwarded_type>>` is implicitly convertible from `T`

[[printable_traits_of]]
=== Type alias template `printable_traits_of`

[source,cpp,subs=normal]
----
namespace strf {

struct printable_tag;

template <typename T> struct printable_traits;

template <typename T> using printable_traits_of = /{asterisk} see below\... {asterisk}/;

} // namespace strf
----

`printable_traits_of<T>` is:

*  `printable_traits_of<std::remove_cvref<T>>`, if `T` is a reference type or has any cv-qualifier
*  otherwise, it is `Traits`, when `T` is `{printable_with_fmt}<Traits, /{asterisk}\... {asterisk}/>`
*  otherwise, it is `printable_traits<T>` if such template specialization is defined
*  otherwise, it is `decltype(tag_invoke(printable_tag{}, std::declval<T>()))`

[[PrintableTraits]]
=== Type requirement _PrintableTraits_

Given

* `T`, a _PrintableTraits_ type.
* `P`, a _{Printable}_ type such that `{printable_traits_of}<P>` is `T`.

==== Member types
[[PrintableTraits_forwarded_type]]
====
[source,cpp]
----
T::forwarded_type
----
`forwarded_type` must be implicitly convertible from `P`,
and must be copy-constructible. And its copy-constructor should be fast.
( `forwarded_type` is usually `P` or `const P&` )

`forwarded_type` is used intead of `P` as the storage type in some
situations ( for example, the objects created by `fmt` and `{join}` ).
====

[[PrintableTraits_representative_type]]
====
[source,cpp]
----
T::representative_type
----
The type used as the template argument in `{use_facet}`.
This means it is the type that is tested by the
the __UnaryTypeTrait__ template argument passed to
`{constrain}` or `{constrained_fpe}`.
====

[[PrintableTraits_is_overridable]]
====
.( Optional )
[source,cpp]
----
T::is_overridable
----
A type alias to either `std::true_type` or `std::false_type`.
It influences the behavior of `{make_printer}`.
Assumed to be `std::false_type` if not defined.
====

[[PrintableTraits_formatters]]
====
.( Optional )
[source,cpp]
----
T::formatters
----
A type alias to `{tag}<F\...>`, where all types in `F\...` satisfy __<<Formatter,Formatter>>__.
It affects the return type of `<<fmt,fmt>>`.
Assumed to be `{tag}<>` if not defined.
====

[[PrintableTraits_functions]]
==== Member static function templates

Given

* `T`, a _PrintableTraits_ type.
* `CharT`, a character type
* `fpack`, a value of type `{facets_pack}</{asterisk}\... {asterisk}/>`
* `pre`, a value of type `{premeasurements}</{asterisk}\... {asterisk}/>`
* `dst`, an non-const lvalue of type `{destination}<CharT>&`
* `v`, a value of type `T::forwarded_type` or `{printable_with_fmt}<T, F\...>`,
   where `F\...` is such that `T::formatters` is an alias to `{tag}<F\...>`.
* `R`, the return type of `T::make_printer({tag}<CharT>{}, pre, fpack, v)`
* `PrinterT`, the same type as `R`, if `R` is _{Printer}_, or `R::printer_type` otherwise

The following must be satisfied:

* `R` is either _{Printer}_ or _{PrinterInput}_.
* At least one of the function templates below must be defined:

====
.( Optional )
[source,cpp,subs=normal]
----
T::print(dst, fpack, v);
----
[horizontal]
Return Type:: void
Effect:: Prints the content to `dst`
====

====
.( Optional )
[source,cpp,subs=normal]
----
PrinterT p{ T::make_printer({tag}<CharT>{}, pre, fpack, v) };
----
The `make_printer` function has two purposes: to create (or enable the creation of) a
__{Printer}__ object `p`, and, before that, to measure the size and/or width
(if required) of the content to be written by `p.write_to(dst)`.

`pre` acts as an output variable:
If `pre.<<premeasurements,width_demanded>>` is `true`, then the width of such content
`v` shall be added to the <<width_accumulator,remaining_width>> of `pre`.

If `pre.<<premeasurements,size_demanded>>` is `true`, then the size of such content
( or a value greater than that ) shall be added into the
<<size_accumulator,accumulated_size>> of `pre`.

The calculated size must be such that to ensure that
`p.write_to(dst)` does not call `dst.recycle()`,
if the value of `dst.space()` ( immediately before calling `p.write_to(dst)` )
is greater than or equal to such calculated size.
====

=== Type alias template `representative_of_printable` [[representative_of_printable]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename T>
using representative_of_printable = typename {printable_traits_of}<T>::<<PrintableTraits_representative_type,representative_type>>;

} // namespace strf
----

=== Variable template `is_printable_and_overridable` [[is_printable_and_overridable]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename T>
using is_printable_and_overridable = ... /{asterisk}see below{asterisk}/;

template <typename T>
constexpr bool is_printable_and_overridable_v = is_printable_and_overridable<T>::value;

} // namespace strf
----

`is_printable_and_overridable<T>` is an alias to
`{printable_traits_of}<T>::<<PrintableTraits_is_overridable,is_overridable>>`
if such type is defined, otherwise it is an alias to `std::false_type`.

=== Type alias template `forwarded_printable_type` [[forwarded_printable_type]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename T>
using forwarded_printable_type = typename {printable_traits_of}<T>::<<PrintableTraits_forwarded_type,forwarded_type>>;

} // namespace strf
----

=== Type requirements _Printer_ [[Printer]]

Given

* `CharT`, a character type
* `X`, a _Printer_ type for type `CharT`
* `x`, a const lvalue of type `X`
* `dst`, an non-const lvalue of type `{destination}<CharT>`

The following expression must be well-formed:

[source,cpp,subs=normal]
----
x(dst);
----

=== Type requirements _PrinterInput_ [[PrinterInput]]

Given

* `CharT`, a character type
* `PreMeasurements`, an instance of the `{premeasurements}` class template
* `X`, a _PrinterInput_ type for types `CharT` and `PreMeasurements`
* `x`, a value of type `X`

====
[source,cpp,subs=normal]
----
X::char_type
----
A type alias to `CharT`.
====

====
[source,cpp,subs=normal]
----
X::premeasurements_type
----
A type alias to `PreMeasurements`.
====

====
[source,cpp,subs=normal]
----
X::printer_type
----
A __{Printer}__ type that is constructible from `X`
====

====
[source,cpp,subs=normal]
----
x.pre
----
A lvalue reference of type `PreMeasurements`.
====

=== Class template `usual_printer_input` [[usual_printer_input]]

`usual_printer_input` is a syntactic sugar to create `PrinterInput` types.

[source,cpp,subs=normal]
----
template < typename CharT, typename PreMeasurements
         , typename FPack, typename Arg, typename Printer>
struct usual_printer_input
{
    using char_type = CharT;
    using arg_type = Arg;
    using premeasurements_type = PreMeasurements;
    using fpack_type = FPack;
    using printer_type = Printer;

    premeasurements_type& pre;
    FPack facets;
    Arg arg;
};
----
////
Compile-time requirements::
* `PreMeasurements` is an instance of the `{premeasurements}` class template.
////

=== Function template `make_default_printer` [[make_default_printer]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT, typename Pre, typename FPack, typename Arg>
constexpr auto make_default_printer
    ( Pre& pre, const FPack& facets, const Arg& arg)
    noexcept(/{asterisk} see below\... {asterisk}/)
    \-> /{asterisk} see below\... {asterisk}/

} // namespace strf
----

The expression `make_default_printer<CharT>(pre, facets, arg)` is equivalent to
[source,cpp,subs=normal]
----
{printable_traits_of}<Arg>::<<PrintableTraits_functions,make_printer>>({tag}<CharT>{}, pre, facets, arg);
----

=== Facet category `printable_overrider_c` [[printable_overrider_c]]

A facet of this category must have a `make_printer` member function template
that satisfy the same syntax and semantics as of
`<<PrintableTraits_functions,__PrintableTraits__::make_printer>>`, except that
it doesn't need to static (though it must then be const ).

The purpose of this facet is to cause `strf::{make_printer}`
to forward the call to its `make_printer`, instead of the `make_printer`
defined in the __PrintableTraits__ ( which is the default ).
In order words, it enables the user to override the implementation
that prints a printable type.

A facet of this category should **aways** be <<constrain,constrained>> to the
printable type intended to be overriden.

[source,cpp,subs=normal]
----
namespace strf {

struct printable_overrider_c {
    static constexpr bool constrainable = true;

    constexpr static <<dont_override,dont_override>> get_default() noexcept {
        return {};
    }
};

} // namespace strf
----

==== Struct `dont_override` [[dont_override]]

`dont_override` is the default facet of `printable_overrider_c` category.

[source,cpp,subs=normal]
----
namespace strf {

struct dont_override {
    using category = printable_overrider_c;

    template <typename CharT, typename Pre, typename FPack, typename Arg>
    constexpr static auto make_printer
        ( {tag}<CharT>{}, Pre& pre, const FPack& facets, Arg&& arg )
        noexcept(noexcept({make_default_printer}<CharT>(pre, facets, arg)))
    {
        return {make_default_printer}<CharT>(pre, facets, arg);
    }
};

} // namespace strf
----

=== Function template `make_printer` [[make_printer]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT, typename Pre, typename FPack, typename Arg>
constexpr /{asterisk}\...{asterisk}/ make_printer(Pre* pre, const FPack& facets, const Arg& arg);

} // namespace strf
----

If `{printable_traits_of}<Arg>::<<PrintableTraits_is_overridable,is_overridable>>::value` is `true`,
`make_printer` returns
[source,cpp,subs=normal]
----
{use_facet}< {printable_overrider_c}, {representative_of_printable}<Arg> > (facets)
    .make_printer({tag}<CharT>{}, pre, facets, arg);
----

Otherwise, it returns

[source,cpp,subs=normal]
----
{printable_traits_of}<Arg>::make_printer({tag}<CharT>{}, pre, facets, arg)
----


=== Type alias template `printer_type` [[printer_type]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT, typename Pre, typename FPack, typename Arg>
using printer_input_type = decltype
    ( {make_printer}<CharT>
        ( std::declval<Pre*>()
        , std::declval<const FPack&>()
        , std::declval<Arg>() ) );

template <typename CharT, typename Pre, typename FPack, typename Arg>
using printer_type = typename printer_input_type<CharT, Pre, FPack, Arg>::printer_type;

} // namespace strf
----

=== Class template `premeasurements` [[premeasurements]]

[source,cpp,subs=normal]
----
namespace strf {

enum class width_presence: bool { no = false, yes = true };
enum class size_presence : bool { no = false, yes = true };

template <size_presence SizePresence, width_presence WidthPresence>
class premeasurements
    : public {size_accumulator}<static_cast<bool>(SizePresence)>
    , public {width_accumulator}<static_cast<bool>(WidthPresence)>
{
public:

    static constexpr bool size_demanded = static_cast<bool>(SizePresence);
    static constexpr bool width_demanded = static_cast<bool>(WidthPresence);
    static constexpr bool no_demands  = ! size_demanded && ! width_demanded;    
    static constexpr bool something_demanded = size_demanded || width_demanded;
    static constexpr bool size_and_width_demanded = size_demanded && width_demanded;

    constexpr premeasurements() noexcept = default;
    constexpr explicit premeasurements(<<width_t,width_t>> initial_width) noexcept;

    ~premeasurements() = default;
};

} // namespace strf
----
==== Constructors
====
[source,cpp,subs=normal]
----
constexpr premeasurements() noexcept;
----
[horizontal]
Effect:: Default-construct each of the base classes.
====
====
[source,cpp,subs=normal]
----
constexpr explicit premeasurements(<<width_t,width_t>> width_limit) noexcept;
----
Compile-time requirement:: `WidthPresence` is `width_presence::yes`, otherwise this constructor
does not participate in overload resolution.
Effect:: Initializes `{width_accumulator}` base
with `width_limit`.
====
[[size_accumulator]]
=== Class template `size_accumulator`
[source,cpp,subs=normal]
----
namespace strf {
template <bool Active>
class size_accumulator
{
public:
    explicit constexpr size_accumulator() noexcept;
    explicit constexpr size_accumulator(std::integral auto initial_size) noexcept;

    constexpr void add_size(std::integral auto s) noexcept;

    constexpr std::ptrdiff_t accumulated_ssize() const noexcept;
    constexpr std::size_t accumulated_usize() const noexcept;
};
} // namespace strf
----

==== Member functions
====
[source,cpp]
----
explicit constexpr size_accumulator() noexcept;
----
Postcondition:: `accumulated_ssize() == 0`
====
====
[source,cpp]
----
explicit constexpr size_accumulator(std::integral auto initial_size) noexcept;
----
Compile-time requirement:: `Active` is `true`, otherwise this constructor
does not participate in overload resolution.
Postcondition:: `accumulated_ssize() == initial_size >= 0 ? initial_size : 0`
====
[[size_accumulator_add_size]]
====
[source,cpp]
----
constexpr void add_size(std::integral auto s) noexcept;
----
Effects::
When `Active` is `false`::: None
When `Active` is `true` ::: The internally stored size value ( that is returned by `accumulated_ssize()` ) is incremented by the value `(s >= 0 ? s : 0)`.
====

[[size_accumulator_accumulated_usize]]
====
[source,cpp]
----
constexpr std::size_t accumulated_usize() const noexcept;
----
When `Active` is `false`::: `0`
When `Active` is `true` ::: The internally stored size value.
====

[[size_accumulator_accumulated_ssize]]
====
[source,cpp]
----
constexpr std::ptrdiff_t accumulated_ssize() const noexcept;
----
Return value:: `static_cast<std::ptrdiff_t>(accumulated_usize())`
====


[[width_accumulator]]
=== Class template `width_accumulator`

[source,cpp,subs=normal]
----
namespace strf {
template <bool Active>
class width_accumulator
{
public:
    constexpr width_accumulator() noexcept;

    constexpr explicit width_accumulator(<<width_t,width_t>> width_limit) noexcept;

    constexpr void add_width(<<width_t,width_t>>) noexcept;

    constexpr void checked_add_width(<<width_t,width_t>>) noexcept;

    constexpr <<width_t,width_t>> accumlated_width() const noexcept;

    constexpr <<width_t,width_t>> remaining_width() const noexcept;

    constexpr bool has_remaining_width() const noexcept;

    constexpr bool remaining_width_greater_than(width_t w) const noexcept

    constexpr saturate_width(width_t w) noexcept;

private:
    width_t limit_ = width_max; // exposition-only
    width_t width_ = 0;         // exposition-only
}
} // namespace strf
----

==== Member functions


====
[source,cpp,subs=normal]
----
constexpr explicit width_accumulator(<<width_t,width_t>> width_limit) noexcept;
----
Compile-time requiment:: `Active` is `true`, otherwise this constructor
does not participate in overload resolution.
Postcondition:: `remaining_width() == width_limit > 0 ? width_limit : 0`
====


====
[source,cpp]
----
constexpr width_accumulator() noexcept;
----
Postcondition:: `remaining_width() == (Active ? <<width_t,width_max>> : 0)`
====

====
[source,cpp,subs=normal]
----
constexpr void  checked_add_width(<<width_t,width_t>> w) noexcept;
----
Effect::
None if `Active` is `false`, otherwise does
+
[source,cpp]
----
if (w > 0 && width_ < limit_) {
    width_ = ( w >= limit_ - width_
             ? limit_
             : width_ + w );
}
----

====

====
[source,cpp,subs=normal]
----
constexpr void add_width(<<width_t,width_t>> w) noexcept;
----
Effect::
None if `Active` is `false`, otherwise does `width_ += w`
====


====
[source,cpp,subs=normal]
----
constexpr width_t accumulated_width() noexcept;
----
Return value:: `Active ? (width_ <= limit_ ? width_ : limit_) : 0`
====

====
[source,cpp,subs=normal]
----
constexpr width_t remaining_width() noexcept;
----
Return value:: `Active ? (width_ < limit_ ? limit_ - width_ : 0) : 0`
====

====
[source,cpp,subs=normal]
----
constexpr bool has_remaining_width() noexcept;
----
Return value:: `Active && width_ < limit_`
====

====
[source,cpp,subs=normal]
----
constexpr bool remaining_width_greater_than(strf::width_t w) const noexcept
----
Return value:: `Active && width_ + w < limit_`
====


====
[source,cpp,subs=normal]
----
constexpr saturate_width(width_t w) noexcept;
----
Effect: None if `Active` is `false`, otherwise do `width_ = limit_`
Postcondition:: `remaining_width() == 0` 
====


=== Function template `measure` [[measure]]

[source,cpp,subs=normal]
----
template < typename CharT
         , <<premeasurements,size_presence>> SizePresence
         , <<premeasurements,width_presence>> WidthPresence
         , typename\... FPE
         , typename\... Args >
void measure
    ( {premeasurements}<SizePresence, WidthPresence>* pp
    , const {facets_pack}<FPE\...>& facets
    , const Args&\... args );
----

Calculates the size and/or width of the result of printing the arguments `args\...`

Compile-time requirements::
* All types in `Args\...` are __{Printable}__
* All types in `FPE\...` are __<<FacetsPackElement,FacetsPackElement>>__
  ( since this is a requirement of `{facets_pack}` ).

Effects::
* When `SizePresence` is `size_presence::yes`, for each argument `arg` in `args\...`
  instantiates the correponding _{Printer}_ type with `pp`, `facets`, and `arg`.
  This translates into the following
  https://en.cppreference.com/w/cpp/language/fold[fold expression]:
+
[source,cpp,subs=normal]
----
(\..., {printer_type}< CharT
                  , {premeasurements}<SizePresence, WidthPresence>
                  , facets_pack<FPE\...>
                  , Args >  {{make_printer}<CharT>(pp, facets, args)} );
----
* When `SizePresence` is `size_presence::no` and `WidthPresence` is `width_presence::yes`,
  for each argument `arg` in `args\...` instantiates the correponding _{Printer}_
  type with `pp`, `facets`, and `arg` ( again, using `{printer_type}`  and
  `{make_printer}` ), while `pp-><<width_accumulator,remaining_width>>() > 0`
  is `true`.
  This implies that not necessarily all argument in `arg\...` are used.
* When `SizePresence` is `size_presence::no` and `WidthPresence` is `width_presence::no`,
  does nothing

