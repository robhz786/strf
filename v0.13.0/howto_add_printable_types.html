<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>How to add printable types</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>How to add printable types</h1>
<div id="toc" class="toc2">
<div id="toctitle">Adding printable types</div>
<ul class="sectlevel1">
<li><a href="#_the_customization_point">The customization point</a></li>
<li><a href="#CreatePrintTraits">Creating a <em>PrintTraits</em> class</a>
<ul class="sectlevel2">
<li><a href="#_which_facets_to_forward">Which facets to forward ?</a></li>
</ul>
</li>
<li><a href="#creating_facet">Creating and using facets</a></li>
<li><a href="#_adding_format_functions">Adding format functions</a></li>
<li><a href="#_creating_format_functions">Creating format functions</a></li>
<li><a href="#creating_printer">The low-level way</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_the_customization_point">The customization point</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Strf uses the tag_invoke pattern to define printable types.
To make a type named <code>your_type</code> become printable,
you overload <code>tag_invoke</code> like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

struct your_type_print_traits { /*...*/ }; // a <em><a href="strf_hpp.html#PrintTraits">PrintTraits</a></em> type

your_type_print_traits tag_invoke(strf::print_traits_tag, const your_type&amp;);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In most compilers you don&#8217;t need to implement this overload.
It&#8217;s enough to just declare it, since the library just need to know
the return type, which can obtained with <code>decltype</code>.
Actually, even the declaration
is only necessary if you want to match types that derive from
or are implicitly convertible to <code>your_type</code>. Otherwise, you can
just define the template specialization <code>print_traits&lt;your_type&gt;</code>,
since this is the fallback the library uses when there is not
matching overload.</p>
</div>
<div class="paragraph">
<p>Whatever approach you use, <code>print_traits&lt;your_type&gt;</code>
or the return type of <code>tag_invoke</code> must satisfy <em><a href="strf_hpp.html#PrintTraits">PrintTraits</a></em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="CreatePrintTraits">Creating a <em><a href="strf_hpp.html#PrintTraits">PrintTraits</a></em> class</h2>
<div class="sectionbody">
<div class="paragraph">
<p>According to the documentation, a <em><a href="strf_hpp.html#PrintTraits">PrintTraits</a></em> class
must contain a static template function named <code>make_print_input</code>
that kind of tells the library how to print the value.</p>
</div>
<div class="paragraph">
<p>The type of the first argument is always an instance of the <code><a href="strf_hpp.html#print_preview">print_preview</a></code>
class template. But you don&#8217;t need to know much about it, unless
you need to <a href="#creating_printer">create a printer class</a>.
The type of the second argument is a always be an instance of <code><a href="strf_hpp.html#facets_pack">facets_pack</a></code>
class template. This argument contains the facet objects.
The third argument is the value to be printed.</p>
</div>
<div class="paragraph">
<p>For example, let&#8217;s make
<a href="https://en.cppreference.com/w/cpp/numeric/complex"><code>std::complex</code></a>
printable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename FloatT&gt;
struct print_traits&lt;std::complex&lt;FloatT&gt;&gt; {
    using <a href="strf_hpp.html#PrintTraits_override_tag">override_tag</a> = std::complex&lt;FloatT&gt;;
    using <a href="strf_hpp.html#PrintTraits_forwarded_type">forwarded_type</a> = std::complex&lt;FloatT&gt;;

    template &lt;typename CharT, typename Preview, typename FPack&gt;
    static auto make_printer_input
        ( Preview&amp; preview
        , const FPack&amp; fp
        , std::complex&lt;FloatT&gt; arg)
    {
        auto arg2 =  strf::<a href="quick_referance.html#joins">join</a>
            ( static_cast&lt;CharT&gt;('('), arg.real()
            , static_cast&lt;CharT&gt;(','), arg.imag()
            , static_cast&lt;CharT&gt;(')') );

        return <a href="strf_hpp.html#make_printer_input">strf::make_printer_input</a>&lt;CharT&gt;(preview, fp, arg2);
    }
};

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code above basically tells the library to handle a
<code>std::complex</code> in the same way it handles the <code><a href="quick_referance.html#joins">join</a></code> object created above ( <code>arg2</code> ).
That&#8217;s because the expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="strf_hpp.html#make_printer_input">strf::make_printer_input</a>&lt;CharT&gt;(<em>preview</em>, <em>fp</em>, <em>foo</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><em>foo_print_traits</em>::template make_printer_input&lt;CharT&gt;(<em>preview</em>, <em>fp</em>, <em>foo</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>, where <code><em>foo_print_traits</em></code> is the return type of <code>tag_invoke(strf::print_traits_tag{}, <em>foo</em>)</code></p>
</div>
<div class="paragraph">
<p>Actually, sometimes is instead be equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><em>overrider</em>.template make_printer_input&lt;CharT&gt;(<em>preview</em>, <em>fp</em>, <em>foo</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>, where <code><em>overrider</em></code> is a facet object of the <code><a href="strf_hpp.html#print_override_c">print_override_c</a></code> category,
but you don&#8217;t have to think about this now.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>make_printer_input</code> function does not actually print the value,
it just returns an object that the library knows how to print.
Make sure that the returned object does not contain any dangling reference.
For example, if the join we created in the above contained a
reference to any local object, we would get undefined behaviour.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Anyway  , sometimes it is not possible to use this tactic,
<em>i.e.</em> to print a value by converting it to another that is already printable.
A <a href="#creating_printer">further section</a> explains how to deal with such cases.</p>
</div>
<div class="sect2">
<h3 id="_which_facets_to_forward">Which facets to forward ?</h3>
<div class="paragraph">
<p>There is an important consideration to make when
you implement the <code>make_printer_input</code> member function
of a <em>PrintTraits</em> class that calls
<code><a href="strf_hpp.html#make_printer_input">strf::make_printer_input</a></code> as we did previously:
you need to decide which facets are and which aren&#8217;t propagated.</p>
</div>
<div class="paragraph">
<p>The facet objects are inside the second parameter of <code>make_printer_input</code>
( which we named in the above example as <code>fp</code> ).
Its type is ( supposed to be ) an instance of the <code><a href="strf_hpp.html#facets_pack">facets_pack</a></code>
template.
When printing a <code>std::complex</code> as we did above,
it makes sense to just forward all facet objects.
And this is what we did by passing <code>fp</code> to
<code><a href="strf_hpp.html#make_printer_input">strf::make_printer_input</a></code>. As a consequence, if <code>fp</code> specifies
<a href="quick_reference.html.html#numpunct">punctuation</a> for floation points
, for example, then the floating points values are
printed with punctuation.</p>
</div>
<div class="paragraph">
<p>However, suppose we were printing instead an IPv4 address.
Now we have four integer values separated by dots
( in the usual
<a href="https://en.wikipedia.org/wiki/Dot-decimal_notation">dot decimal notation</a> )
In this case it would be simply wrong to apply numeric punctuation
on those integers.
So <code>numpunct_c&lt;10&gt;</code> is one of the facet category
that would have to be excluded.
There is also another one: the <code><a href="strf_hpp.html#print_override_c">print_override_c</a></code>,
which enables a facet to overrides how a type is printed.
It could make integers to be printed in a different
numeral system, for example. That would also be wrong.</p>
</div>
<div class="paragraph">
<p>So how do we prevent some facet categories to propagate ?
It is not possible to remove elements from a <a href="strf_hpp.html#facets_pack">facets_pack</a>
object. So we instead create a new one, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto fp2 = strf::pack( fp
                     , strf::default_numpunct&lt;10&gt;{}
                     , strf::<a href="strf_hpp.html#no_print_override">no_print_override</a>{} );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>fp2</code> object created above contains a copy of all facet objects
of <code>fp</code>, but those associated with the <code>numpunct_c&lt;10&gt;</code> and <code>print_override_c</code>
categories are overriden by the corresponding default facet values.</p>
</div>
<div class="paragraph">
<p>Of course, you could instead create <code>fp2</code> with only the facet object
you want to forward, <em>i.e.</em> extracting each of them
from <code>fp</code> with <code><a href="strf_hpp.html#get_facet">get_facet</a></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto fp2 = strf::pack
    ( strf::get_facet&lt;/* category 1 */, /* some type */&gt;(fp)
    , strf::get_facet&lt;/* category 2 */, /* some type */&gt;(fp)
    , strf::get_facet&lt;/* category 3 */, /* some type */&gt;(fp) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the case of IPv4 address, we actually don&#8217;t need to forward
any facet. We could just ignore <code>fp</code> and pass <code>strf::pack()</code>.
However, this is not the case when printing IPv4 with alignment.
Because remember that the fill character is a <code>char32_t</code>
value that needs to be properly encoded, which means you have to
propagate the facet object associated with
the <code><a href="strf_hpp.html#char_encoding_c">char_encoding_c</a>&lt;<em>char_type</em>&gt;</code> category,
which is actually something that you should always do,
unless you when are sure that it&#8217;s not necessary ( and it
is never wrong anyway ).</p>
</div>
<div class="paragraph">
<p>Anyway, you should always carefully check all the facet categories
employed in each of the types you are using ( they are all
documented <a href="strf_hpp.html#_list_of_printable_types">here</a> ).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating_facet">Creating and using facets</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes you may want to create a new facet category
for the new printable type. For example, suppose
we want to turn the following enumeration into a facet
that enables the user to select which form the complex numbers
shall be printed in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">enum class complex_form { vector, algebric, polar };</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Same complex number printed in different forms</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>complex_form::vector</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(3, 4)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>complex_form::algebric</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(3 + i*4)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>complex_form::polar</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>5∠ 0.9272952180016122</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Too turn <code>complex_form</code> into a facet, <em>i.e.</em> to make it satisfy the
<em><a href="strf_hpp.html#Facet">Facet</a></em> requirement, we do the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">struct complex_form_c {
    static constexpr complex_form get_default() noexcept {
        return complex_form::vector;
    }
};

namespace strf {

template &lt;&gt; struct facet_traits&lt;complex_form&gt; {
    using category = complex_form_c;
};

} // namespace strf;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s reimplement <code>make_printer_input</code> to take
into account this new facet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename FloatT&gt;
std::pair&lt;FloatT, FloatT&gt; complex_coordinates
    ( std::complex&lt;FloatT&gt; x, complex_form form ) noexcept;

namespace strf {

template &lt;typename FloatT&gt;
struct print_traits&lt;std::complex&lt;FloatT&gt;&gt; {
    using override_tag = std::complex&lt;FloatT&gt;;
    using forwarded_type = std::complex&lt;FloatT&gt;;

    template &lt;typename CharT, typename Preview, typename FPack&gt;
    static auto make_printer_input
        ( Preview&amp; preview
        , const FPack&amp; fp
        , std::complex&lt;FloatT&gt; arg)
    {
        complex_form form = strf::<a href="strf_hpp.html#get_facet">get_facet</a>&lt;complex_form_c, std::complex&lt;FloatT&gt;&gt;(fp);
        auto v = ::complex_coordinates(arg, form);
        unsigned has_brackets = form != complex_form::polar;
        auto arg2 = strf::join
            ( strf::<a href="quick_reference.html#multi">multi</a>(static_cast&lt;CharT&gt;('('), has_brackets)
            , v.first
            , strf::<a href="quick_reference.html#string_formatting">conv</a>(middle_string(form), strf::<a href="quick_reference.html#static_char_encodings">utf16</a>&lt;char16_t&gt;())
            , v.second
            , strf::<a href="quick_reference.html#multi">multi</a>(static_cast&lt;CharT&gt;(')'), has_brackets) );

        return strf::make_printer_input&lt;CharT&gt;(preview, fp, arg2);
    }

private:

    static const char16_t* middle_string(complex_form form)
    {
        switch(form) {
            case complex_form::algebric: return u" + i*";
            case complex_form::polar: return u"\u2220 "; // the angle character ∠
            default: return u", ";
        }
    }
};

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Its first line gives us the <code>complex_form</code> value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">complex_form form = strf::<a href="strf_hpp.html#get_facet">get_facet</a>&lt;complex_form_c, std::complex&lt;FloatT&gt;&gt;(fp);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>get_facet</code> is used to extract a facet object from a <code><a href="strf_hpp.html#facets_pack">facets_pack</a></code> object.
The first template paramenter is the facet category.
The second is the usually printable type and it only has effect when there is
any <a href="introduction.html#constrained_facets">constrained facets</a> of the given category
in the the <code><a href="strf_hpp.html#facets_pack">facets_pack</a></code> object. The effect is that
<code><a href="strf_hpp.html#get_facet">get_facet</a></code> only returns the value inside a constrained facet when
<code>Filter&lt;Tag&gt;::value</code> is <code>true</code> ,
where <code>Filter</code> is the template parameter of the constrained facet, and <code>Tag</code>
is the second template parameter used in <code><a href="strf_hpp.html#get_facet">get_facet</a></code>
( which is <code>std::complex&lt;FloatT&gt;</code> in this case ).</p>
</div>
<div class="paragraph">
<p>Next, we evaluate the floating-point values to be printed.
We can&#8217;t just use <code>arg.real()</code> and <code>arg.imag()</code> as before,
since that would be incorrect in the polar form.
Let&#8217;s just assume the correct values are calculated in a function
named <code>complex_coordinates</code> whose implementation is not the point here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">std::pair&lt;FloatT,FloatT&gt; v = ::complex_coordinates(arg, form);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we want to the parenthesis to not be printed in the polar form,
we can achieve that using the <code><a href="quick_reference.html#multi">multi</a></code> format function.
It causes a character to be printed <em>n</em> times,
where <em>n</em> in our case is either 0 or 1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">unsigned has_brackets = form != complex_form::polar;
auto arg2 = strf::join
    ( strf::<a href="quick_reference.html#multi">multi</a>(static_cast&lt;CharT&gt;('('), has_brackets)
    /* ... */
    , strf::<a href="quick_reference.html#multi">multi</a>(static_cast&lt;CharT&gt;(')'), has_brackets) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that it is not possible to use instead <code><em>if-else</em></code> blocks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">if (form != complex_form::polar) {
    auto j1 = strf::join
            ( static_cast&lt;CharT&gt;('(')
            , v.first
            , strf::<a href="quick_reference.html#string_formatting">conv</a>(middle_string(form), strf::<a href="quick_reference.html#static_char_encodings">utf16</a>&lt;char16_t&gt;())
            , v.second
            , static_cast&lt;CharT&gt;(')') );
    return strf::make_printer_input&lt;CharT&gt;(preview, fp, j1);
}
auto j2 = strf::join
    ( v.first
    , strf::<a href="quick_reference.html#string_formatting">conv</a>(middle_string(form), strf::<a href="quick_reference.html#static_char_encodings">utf16</a>&lt;char16_t&gt;())
    , v.second );
return strf::make_printer_input&lt;CharT&gt;(preview, fp, j2); // different return type !</code></pre>
</div>
</div>
<div class="paragraph">
<p>That wouldn&#8217;t compile since <code>j1</code> and <code>j2</code> have different types.</p>
</div>
<div class="paragraph">
<p>At last, we need to select a different middle string for each form.
No big deal here, we just created a fuction <code>middle_string</code> to handle that.
But what may have caught your eye is that the string is passed to
the <code><a href="quick_reference.html#string_formatting">conv</a></code> function. The code wouldn&#8217;t compile without it, unless
when <code>CharT</code> is the same as the string&#8217;s character type, and even
in this case, there is the risk of the destination encoding differs
from the one used in the string ( especially if we were using a <code>char</code>
string, instead of a <code>char16_t</code> string as we did above ).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto arg2 = strf::<a href="quick_referance.html#joins">join</a>
    ( /* ... */
    , /* ... */
    , strf::<a href="quick_reference.html#string_formatting">conv</a>(middle_string(form), strf::<a href="quick_reference.html#static_char_encodings">utf16</a>&lt;char16_t&gt;())
    , /* ... */
    , /* ... */ );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you are ready to go:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">void sample()
{
    auto str = strf::to_string(std::complex&lt;double&gt;(3, 4));
    assert(str == "(3, 4)");

    str = strf::to_string.with(complex_form::algebric) (std::complex&lt;double&gt;(3, 4));
    assert(str == "(3 + i*4)");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_adding_format_functions">Adding format functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Format functions are defined in classes that
comply with the <em><a href="strf_hpp.html#Formatter">Formatter</a></em> requirements.
If you want to add format functions
you need to create a formatter class and/or
select one or some of those provided by the library.
Then, in your <em>PrinterTraits</em> class, you need
to define a member <code><a href="strf_hpp.html#PrintTraits_formatters">formatters</a></code> as a type alias
to <code><a href="strf_hpp.html#tag">tag</a>&lt;Fmts...&gt;</code>,
where <code>Fmts...</code> are the <em><a href="strf_hpp.html#Formatter">Formatter</a></em> types you want
to enable.</p>
</div>
<div class="paragraph">
<p>There are formatters that make sense for <code>std::complex</code>:
the <code><a href="strf_hpp.html#alignment_formatter">alignment_formatter</a></code> and the <code><a href="strf_hpp.html#float_formatter">float_formatter</a></code>. So let&#8217;s
select them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename FloatT&gt;
struct print_traits&lt;std::complex&lt;FloatT&gt;&gt; {
    // &#8230;&#8203;
    using <a href="strf_hpp.html#PrintTraits_formatters">formatters</a> = strf::<a href="strf_hpp.html#tag">tag</a>
        &lt; <a href="strf_hpp.html#alignment_formatter">alignment_formatter</a>
        , <a href="strf_hpp.html#float_formatter">float_formatter</a>&lt;strf::float_notation::general&gt; &gt;;
    // &#8230;&#8203;
};

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>After that, whenever a value <code>x</code> is a <code>std::complex</code>,
expressions like <code>+strf::fmt(x)</code> and <code>*strf::sci(x) &gt; 20</code> and <code>right(x, 20, '_').sci()</code>
are all well-formed, and the type of <code>strf::fmt(x)</code> is
<code><a href="strf_hpp.html#value_with_formatters">value_with_formatters</a>&lt;print_traits&lt;std::complex&lt;&#8230;&#8203;&gt;&gt;, Fmts...&gt;</code>, where <code>Fmts...</code>
are the types you used in to define the <code>formatters</code> type alias.</p>
</div>
<div class="paragraph">
<p>Though well-formed, they are still not printable.
To make them printable we need to overload <code>make_printer_input</code>.
As I did before, I will show a solution and then explain it further:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename FloatT&gt;
struct print_traits&lt;std::complex&lt;FloatT&gt;&gt; {

    // ...

    template &lt;typename CharT, typename Preview, typename FPack&gt;
    static auto make_printer_input
        ( Preview&amp; preview
        , const FPack&amp; fp
        , std::complex&lt;FloatT&gt; arg)
    {
        // handles value without formatting
        // ( same as before )
    }

    template &lt; typename CharT, typename Preview, typename FPack, typename... T&gt;
    static auto make_printer_input
        ( Preview&amp; preview
        , const FPack&amp; fp
        , strf::<a href="strf_hpp.html#value_with_formatters">value_with_formatters</a>&lt;T...&gt; arg )
    {
        // handles value with formatting

        auto form = strf::get_facet&lt;complex_form_c, std::complex&lt;FloatT&gt;&gt;(fp);
        auto v = ::complex_coordinates(arg.value(), form);
        unsigned has_brackets = form != complex_form::polar;
        auto arg2 = strf::join
            ( strf::<a href="quick_reference.html#multi">multi</a>(static_cast&lt;CharT&gt;('('), has_brackets)
            , strf::fmt(v.first).<a href="strf_hpp.html#float_formatter">set_float_format</a>(arg.<a href="strf_hpp.html#float_formatter">get_float_format</a>())
            , strf::conv(middle_string(form), strf::utf16&lt;char16_t&gt;())
            , strf::fmt(v.second).<a href="strf_hpp.html#float_formatter">set_float_format</a>(arg.<a href="strf_hpp.html#float_formatter">get_float_format</a>())
            , strf::<a href="quick_reference.html#multi">multi</a>(static_cast&lt;CharT&gt;(')'), has_brackets) );
        auto arg3 = arg2.<a href="strf_hpp.html#alignment_formatter_fn_false">set_alignment_format</a>(arg.<a href="strf_hpp.html#alignment_formatter_fn_false">get_alignment_format</a>());
        return strf::make_printer_input&lt;CharT&gt;(preview, fp, arg3);
    }
};

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of taking a raw <code>std::complex&lt;Float&gt;</code>, the new overload takes a
<code><a href="strf_hpp.html#value_with_formatters">value_with_formatters</a>&lt;T...&gt;</code> which matches the return type of the format functions.
Note that we need to add that template parameter pack because the <em>Formatters</em> types
in <code><a href="strf_hpp.html#value_with_formatters">value_with_formatters</a></code> may change as some format functions are used. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">std::complex&lt;double&gt; x;

auto arg1 = strf::fmt(x);
auto arg2 = strf::fmt(x).sci();
auto arg3 = strf::fmt(x).sci() &gt; 10;

// arg1, arg2 and arg3 have different types:
static_assert(! std::is_same_v(decltype(arg1), decltype(arg2)));
static_assert(! std::is_same_v(decltype(arg2), decltype(arg3)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s look at the implementation. You can see there are few changes from
the original. The first one is that we need to use <code>value()</code> function
to extract the <code>std::complex</code> value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">        auto v = ::complex_coordinates(arg<strong>.value()</strong>, form);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Second, we re-apply the floating-point formatting the each floating-point value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">        auto arg2 = strf::join
            ( /* &#8230;&#8203; */
            , strf::fmt(v.first).<a href="strf_hpp.html#float_formatter">set_float_format</a>(arg.<a href="strf_hpp.html#float_formatter">get_float_format</a>())
            , /* &#8230;&#8203; */
            , strf::fmt(v.second).<a href="strf_hpp.html#float_formatter">set_float_format</a>(arg.<a href="strf_hpp.html#float_formatter">get_float_format</a>())
            , /* &#8230;&#8203; */ );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Third, we apply the alignment formatting to the join:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">        auto arg3 = arg2.<a href="strf_hpp.html#alignment_formatter_fn_false">set_alignment_format</a>(arg.<a href="strf_hpp.html#alignment_formatter_fn_false">get_alignment_format</a>());</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_format_functions">Creating format functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>But what if you don&#8217;t want just to enable existing format functions
to your printable type, but also create new ones ?</p>
</div>
<div class="paragraph">
<p>In a <a href="#creating_facet">previous section</a> we created a facet
that specifies the complex number form (vector, algebric or polar).
Now, let&#8217;s suppose we want create format functions for the same purpose.</p>
</div>
<div class="paragraph">
<p>This means we need to create a <em><a href="strf_hpp.html#Formatter">Formatter</a></em> class, which we can
name as <code>std_complex_formatter</code>.
It is required to have a member template type named <code>fn</code> where
the format functions are defined. The template parameter is
used in the return type of the format functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">struct std_complex_formatter {

    enum class complex_form_fmt {
        vector   = (int)complex_form::vector,
        algebric = (int)complex_form::algebric,
        polar    = (int)complex_form::polar,
        use_facet = 1 + std::max({vector, algebric, polar})
    };

    template &lt;class T&gt;
    class fn
    {
    public:

        fn() = default;

        template &lt;class U&gt;
        constexpr fn(const fn&lt;U&gt;&amp; u) noexcept
            : form_(u.form())
        {
        }
        constexpr T&amp;&amp; vector() &amp;&amp; noexcept
        {
            form_ = complex_form_fmt::vector;
            return static_cast&lt;T&amp;&amp;&gt;(*this);
        }
        constexpr T&amp;&amp; algebric() &amp;&amp; noexcept
        {
            form_ = complex_form_fmt::algebric;
            return static_cast&lt;T&amp;&amp;&gt;(*this);
        }
        constexpr T&amp;&amp; polar() &amp;&amp; noexcept
        {
            form_ = complex_form_fmt::polar;
            return static_cast&lt;T&amp;&amp;&gt;(*this);
        }
        constexpr complex_form form(complex_form f) const
        {
            return form_ == complex_form_fmt::use_facet ? f : static_cast&lt;complex_form&gt;(form_);
        }
        constexpr complex_form_fmt form() const
        {
            return form_;
        }

    private:

        complex_form_fmt form_ = complex_form_fmt::use_facet;
    };
};</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>vector()</code>, <code>algebric()</code> and <code>polar()</code> are the format functions
we are creating. <code>std_complex_formatter</code> is designed to work in conjuction with
the <code>complex_form</code> facet that we defined previously. So if none of
its format function is called, the form defined by the facet
object is taken.</p>
</div>
<div class="paragraph">
<p>The <code>static_cast</code> expressions above work because
<code>fn&lt;T&gt;</code> is supposed to be a base class of <code>T</code>
( yes, it&#8217;s the <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> ).
Not only that, <code>T</code> is expected to be an instance of <code><a href="strf_hpp.html#value_with_formatters">value_with_formatters</a></code>
that has <code>std_complex_formatter</code> as one of its template arguments.</p>
</div>
<div class="paragraph">
<p>In our <em>PrintTraits</em> class, there are only two small
modifications: <code>formatters</code> and the first line
of <code>make_printer_input</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename FloatT&gt;
struct print_traits&lt;std::complex&lt;FloatT&gt;&gt; {

    // ...

    using formatters = strf::tag
        &lt; <strong>std_complex_formatter</strong>
        , strf::alignment_formatter
        , strf::float_formatter&lt;strf::float_notation::general&gt; &gt;;

    template &lt;typename CharT, typename Preview, typename FPack&gt;
    static auto make_printer_input
        ( Preview&amp; preview
        , const FPack&amp; fp
        , std::complex&lt;FloatT&gt; arg)
    {
        // same as before
        //...
    }

    template &lt; typename CharT, typename Preview, typename FPack, typename... T&gt;
    static auto make_printer_input
        ( Preview&amp; preview
        , const FPack&amp; fp
        , strf::<a href="strf_hpp.html#value_with_formatters">value_with_formatters</a>&lt;T...&gt; arg )
    {
        auto form = arg.form(strf::get_facet&lt;complex_form_c, std::complex&lt;FloatT&gt;&gt;(fp));

        // same as before
        //...
    }
};

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, we a are ready to play:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">void sample()
{
    std::complex&lt;double&gt; x{3, 4};

    auto str = strf::to_u16string .with(complex_form::algebric)
        ( x, u" == ", strf::sci(x).p(5).polar() );

    assert(str == u"(3 + i*4) == 5.00000e+00∠ 9.27295e-01");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, you may find that <code>std_complex_formatter::fn</code> is incomplete
because we only create format functions that are non-const
and use the <code>&amp;&amp;</code> ref-qualifier. Shouldn&#8217;t we overload them
for the other cases as well ? They would be necessary
in situation like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">const auto fmt1 = strf::fmt(std::complex&lt;double&gt;{3, 4});
auto fmt2 = fmt1.polar(); // error: no polar() for const lvalue
fmt2.algebric();          // error: no algebric() for non-const lvalue</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, for the sake of completeness, below goes <code>polar()</code> overloaded
for both rvalues and lvalues:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">struct std_complex_formatter {
    // ...

    template &lt;class T&gt;
    class fn
    {
    public:

        // ...
        constexpr explicit fn(complex_form_fmt f) noexcept
            : form_(f)
        {
        }

        constexpr T&amp;&amp; polar() &amp;&amp; noexcept
        {
            // ( same as before )
        }
        constexpr T&amp; polar() &amp; noexcept
        {
            form_ = complex_form_fmt::polar;
            return static_cast&lt;T&amp;&gt;(*this);
        }
        constexpr T polar() const &amp; noexcept
        {
            return T{ static_cast&lt;const T&amp;&gt;(*this)
                    , strf::tag&lt;std_complex_formatter&gt; {}
                    , complex_form_fmt::polar };
        }
        // ( vector and algebric are analogous )

        // ...
    };
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the const version of <code>polar()</code> can&#8217;t modify the current object,
it instead returns a new one where each base class subobject is initialized
with (copied from) the correponding base class subobject of this object,
except the <code>std_complex_formatter::fn&lt;T&gt;</code> one,
which is initialized instead with <code>complex_form_fmt::polar</code>.
This is why we also need to add that constructor that has
a <code>complex_form_fmt</code> paramenter. The <code>value_with_formtters</code> ' constructor
used above is documented <a href="strf_hpp.html#value_with_formatters_vwf2_t_i">here</a>.</p>
</div>
<div class="paragraph">
<p>And its done! I think is a pretty complete example of how to make
<code>std::complex</code> printable. You can see the complete implementation
<a href="https://github.com/robhz786/strf/blob/v0.13.0/example/extend_input_std_complex.cpp">here</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating_printer">The low-level way</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes, when creating a <em>PrinterTraits</em> class,
it is not possible possible to make its <code>make_printer_input</code>
member function just return <code>strf::make_printer_input(&#8230;&#8203;)</code>
as we did in the previous sections.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s see another approach to make <code>std::complex</code>
printable &#x2014; the low-level way.
First, let&#8217;s redefine <code>print_traits&lt;std::complex&lt;&#8230;&#8203;&gt;&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
template &lt;typename FloatT&gt;
struct print_traits&lt;std::complex&lt;FloatT&gt;&gt;
{
    using override_tag = std::complex&lt;FloatT&gt;;
    using forwarded_type = std::complex&lt;FloatT&gt;;
    using formatters = strf::tag&lt; &#8230;&#8203; /*same as before*/&gt;;

    // make_print_input that handles unformatted values
    template &lt;typename CharT, typename Preview, typename FPack&gt;
    static auto make_printer_input
        ( Preview&amp; preview
        , const FPack&amp; fp
        , std::complex&lt;FloatT&gt; arg )
        -&gt; strf::<a href="strf_hpp.html#usual_printer_input">usual_printer_input</a>
            &lt; CharT, Preview, FPack, std::complex&lt;FloatT&gt;
            , std_complex_printer&lt;CharT, FloatT&gt; &gt;
    {
        return {preview, fp, arg};
    }

    &#8230;&#8203; /* omitting the make_print_input overload that handles formatted values */ &#8230;&#8203;
};
} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>The return type of <code>make_printer_input</code> must aways be a <em><a href="strf_hpp.html#PrintInput">PrinterInput</a></em>
type, and the <code><a href="strf_hpp.html#usual_printer_input">usual_printer_input</a></code> class template is syntatic sugar to
achieve that.
Most of the work lies in creating the class &#x2014;
 or, more likely, the class template &#x2014;
used in its fifth template parameter, named here as <code>std_complex_printer</code>.
It must be a concrete
class that derives from <code><a href="strf_hpp.html#printer">printer</a>&lt;CharT&gt;</code>, or that is
<a href="https://en.cppreference.com/w/cpp/language/cast_operator">convertible</a>
to <code>const <a href="strf_hpp.html#printer">printer</a>&lt;CharT&gt;&amp;</code>. It must also be constructible from the
return type of our <code>make_printer_input</code> member function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename CharT, typename FloatT&gt;
class std_complex_printer: public strf::printer&lt;CharT&gt; {
public:

    template &lt;typename... T&gt;
    explicit std_complex_printer(strf::usual_printer_input&lt;T...&gt;);

    void print_to(strf::<a href="outbuff_hpp.html#basic_outbuff">basic_outbuff</a>&lt;CharT&gt;&amp; dest) const override;

private:

    template &lt;typename Preview, typename WCalc&gt;
    void preview_(Preview&amp; preview, const WCalc&amp; wcalc) const;

    strf::<a href="strf_hpp.html#dynamic_char_encoding">dynamic_char_encoding</a>&lt;CharT&gt; encoding_;
    strf::<a href="strf_hpp.html#numpunct">numpunct</a>&lt;10&gt; numpunct_;
    strf::<a href="strf_hpp.html#lettercase">lettercase</a> lettercase_;
    complex_form form_;
    std::pair&lt;FloatT, FloatT&gt; coordinates_;

    static constexpr char32_t anglechar_ = 0x2220;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>print_to</code> member function is responsible for writing the content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename CharT, typename FloatT&gt;
void std_complex_printer&lt;CharT, FloatT&gt;::print_to(strf::<a href="outbuff_hpp.html#basic_outbuff">basic_outbuff</a>&lt;CharT&gt;&amp; dest) const
{
    auto print = strf::to(dest).with(lettercase_, numpunct_, encoding_);
    if (form_ == complex_form::polar) {
        print(coordinates_.first, U'\u2220', static_cast&lt;CharT&gt;(' ') );
        print(coordinates_.second );
    } else {
        print((CharT)'(', coordinates_.first);
        print(strf::conv(form_ == complex_form::algebric ? " + i*" : ", ") );
        print(coordinates_.second, (CharT)')');
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s look the constructor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename CharT, typename FloatT&gt;
template &lt;typename... T&gt;
inline std_complex_printer&lt;CharT, FloatT&gt;::std_complex_printer
    ( strf::<a href="strf_hpp.html#usual_printer_input">usual_printer_input</a>&lt;T...&gt; x )
    : encoding_(strf::<a href="strf_hpp.html#get_facet">get_facet</a>&lt;strf::<a href="strf_hpp.html#char_encoding_c">char_encoding_c</a>&lt;CharT&gt;, void&gt;(x.facets))
    , numpunct_(strf::<a href="strf_hpp.html#get_facet">get_facet</a>&lt;strf::<a href="strf_hpp.html#numpunct_c">numpunct_c</a>&lt;10&gt;, FloatT&gt;(x.facets))
    , lettercase_(strf::<a href="strf_hpp.html#get_facet">get_facet</a>&lt;strf::<a href="strf_hpp.html#lettercase">lettercase_c</a>, FloatT&gt;(x.facets))
    , form_(strf::<a href="strf_hpp.html#get_facet">get_facet</a>&lt;complex_form_c, std::complex&lt;FloatT&gt;&gt;(x.facets))
    , coordinates_(::complex_coordinates(form_, x.arg))
{
    auto wcalc = strf::<a href="strf_hpp.html#get_facet">get_facet</a>&lt; strf::<a href="strf_hpp.html#width_calculator_c">width_calculator_c</a>
                                , std::complex&lt;FloatT&gt; &gt;(x.facets);
    preview_(x.preview, wcalc);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The member variables <code>encoding_</code>, <code>numpunct_</code> and <code>lettercase_</code> are facet objects.
The reason why I did not instead just store a copy of <code>x.facets</code> as member
variable is because its type would need to be another template paramenter,
one that would change often &#x2014; every time the facets are different &#x2014;
thus causing some code bloat.</p>
</div>
<div class="paragraph">
<p>Usually the second template argument in <code><a href="strf_hpp.html#get_facet">get_facet</a></code> is the input type,
which here is <code>std::comple&lt;FloatT&gt;</code>. However, I decided that
it makes more sense to use <code>FloatT</code> for the numeric punctuation
and letter case. There is no strict rule for that.
The type you choose to extract the encoding facet object makes
not difference since encoding facets are not constrainable.</p>
</div>
<div class="paragraph">
<p>Now, in addition to initialize the object, the constructor <strong>must</strong>
do another thing. <code><a href="strf_hpp.html#usual_printer_input">usual_printer_input</a></code> contains a <code><a href="strf_hpp.html#print_preview">print_preview</a></code>
reference, named <code>preview</code>. When the first template argument of this
<code>print_preview</code> is <code>preview_size::yes</code>, then
we must inform the size of the content that <code>print_to</code> writes.
Actually, let me rephare that, because it&#8217;s a little bit tricky:
our constructor must inform
a size <code>s</code> that ensures that <code>print_to</code> does not call
<code>dest.<a href="outbuf_hpp.html#basic_outbuff_recycle">recycle</a>()</code> if
<code>dest.<a href="outbuf_hpp.html#basic_outbuff_space">space</a>() &gt;= s</code>,
where <code>dest</code> is the argument passed to <code>print_to</code>.</p>
</div>
<div class="paragraph">
<p>However, you only need to be that cautious when your
<code>print_to</code> function directly calls <code>dest.recycle()</code>,
which is only the case when you write things directly to
<code>dest.<a href="outbuff_hpp.html#basic_outbuff_pointer">pointer</a>()</code>.
If you need to go that low-level, you may want to read
<a href="howto_add_destination.html">this document</a> to understand
how the class template <code><a href="outbuff_hpp.html#basic_outbuff">basic_outbuff</a></code> works.</p>
</div>
<div class="paragraph">
<p>Now, if this is too complicated, you can just instead
define your constructor with this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">using preview_type = typename strf::usual_printer_input&lt;T...&gt;::preview_type;
static_assert(! preview_type::<a href="strf_hpp.html#print_preview">size_required</a>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>That would prevent your printable type to work when the feature
<code><a href="introduction.html#syntax">reserve_calc</a></code> is used,
which may not be a problem to you.</p>
</div>
<div class="paragraph">
<p>When the second template argument of this
<code>print_preview</code> is <code>preview_width::yes</code>, then we must inform
<code>x.preview</code> the <code>width</code>. This happens only when your printable type
is used it in an <a href="quick_reference.html#aligned_join">aligned join</a>.
So if you don&#8217;t care about supporting that situation, you can just do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">using preview_type = typename strf::usual_printer_input&lt;T&#8230;&#8203;&gt;::preview_type;
static_assert(! preview_type::<a href="strf_hpp.html#print_preview">width_required</a>);

// or, if you don&#8217;t want to preview the size either:
static_assert(preview_type::<a href="strf_hpp.html#print_preview">nothing_required</a>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fortunately, in our case, previewing the size and width is not that difficult.
For the floating point values, we can use the global function template
<code><a href="strf_hpp.html#preview">preview</a></code>. The rest of the content we can easily calculate manually:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename CharT, typename FloatT&gt;
template &lt;typename Preview, typename WidthCalc&gt;
void std_complex_printer&lt;CharT, FloatT&gt;::preview_(Preview&amp; pp, const WidthCalc&amp; wcalc) const
{
    switch (form_) {
        case complex_form::algebric:
            pp.subtract_width(7);
            pp.add_size(7);
            break;

        case complex_form::vector:
            pp.subtract_width(4);
            pp.add_size(4);
            break;

        default:
            assert(form_ == complex_form::polar);
            if (pp.remaining_width() &gt; 0) {
                pp.subtract_width(wcalc.char_width(strf::utf32&lt;char32_t&gt;{}, anglechar_));
                pp.subtract_width(1);
            }

            pp.add_size(encoding_.encoded_char_size(anglechar_));
            pp.add_size(1);
    }

    auto facets = strf::pack(lettercase_, numpunct_, encoding_);
    strf::preview&lt;CharT&gt;(pp, facets, coordinates_.first, coordinates_.second);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To calculate the size of the angle character, that is used in the polar form,
we need to use the encoding facet object. To calculate its width, we use
the <code><a href="strf_hpp.html#width_calculator_c">width_calculator_c</a></code> facet category. And the width of ASCII characters is
always assumed to be equal to 1 in strf.</p>
</div>
<div class="paragraph">
<p>You can see the use of <code>add_size</code> and <code>subtract_width</code> functions.
When calculating the width is potentially expensive, it may worth to
check the return of <code>remaining_width</code> &#x2014; if its not greater than zero,
there is no further need to call <code>subract_width</code>.</p>
</div>
<div class="paragraph">
<p>With this, are ready with our <code>std_complex_printer</code> class template.
But, of course, we are not done yet, since it only handles
<code>std::complex</code> values without formatting. We need to create
another printer &#x2014; you could name <code>fmt_std_complex_printer</code>
&#x2014; to print formatted values, which is naturally a little
bit more complex. However, it&#8217;s basically the same idea:
<code>print_to</code> prints the content and the constructor previews it. Here is a full implementation:
<a href="https://github.com/robhz786/strf/blob/v0.13.0/example/std_complex_printer.cpp">example/std_complex_printer.cpp</a>.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-12-22 18:30:51 -0300
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js"></script>
</body>
</html>