<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>&lt;strf.hpp&gt; Header file reference</title>
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:34em;padding-right:0}
#toc.toc2{width:34em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:34em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{min-width:9em;font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body id="main" class="article toc2 toc-left">
<div id="header">
<h1><code>&lt;strf.hpp&gt;</code> Header file reference</h1>
<div id="toc" class="toc2">
<div id="toctitle">&lt;strf.hpp&gt;</div>
<ul class="sectlevel1">
<li><a href="#printable_types_list">1. List of printable types</a>
<ul class="sectlevel2">
<li><a href="#_strings">1.1. Strings</a></li>
<li><a href="#_single_characters">1.2. Single characters</a></li>
<li><a href="#printable_bool">1.3. <code>bool</code></a></li>
<li><a href="#_const_void">1.4. <code>const void*</code></a></li>
<li><a href="#_integers">1.5. Integers</a></li>
<li><a href="#_floating_points">1.6. Floating Points</a></li>
<li><a href="#_ranges">1.7. Ranges</a></li>
<li><a href="#join">1.8. Joins</a></li>
<li><a href="#tr_string">1.9. Tr-string</a></li>
<li><a href="#global_function_with">1.10. Facets</a></li>
</ul>
</li>
<li><a href="#_format_functions">2. Format functions</a>
<ul class="sectlevel2">
<li><a href="#_global_format_functions">2.1. Global format functions</a></li>
<li><a href="#FormatSpecifier">2.2. Type requirement <em>FormatSpecifier</em></a></li>
<li><a href="#alignment_format_specifier">2.3. <em>FormatSpecifier</em> <code>alignment_format_specifier</code></a></li>
<li><a href="#int_format_specifier">2.4. <em>FormatSpecifier</em> <code>int_format_specifier</code></a></li>
<li><a href="#float_format_specifier">2.5. <em>FormatSpecifier</em> <code>float_format_specifier</code></a></li>
<li><a href="#quantity_format_specifier">2.6. <em>FormatSpecifier</em> <code>quantity_format_specifier</code></a></li>
<li><a href="#string_precision_format_function">2.7. String precision</a></li>
<li><a href="#transcoding_format_functions">2.8. Transcoding format functions</a></li>
<li><a href="#fmt">2.9. Callable object <code>fmt</code></a></li>
<li><a href="#fmt_type">2.10. Type alias template <code>fmt_type</code></a></li>
<li><a href="#value_and_format">2.11. Class template <code>value_and_format</code></a></li>
</ul>
</li>
<li><a href="#_numeric_punctuation">3. Numeric punctuation</a>
<ul class="sectlevel2">
<li><a href="#numpunct_c">3.1. Facet category template <code>numpunct_c</code></a></li>
<li><a href="#NumericPunctuation">3.2. Type requirement <em>NumericPunctuation</em></a></li>
<li><a href="#numpunct">3.3. Class template <code>numpunct</code></a></li>
<li><a href="#default_numpunct">3.4. Class template <code>default_numpunct</code></a></li>
<li><a href="#no_grouping">3.5. Class template <code>no_grouping</code></a></li>
<li><a href="#digits_grouping">3.6. Class <code>digits_grouping</code></a></li>
<li><a href="#digits_grouping_creator">3.7. Class <code>digits_grouping_creator</code></a></li>
<li><a href="#digits_grouping_iterator">3.8. Class <code>digits_grouping_iterator</code></a></li>
<li><a href="#digits_distribution">3.9. Class <code>digits_distribution</code></a></li>
<li><a href="#reverse_digits_groups">3.10. Class <code>reverse_digits_groups</code></a></li>
</ul>
</li>
<li><a href="#_character_encodings">4. Character encodings</a>
<ul class="sectlevel2">
<li><a href="#charset_id">4.1. Enumeration <code>charset_id</code></a></li>
<li><a href="#transcoding_error_notifier_c">4.2. Facet category <code>transcoding_error_notifier_c</code></a></li>
<li><a href="#transcode_flags">4.3. Enum <code>transcode_flags</code></a></li>
<li><a href="#transcode_stop_reason">4.4. Enum <code>transcode_stop_reason</code></a></li>
<li><a href="#charset_c">4.5. Facet category template <code>charset_c</code></a></li>
<li><a href="#transcode_dest">4.6. Type alias template <code>transcode_dest</code></a></li>
<li><a href="#transcode_result">4.7. Struct template <code>transcode_result</code></a></li>
<li><a href="#transcode_size_result">4.8. Struct template <code>transcode_size_result</code></a></li>
<li><a href="#count_codepoints_result">4.9. Struct template <code>count_codepoints_result</code></a></li>
<li><a href="#charset_function_pointers">4.10. Aliases for pointers to functions</a></li>
<li><a href="#Transcoder">4.11. Type requirement <em>Transcoder</em></a></li>
<li><a href="#Charset">4.12. Type requirement <em>Charset</em></a></li>
<li><a href="#static_transcoder">4.13. Class template <code>static_transcoder</code></a></li>
<li><a href="#static_charset">4.14. Class template <code>static_charset</code></a></li>
<li><a href="#dynamic_transcoder">4.15. Class template <code>dynamic_transcoder</code></a></li>
<li><a href="#dynamic_charset_data">4.16. Struct template <code>dynamic_charset_data</code></a></li>
<li><a href="#dynamic_charset">4.17. Class template <code>dynamic_charset</code></a></li>
<li><a href="#find_transcoder">4.18. Function template <code>find_transcoder</code></a></li>
<li><a href="#decode_encode_result">4.19. Struct template <code>decode_encode_result</code></a></li>
<li><a href="#decode_encode_size_result">4.20. Struct template <code>decode_encode_size_result</code></a></li>
<li><a href="#decode_encode">4.21. Function template <code>decode_encode</code> </a></li>
<li><a href="#decode_encode_size">4.22. Function template <code>decode_encode_size</code></a></li>
<li><a href="#unsafe_decode_encode">4.23. Function template <code>unsafe_decode_encode</code> </a></li>
<li><a href="#unsafe_decode_encode_size">4.24. Function template <code>unsafe_decode_encode_size</code></a></li>
<li><a href="#transcode">4.25. Function template <code>transcode</code></a></li>
<li><a href="#transcode_size">4.26. Function template <code>transcode_size</code></a></li>
<li><a href="#unsafe_transcode">4.27. Function template <code>unsafe_transcode</code></a></li>
<li><a href="#unsafe_transcode_size">4.28. Function template <code>unsafe_transcode_size</code></a></li>
<li><a href="#static_charset_aliases">4.29. Type aliases for charsets</a></li>
<li><a href="#static_charset_constexpr">4.30. Template variable for charsets</a></li>
</ul>
</li>
<li><a href="#width_calculation">5. Width Calculation</a>
<ul class="sectlevel2">
<li><a href="#width_calculator_c">5.1. Facet category <code>width_calculator_c</code></a></li>
<li><a href="#fast_width">5.2. Class <code>fast_width_t</code></a></li>
<li><a href="#width_as_fast_u32len">5.3. Class <code>width_as_fast_u32len_t</code></a></li>
<li><a href="#width_as_u32len">5.4. Class <code>width_as_u32len_t</code></a></li>
<li><a href="#std_width_calc">5.5. Class <code>std_width_calc</code></a></li>
<li><a href="#width_t">5.6. Class <code>width_t</code></a></li>
<li><a href="#width_literal">5.7. <code>width_t</code> literal <code>_w</code></a></li>
</ul>
</li>
<li><a href="#_requirements_of_printable_types">6. Requirements of printable types</a>
<ul class="sectlevel2">
<li><a href="#Printable">6.1. Type requirement <em>Printable</em></a></li>
<li><a href="#printable_def_of">6.2. Type alias template <code>printable_def_of</code></a></li>
<li><a href="#PrintableDef">6.3. Type requirement <em>PrintableDef</em></a></li>
<li><a href="#representative_of_printable">6.4. Type alias template <code>representative_of_printable</code></a></li>
<li><a href="#is_printable_and_overridable">6.5. Variable template <code>is_printable_and_overridable</code></a></li>
<li><a href="#forwarded_printable_type">6.6. Type alias template <code>forwarded_printable_type</code></a></li>
<li><a href="#printable_overrider_c">6.7. Template facet category <code>printable_overrider_c</code></a></li>
<li><a href="#printable_overrider_c_of">6.8. Type alias <code>printable_overrider_c_of</code></a></li>
<li><a href="#dont_override">6.9. Struct template <code>dont_override</code></a></li>
<li><a href="#make_printer">6.10. Function template <code>make_printer</code></a></li>
<li><a href="#premeasurements">6.11. Class template <code>premeasurements</code></a></li>
<li><a href="#size_accumulator">6.12. Class template <code>size_accumulator</code></a></li>
<li><a href="#width_accumulator">6.13. Class template <code>width_accumulator</code></a></li>
<li><a href="#measure">6.14. Function template <code>measure</code></a></li>
</ul>
</li>
<li><a href="#_facets_pack">7. facets_pack</a>
<ul class="sectlevel2">
<li><a href="#facets_pack">7.1. Class template <code>facets_pack</code></a></li>
<li><a href="#pack">7.2. Function template <code>pack</code></a></li>
<li><a href="#get_facet">7.3. Function template <code>get_facet</code></a></li>
<li><a href="#has_facet">7.4. Hypothetical function template <code>has_facet</code></a></li>
<li><a href="#do_get_facet">7.5. Hypothetical function template <code>do_get_facet</code></a></li>
<li><a href="#constrained_fpe">7.6. Class template <code>constrained_fpe</code></a></li>
<li><a href="#constrain">7.7. Function template <code>constrain</code></a></li>
<li><a href="#FacetsPackElement">7.8. Type requirement <em>FacetsPackElement</em></a></li>
<li><a href="#ConstrainableFacetsPackElement">7.9. Type requirement <em>ConstrainableFacetsPackElement</em></a></li>
<li><a href="#Facet">7.10. Type requirement <em>Facet</em></a></li>
<li><a href="#FacetCategory">7.11. Type requirement <em>FacetCagory</em></a></li>
<li><a href="#facet_traits">7.12. Class template <code>facet_traits</code></a></li>
<li><a href="#facet_category">7.13. Type alias <code>facet_category</code></a></li>
</ul>
</li>
<li><a href="#destinators">8. Printing syntax</a>
<ul class="sectlevel2">
<li><a href="#printing_syntax">8.1. Class template <code>printing_syntax</code></a></li>
<li><a href="#DestinationCreator">8.2. Type requirement <em>DestinationCreator</em></a></li>
<li><a href="#SizedDestinationCreator">8.3. Type requirement <em>SizedDestinationCreator</em></a></li>
</ul>
</li>
<li><a href="#_miscellaneous">9. Miscellaneous</a>
<ul class="sectlevel2">
<li><a href="#lettercase">9.1. The <code>lettercase</code> facet</a></li>
<li><a href="#_type_traits">9.2. Type traits</a></li>
<li><a href="#tag">9.3. Class template <code>tag</code></a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This document is still a work in progress.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="printable_types_list">1. List of printable types</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_strings">1.1. Strings</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Types</dt>
<dd>
<p><code>const CharT*</code>, <code>std::basic_string_view&lt;CharT, Traits&gt;</code>
and <code>std::basic_string&lt;CharT, Traits, Alloc&gt;</code></p>
<div class="paragraph">
<p>where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CharT</code> is the character type. If it is not the same as the output character type, then it is necessary to use the <code>transcode</code> or <code>sani</code> format function.</p>
</li>
<li>
<p><code>Traits</code> can be any type that satisfies <a href="https://en.cppreference.com/w/cpp/named_req/CharTraits">CharTraits</a></p>
</li>
<li>
<p><code>Alloc</code> can be any type that satisfies <a href="https://en.cppreference.com/w/cpp/named_req/Allocator">Allocator</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Overridable</dt>
<dd>
<p>No</p>
</dd>
<dt class="hdlist1">Representative type</dt>
<dd>
<p><code>string_input_tag&lt;CharT&gt;</code>,  where <code>string_input_tag</code> is defined as below:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

struct string_input_tag_base {};

template &lt;typename CharT&gt;
struct string_input_tag: string_input_tag_base{}

} // namespace strf</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">Influenced by facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#width_calculator_c">width_calculator_c</a></code></p>
</li>
<li>
<p><code><a href="#charset_c">charset_c</a>&lt;<em>CharType</em>&gt;</code></p>
</li>
<li>
<p><code><a href="#transcoding_error_notifier_c">transcoding_error_notifier_c</a></code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Format functions</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="#alignment_format_specifier">alignment format functions</a></p>
</li>
<li>
<p><a href="#string_precision_format_function">string precision format function</a></p>
</li>
<li>
<p><a href="#transcoding_format_functions">transcoding format functions</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_single_characters">1.2. Single characters</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Type</dt>
<dd>
<p>The same as the output character type or <code>char32_t</code>. In the later case,
the UTF-32 character is encoded to the destination charset.</p>
</dd>
<dt class="hdlist1">Representative type</dt>
<dd>
<p>The same as the input type</p>
</dd>
<dt class="hdlist1">Overridable</dt>
<dd>
<p>No</p>
</dd>
<dt class="hdlist1">FormatSpecifier types</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#alignment_format_specifier">alignment_format_specifier</a></code></p>
</li>
<li>
<p><code><a href="#quantity_format_specifier">quantity_format_specifier</a></code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Influenced by facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#width_calculator_c">width_calculator_c</a></code></p>
</li>
<li>
<p><code><a href="#charset_c">charset_c</a>&lt;<em>CharType</em>&gt;</code>: in two situations:</p>
<div class="ulist">
<ul>
<li>
<p>when using <a href="#alignment_format_specifier">alignment formatting</a></p>
</li>
<li>
<p>when the character type is <code>char32_t</code> and the destination character type
is not <code>char32_t</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="printable_bool">1.3. <code>bool</code></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Type</dt>
<dd>
<p><code>bool</code></p>
</dd>
<dt class="hdlist1">Representative type</dt>
<dd>
<p><code>bool</code></p>
</dd>
<dt class="hdlist1">Overridable</dt>
<dd>
<p>Yes</p>
</dd>
<dt class="hdlist1">FormatSpecifier types</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#alignment_format_specifier">alignment_format_specifier</a></code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Influenced by facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#lettercase">lettercase_c</a></code></p>
</li>
<li>
<p><code><a href="#charset_c">charset_c</a>&lt;<em>CharType</em>&gt;</code>: Used to encode the <a href="#alignment_format_specifier">fill character</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_const_void">1.4. <code>const void*</code></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Types</dt>
<dd>
<p><code>const void*</code></p>
</dd>
<dt class="hdlist1">Representative type</dt>
<dd>
<p><code>const void*</code></p>
</dd>
<dt class="hdlist1">Overridable</dt>
<dd>
<p>Yes</p>
</dd>
<dt class="hdlist1">FormatSpecifier types</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#alignment_format_specifier">alignment_format_specifier</a></code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Influenced by facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#lettercase">lettercase_c</a></code></p>
</li>
<li>
<p><code><a href="#charset_c">charset_c</a>&lt;<em>CharType</em>&gt;</code>: Used to encode the <a href="#alignment_format_specifier">fill character</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_integers">1.5. Integers</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Types</dt>
<dd>
<p><code>short</code>,
<code>int</code>,
<code>long int</code>,
<code>long long int</code>,
<code>unsigned short</code>,
<code>unsigned int</code>,
<code>unsigned long int</code> and
<code>unsigned long long int</code></p>
</dd>
<dt class="hdlist1">Representative type</dt>
<dd>
<p>The same as the input type ( <code>short</code>,
<code>int</code>,
<code>long int</code>,
<code>long long int</code>,
<code>unsigned short</code>,
<code>unsigned int</code>,
<code>unsigned long int</code> or
<code>unsigned long long int</code> )</p>
</dd>
<dt class="hdlist1">Overridable</dt>
<dd>
<p>No</p>
</dd>
<dt class="hdlist1">FormatSpecifier types</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#alignment_format_specifier">alignment_format_specifier</a></code></p>
</li>
<li>
<p><code><a href="#int_format_specifier">int_format_specifier</a></code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Influenced by facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#lettercase">lettercase_c</a></code></p>
</li>
<li>
<p><code><a href="#numpunct">numpunct_c</a>&lt;<em>Base</em>&gt;</code></p>
</li>
<li>
<p><code><a href="#charset_c">charset_c</a>&lt;<em>CharType</em>&gt;</code>: Used to encode the <a href="#alignment_format_specifier">fill character</a> and the <a href="#numpunct">punctuation characters</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_floating_points">1.6. Floating Points</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Types</dt>
<dd>
<p><code>float</code>, <code>double</code></p>
</dd>
<dt class="hdlist1">Representative type</dt>
<dd>
<p>The same as the input type ( <code>float</code> or <code>double</code> )</p>
</dd>
<dt class="hdlist1">Overridable</dt>
<dd>
<p>Yes</p>
</dd>
<dt class="hdlist1">FormatSpecifier types</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#alignment_format_specifier">alignment_format_specifier</a></code></p>
</li>
<li>
<p><code><a href="#float_format_specifier">float_format_specifier</a></code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Influenced by facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#lettercase">lettercase_c</a></code></p>
</li>
<li>
<p><code><a href="#numpunct">numpunct_c</a>&lt;10&gt;</code></p>
</li>
<li>
<p><code><a href="#numpunct">numpunct_c</a>&lt;16&gt;</code></p>
</li>
<li>
<p><code><a href="#charset_c">charset_c</a>&lt;<em>CharType</em>&gt;</code>: Used to encode the <a href="#alignment_format_specifier">fill character</a> and the <a href="#numpunct">punctuation characters</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ranges">1.7. Ranges</h3>
<div class="sect3">
<h4 id="_without_formatting">Without formatting</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename Range&gt;
/*...*/ range(const Range&amp; r);

template &lt;typename T, std::size_t N&gt;
/*...*/ range(T (&amp;array)[N]);

template &lt;typename Iterator&gt;
/*...*/ range(const Iterator&amp; begin, const Iterator&amp; end);

// With operation

template &lt;typename Range, typename UnaryOperation&gt;
/*...*/ range(const Range&amp; r, UnaryOperation unary_op);

template &lt;typename T, std::size_t N, typename UnaryOperation&gt;
/*...*/ range(T (&amp;array)[N], UnaryOperation unary_op);

template &lt;typename Iterator, typename UnaryOperation&gt;
/*...*/ range( const Iterator&amp; begin
             , const Iterator&amp; end
             , UnaryOperation unary_op );

// With separator:

template &lt;typename Range, typename CharT&gt;
/*...*/ separated_range(const Range&amp; r, const CharT* separator);

template &lt;typename T, std::size_t N, typename CharT&gt;
/*...*/ separated_range(T (&amp;array)[N], const CharT* separator);

template &lt;typename Iterator, typename CharT&gt;
/*...*/ separated_range( const Iterator&amp; begin
                       , const Iterator&amp; end
                       , const CharT* separator );

// With separator and operation

template &lt;typename Range, typename CharT, typename UnaryOperation&gt;
/*...*/ separated_range( const Range&amp; r
                       , const CharT* separator
                       , UnaryOperation unary_op );

template &lt;typename T, std::size_t N, typename CharT, typename UnaryOperation&gt;
/*...*/ separated_range( T (&amp;array)[N]
                       , const CharT* separator
                       , UnaryOperation unary_op );

template &lt;typename Iterator, typename CharT, typename UnaryOperation&gt;
/*...*/ separated_range( const Iterator&amp; begin
                       , const Iterator&amp; end
                       , const CharT* separator
                       , UnaryOperation unary_op );
} // namespace strf</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">int arr[3] = { 11, 22, 33 };

auto str = strf::to_string(strf::range(arr));
assert(str == "112233");

str = strf::to_string(strf::separated_range(arr, ", "));
assert(str == "11, 22, 33");

auto op = [](auto x){ return strf::<a href="#join">join</a>('(', +strf::fmt(x * 10), ')'); };

str = strf::to_string(strf::separated_range(arr, ", ", op));
assert(str == "(+110), (+220), (+330)");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_with_formatting">With formatting</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename Range&gt;
/*...*/ fmt_range(const Range&amp; r);

template &lt;typename T, std::size_t N&gt;
/*...*/ fmt_range(T (&amp;array)[N], const Range&amp; r);

template &lt;typename Iterator&gt;
/*...*/ fmt_range(const Iterator&amp; begin, const Iterator&amp; end);

// With separator

template &lt;typename Range, typename CharT&gt;
/*...*/ fmt_separated_range(const Range&amp; r, const CharT* separator);

template &lt;typename T, std::size_t N, typename CharT&gt;
/*...*/ fmt_separated_range(T (&amp;array)[N], const CharT* separator);

template &lt;typename Iterator, typename CharT&gt;
/*...*/ fmt_separated_range( const Iterator&amp; begin
                           , const Iterator&amp; end
                           , const CharT* separator );
} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any format function applicable to the element type of the
range can also be applied to the
expression <code>strf::fmt_range(/*...*/)</code> or
<code>strf::fmt_separated_range(/*...*/)</code>.
This way the format functions is applied to all elements:</p>
</div>
<div class="listingblock">
<div class="title">Example 1</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">std::vector&lt;int&gt; vec = { 11, 22, 33 };
auto str1 = strf::to_string("[", +strf::fmt_separated_range(vec, " ;") &gt; 4, "]");
assert(str1 == "[ +11 ; +22 ; +33]");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 2</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">std::vector&lt;int&gt; vec = { 11, 22, 33 };
auto str2 = strf::to_string
    ( "["
    , *strf::fmt_separated_range(vec, " / ").fill('.').hex() &gt; 6,
    " ]");

assert(str2 == "[..0xfa / ..0xfb / ..0xfc]");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="join">1.8. Joins</h3>
<div class="sect3">
<h4 id="_without_alignment">Without alignment</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename ... Args&gt;
/*...*/ join(const Args&amp; ... args);

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_with_alignment">With alignment</h4>
<div class="paragraph">
<p>You can apply the <a href="#alignment_format_specifier">alignment format functions</a>
one the return type of <code>join(args...)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto str = strf::to_string
    ("---", strf::join("abc", "def", 123) &gt; 15, "---");

assert(str == "---      abcdef123---");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The functions below provide an alternartive syntax to create aligned
join. Their return type has the <code>operator()(const Args&amp; ... args)</code> member function
that receives the elements of the join.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

enum class text_alignment {left, right, center};

/* ... */ join_align( std::int16_t width
                    , text_alignment align
                    , char32_t fillchar = U' ' );
/* ... */ join_center(int width, char32_t fillchar = U' ');
/* ... */ join_left(int width, char32_t fillchar = U' ');
/* ... */ join_right(int width, char32_t fillchar = U' ');
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto str = strf::to_string
    ("---", strf::join_right(15) ("abc", "def", 123), "---");
assert(str == "---      abcdef123---");

str = strf::to_string
    ("---", strf::join_center(15) ("abc", "def", 123), "---");
assert(str == "---   abcdef123   ---");

str = strf::to_string
    ( "---"
    , strf::join_left(15, U'.') ("abc", strf::right("def", 5), 123)
    , "---" );
assert(str == "---abc  def123....---");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tr_string">1.9. Tr-string</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Type</dt>
<dd>
<p>The return type of the <code>tr</code> function template which is described further</p>
</dd>
<dt class="hdlist1">Overridable</dt>
<dd>
<p>No</p>
</dd>
<dt class="hdlist1">Influenced by facets category</dt>
<dd>
<p><code><a href="#tr_error_notifier_c">tr_error_notifier_c</a></code></p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_the_tr_function_template">The <code>tr</code> function template</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename StringType, typename&#8230;&#8203; Args&gt;
/*...*/ tr(const StringType&amp; str, Args&amp;&amp;... args);

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>StringType</code> must be either:</p>
<div class="ulist">
<ul>
<li>
<p>an instance of <code>std::basic_string</code> or <code>std::basic_string_view</code> whose first
template paramenter ( the character type ) is the same as the output
character type; or</p>
</li>
<li>
<p>implicitly convertible to <code>std::basic_string_view&lt;CharT&gt;</code>, where <code>CharT</code>
is the output character type</p>
</li>
</ul>
</div>
</li>
<li>
<p>All types in <code>std::remove_cv_t&lt;Args&gt;...</code> must be <em><a href="#Printable">Printable</a></em></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Returns a value that is printable.
The content to be printed is the result of parsing <code>str</code> against the <em>Tr-string syntax</em>, as explained below.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_tr_string_syntax">Tr-string Syntax</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">A <code>'{'</code> followed by</th>
<th class="tableblock halign-left valign-top">until</th>
<th class="tableblock halign-left valign-top">means</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'-'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the next <code>'}'</code> or end of string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a comment</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a digit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the next <code>'}'</code> or end of string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a positional argument reference</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">another <code>'{'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the second <code>'{'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">an escaped <code>'{'</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">any other character</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the next <code>'}'</code> or end of string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a non positional argument reference</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_examples">Examples:</h4>
<div class="listingblock">
<div class="title">Comments</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">const char* tr_string =
"You can learn more about python{-the programming language, not the reptile} at {}";

auto str = strf::to_string( strf::tr(tr_string, "www.python.org" ) );

assert(str == "You can learn more about python at www.python.org");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Positional arguments</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">const char* tr_string = "{1 a person} likes {0 a food type}";
auto str = strf::to_string(strf::tr(tr_string, "sandwich", "Paul"), '.');
assert(str == "Paul likes sandwich.");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Non positional arguments</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">const char* tr_string = "{a person} likes {a food type}"
auto str = strf::to_string(strf::tr(tr_string, "Paul", "sandwich"), '.');
assert(str == "Paul likes sandwich.");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Escapes</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto str = strf::to_string(strf::tr("} {{x} {{{} {{{}}", "aaa", "bbb"));
assert(str == "} {x} {aaa {bbb}");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_syntax_error_handling">Syntax error handling</h4>
<div class="paragraph">
<p>When the argument associated with a <code>"{"</code> does not exist, the library does two things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It prints a <a href="https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character">replacement character <code>"\uFFFD"</code> (&#65533;) </a>
( or <code>"?"</code> when the charset can&#8217;t represent it ) where the missing argument would be printed.</p>
</li>
<li>
<p>It calls the <code><a href="#TrErrorHandling">handle</a></code> function on the facet object correspoding to the <code>tr_error_notifier_c</code> category.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="tr_error_notifier_c">Facet category <code>tr_error_notifier_c</code></h4>
<div class="paragraph">
<p>For a type to be a facet of the <code>tr_error_notifier_c</code>, it must satisfy the
requirements of <em><a href="#TrErrorHandling">TrErrorHandling</a></em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

struct tr_error_notifier_c {
    static constexpr <a href="#default_tr_error_notifier">default_tr_error_notifier</a> get_default() noexcept
    {
        return <a href="#default_tr_error_notifier">default_tr_error_notifier</a>{};
    }
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="default_tr_error_notifier">Struct <code>default_tr_error_notifier</code></h4>
<div class="paragraph">
<p><code>default_tr_error_notifier</code> is the default facet of the <code>tr_error_notifier_c</code> category.
It&#8217;s a dummy error handler.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

struct default_tr_error_notifier {
    using category = tr_error_notifier_c;

    template &lt;typename Charset&gt;
    void handle
        ( const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
        , std::ptrdiff_t str_len
        , Charset charset
        , std::ptrdiff_t err_pos ) noexcept
    {
    }
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="TrErrorHandling">Type requirement <em>TrErrorHandling</em></h4>
<div class="paragraph">
<p>Given:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X</code>, a <em>TrErrorHandling</em> type</p>
</li>
<li>
<p><code>x</code>, a value of type <code>X</code></p>
</li>
<li>
<p><code>CharsetT</code>, a <em><a href="#Charset">Charset</a></em> type.</p>
</li>
<li>
<p><code>charset</code>, a value of type <code>CharsetT</code></p>
</li>
<li>
<p><code>str</code>, a value of type <code>const CharsetT::<a href="#Charset_code_unit">code_unit</a>*</code> pointing to string encoded according to <code>charset</code></p>
</li>
<li>
<p><code>str_len</code>, a <code>std::ptrdiff_t</code> value equal to the length of the string <code>str</code></p>
</li>
<li>
<p><code>err_pos</code>, a <code>std::ptrdiff_t</code> value less than or equal to <code>str_len</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must host:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
<li>
<p><code>X::category</code> is a type alias to <code>tr_error_notifier_c</code></p>
</li>
<li>
<p>The following expression is supported:</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.handle(str, str_len, charset, err_pos)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Semantics
</td>
<td class="hdlist2">
<p><code>str</code> is a tr-string that contains an error. <code>err_pos</code> is the
position of the <code>'{'</code> character in <code>str</code> that starts the invalid argument reference.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="global_function_with">1.10. Facets</h3>
<div class="paragraph">
<p>It is possible to override facets to only a subset of the input arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; typename FPack &gt;
class inner_pack
{
public:
    template &lt;typename... Args&gt;
    /*...*/  operator()(const Args&amp;... args) const;
    //...
};

template &lt;typename ... Facets&gt;
inner_pack&lt;/*...*/&gt; with(const Facets&amp;... facets);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 1</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto str = strf::to_string.with(strf::numpunct&lt;10&gt;(1))
    ( !strf::dec(10000)
    , "  "
    , !strf::hex(0x10000)
    , strf::with( strf::numpunct&lt;10&gt;(3)
                , strf::numpunct&lt;16&gt;(4).thousands_sep('\'') )
        ( "  { "
        , !strf::dec(10000)
        , "  "
        , !strf::hex(0x10000)
        , " }" ) );

assert(str == "1,0,0,0,0  10000  { 10,000  1'0000 }");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 2</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto fp = strf::pack
    ( strf::numpunct&lt;10&gt;(3)
    , strf::numpunct&lt;16&gt;(4).thousands_sep('\'') );

auto str = strf::to_string.with(strf::numpunct&lt;10&gt;(1))
    ( !strf::dec(10000)
    , "  "
    , !strf::hex(0x10000)
    , strf::with(fp)
        ( "  { "
        , !strf::dec(10000)
        , "  "
        , !strf::hex(0x10000)
        , strf::with
            (strf::numpunct&lt;10&gt;(2).thousands_sep('.'))
            ("  { ", !strf::dec(10000), " }")
        , " }" ) );

assert(str == "1,0,0,0,0  10000  { 10,000  1'0000  { 1.00.00 } }");</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_format_functions">2. Format functions</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_global_format_functions">2.1. Global format functions</h3>
<div id="format_function_aliases" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
inline namespace format_functions {

constexpr /*&#8230;&#8203;*/ right {};
constexpr /*&#8230;&#8203;*/ left {};
constexpr /*&#8230;&#8203;*/ center {};
constexpr /*&#8230;&#8203;*/ pad0 {};
constexpr /*&#8230;&#8203;*/ punct {};
constexpr /*&#8230;&#8203;*/ hex {};
constexpr /*&#8230;&#8203;*/ dec {};
constexpr /*&#8230;&#8203;*/ oct {};
constexpr /*&#8230;&#8203;*/ bin {};
constexpr /*&#8230;&#8203;*/ fixed {};
constexpr /*&#8230;&#8203;*/ sci {};
constexpr /*&#8230;&#8203;*/ gen {};
constexpr /*&#8230;&#8203;*/ multi {};
constexpr /*&#8230;&#8203;*/ sani {};

template &lt;typename T&gt;
constexpr /*&#8230;&#8203;*/ transcode(T&amp;&amp; value);

template &lt;typename T, typename Charset&gt;
constexpr /*&#8230;&#8203;*/ transcode(T&amp;&amp; value, Charset&amp;&amp; charset);

template &lt;typename T&gt;
constexpr /*&#8230;&#8203;*/ unsafe_transcode(T&amp;&amp; value);

template &lt;typename T, typename Charset&gt;
constexpr /*&#8230;&#8203;*/ unsafe_transcode(T&amp;&amp; value, Charset&amp;&amp; charset);

} // inline namespace format_functions
} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>format_functions</code> inline namespace contains callable objects
that work as alias to format functions</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 46.8085%;">
<col style="width: 53.1915%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Equivalent Expression</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>left(<em>arg</em>, <em>width</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>) &lt; <em>width</em></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>right(<em>arg</em>, <em>width</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>) &gt; <em>width</em></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>center(<em>arg</em>, <em>width</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>) ^ <em>width</em></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>left(<em>arg</em>, <em>width</em>, <em>ch</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).fill(<em>ch</em>) &lt; <em>width</em></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>right(<em>arg</em>, <em>width</em>, <em>ch</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).fill(<em>ch</em>) &gt; <em>width</em></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>center(<em>arg</em>, <em>width</em>, <em>ch</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).fill(<em>ch</em>) ^ <em>width</em></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pad0(<em>arg</em>, <em>count</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).pad0(<em>count</em>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>punct(<em>arg</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).punct()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hex(<em>arg</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).hex()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>oct(<em>arg</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).dec()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dec(<em>arg</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).oct()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bin(<em>arg</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).bin()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sci(<em>arg</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).sic()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fixed(<em>arg</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).fixed()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gen(<em>arg</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).gen()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sci(<em>arg</em>, <em>precision</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).sic().p(<em>precision</em>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fixed(<em>arg</em>, <em>precision</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).fixed().p(<em>precision</em>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gen(<em>arg</em>, <em>precision</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).gen().p(<em>precision</em>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>multi(<em>arg</em>, <em>count</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).multi(<em>count</em>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transcode(<em>arg</em>, <em>charset</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).transcode(<em>charset</em>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transcode(<em>arg</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).transcode()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>unsafe_transcode(<em>arg</em>, <em>charset</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).unsafe_transcode(<em>charset</em>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>unsafe_transcode(<em>arg</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).unsafe_transcode()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sani(<em>arg</em>, <em>charset</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).sani(<em>charset</em>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sani(<em>arg</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#fmt">fmt</a>(<em>arg</em>).sani()</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="FormatSpecifier">2.2. Type requirement <em>FormatSpecifier</em></h3>
<div class="paragraph">
<p>A type <code>Fmt</code> is a <em>FormatSpecifier</em> if it has a member <code>fn</code> that is a type template
with one template type parameter such that, given any types <code>T</code> and <code>U</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Fmt::template fn&lt;T&gt;</code> is well-formed if <code>T</code> is <code>value_and_format&lt;ValueType, Fmts...&gt;</code>.
In this case, note that <code>Fmt</code> is in <code>Fmts...</code> and <code>T</code> derives from <code>Fmt::template fn&lt;T&gt;</code>.</p>
</li>
<li>
<p><code>Fmt::template fn&lt;T&gt;</code> is default constructible, assuming it is well-formed.</p>
</li>
<li>
<p><code>Fmt::template fn&lt;T&gt;</code> can be constructed from <code>const Fmt::template fn&lt;U&gt;&amp;</code>,
if both are well-formed.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="alignment_format_specifier">2.3. <em>FormatSpecifier</em> <code>alignment_format_specifier</code></h3>
<div class="paragraph">
<p>The <em>FormatSpecifier</em> defines the following format functions:</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<colgroup>
<col style="width: 38.2%;">
<col style="width: 61.8%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Format functions</th>
<th class="tableblock halign-left valign-top">Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operator&lt;(<a href="#width_t">width_t</a> <em>width</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aligns to the left ( Or to the right on right-to-left (RTL) scripts, like Arabic )</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operator&gt;(<a href="#width_t">width_t</a> <em>width</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aligns to the right ( Or to the left on RTL scripts )</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operator^(<a href="#width_t">width_t</a> <em>width</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Center alignment</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fill(char32_t ch)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the fill character.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>set_alignment_format(<a href="#alignment_format">alignment_format</a>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set all alignment formatting options simultaneously.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>set_alignment_format(<a href="#default_alignment_format">default_alignment_format</a>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set all alignment formatting options to default.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clear_alignment_format()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set all alignment formatting options to default.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>And the following observers:</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<colgroup>
<col style="width: 38.2%;">
<col style="width: 61.8%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Observers</th>
<th class="tableblock halign-left valign-top">Return type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>width()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#width_t">width_t</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>get_alignment_format()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>default_text_alignment</code> or <code>text_alignment</code>, depending on whether any
  alignment format function has been previously invoked.</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="text_alignment">Enumeration <code>text_alignment</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

enum class text_alignment {left, right, center};

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="alignment_format">struct <code>alignment_format</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

struct alignment_format {
    char32_t fill = U' ';
    <a href="#width_t">width_t</a> width = 0;
    text_alignment alignment = text_alignment::right;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="default_alignment_format">struct <code>default_alignment_format</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

struct default_alignment_format {
    static constexpr char32_t fill = U' ';
    static constexpr <a href="#width_t">width_t</a> width = 0;
    static constexpr <a href="#alignment_format">text_alignment</a> alignment = text_alignment::right;

    constexpr operator <a href="#alignment_format">alignment_format</a> () const noexcept
    {
        return {};
    }
};

} // namespace strf</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="int_format_specifier">2.4. <em>FormatSpecifier</em> <code>int_format_specifier</code></h3>
<div class="paragraph">
<p>This <em>FormatSpecifier</em> defines the following format functions:</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<colgroup>
<col style="width: 38.2%;">
<col style="width: 61.8%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Member function</th>
<th class="tableblock halign-left valign-top">Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bin()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses the binary base.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>oct()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses the octal base.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dec()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses the decimal base.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hex()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses the hexadecimal base.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operator*()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to the <code>'#'</code> format flag in <code>printf</code>. Only applicable in non-decimal bases.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operator+()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to the <code>'+'</code> format flag in <code>printf</code>. Only applicable in decimal base.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operator~()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>fill_sign()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fill_sign()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Similar to the <code>' '</code> format flag in <code>printf</code>:
  prints an extra fill character ( specified by some of the alignment format function )
  before non-negative numbers. Only applicable in decimal base.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>punct()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies the numeric punctuation according to the <code>numpunct_c</code> facet</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operator!()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>punct()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="int_pad0"></a> <code>pad0(int w)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inserts zeros after the sign or base indication and before the digits
  such that at least <code>w</code> characters are printed
  ( not counting the fill characters caused by alignment formatting,
   but still counting the extra fill character caused by <code>fill_sign()</code> ).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="int_precision"></a> <code>p(int precision)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inserts zeros after the sign or base indication and before the digits
  such that at least <code>precision</code> digits are printed</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>set_int_format(<a href="#int_format">int_format</a>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set all integers formatting options simultaneously.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>set_int_format(<a href="#default_int_format">default_int_format</a>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reset all integers formatting options to default.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>And the following observer:</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<colgroup>
<col style="width: 38.2%;">
<col style="width: 61.8%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Observer</th>
<th class="tableblock halign-left valign-top">Return type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>get_int_format()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int_format</code>, <code>default_int_format</code> or an implementation-defined <em>IntFormat</em> type.</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="IntFormat">Type requirements <em>IntFormat</em></h4>
<div class="paragraph">
<p>Given:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>F</code>, a <em>InttFormat</em> type</p>
</li>
<li>
<p><code>f</code>, a value of type <code>F</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must hold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>F</code> is copy-constructible</p>
</li>
<li>
<p><code>F</code> is convertible to <code><a href="#int_format">int_format</a></code></p>
</li>
<li>
<p><code>F</code> has public member variables below:</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 19.1%;">
<col style="width: 19.1%;">
<col style="width: 61.8%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Member</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Semantics / effect</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>f.base</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Numeric base ( must be euqal to <code>2</code>, <code>8</code>, <code>10</code> or <code>16</code> )</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>f.precision</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code><a href="#int_precision">p</a></code> format function.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>f.pad0wdith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See <code><a href="#int_pad0">pad0</a></code> format function.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>f.sign</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>showsign</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See enumeration <code><a href="#showsign">showsign</a></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>f.showbase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to the <code>'#'</code> format flag in printf</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>f.punctuate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Activates numeric punctuation.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="int_format">Struct template <code>int_format</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

struct int_format {
    int base = 10;
    int precision = 0;
    int pad0width = 0;
    showsign sign = <a href="#showsign">showsign</a>::negative_only;
    bool showbase = false;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="default_int_format">Struct template <code>default_int_format</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {


struct default_int_format {
    constexpr static int base = 10;
    constexpr static int precision = 0;
    constexpr static int pad0width = 0;
    constexpr static strf::showsign sign = strf::showsign::negative_only;
    constexpr static bool showbase = false;
    constexpr static bool punctuate = false;

    constexpr operator <a href="#int_format">int_format</a> () const
    {
        return {};
    }
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="showsign">Enumeration <code>showsign</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

enum class showsign {
    negative_only = &#8230;&#8203;, positive_also = &#8230;&#8203;, fill_instead_of_positive = &#8230;&#8203;
};

} // namespace strf</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>showsign::negative_only</code></dt>
<dd>
<p>A sign is printed only before negative numbers.</p>
</dd>
<dt class="hdlist1"><code>showsign::positive_also</code></dt>
<dd>
<p>Negatives numbers are prefixed with <code>'-'</code> and
non-negatives number are prefixed with <code>'+'</code>.</p>
</dd>
<dt class="hdlist1"><code>showsign::fill_instead_of_positive</code></dt>
<dd>
<p>Negatives numbers are prefixed with <code>'-'</code> and
non-negatives number are prefixed with the fill character
( from alignment formatting ).</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="float_format_specifier">2.5. <em>FormatSpecifier</em> <code>float_format_specifier</code></h3>
<div class="paragraph">
<p>The <code>float_format_specifier</code> <em>FormatSpecifier</em> defines the following format functions:</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<colgroup>
<col style="width: 38.2%;">
<col style="width: 61.8%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Member function</th>
<th class="tableblock halign-left valign-top">Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operator*()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to the <code>'#'</code> format flag in <code>printf</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operator+()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to the <code>'+'</code> format flag in <code>printf</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fill_sign()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Similar to the <code>' '</code> format flag in <code>printf</code>:
  prints an extra fill character ( from the alignment formatting )
  before non-negative numbers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operator~()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>fill_sign()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>punct()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Applies the numeric punctuation according to the <code>numpunct_c</code> facet</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operator!()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>punct()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="float_pad0"></a> <code>pad0(int w)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Similar to the <code>'0'</code> format flag in <code>printf</code>:</p>
<p class="tableblock">For NaN and infinity, causes the the width ( from alignment
formatting ) to be at least equal to <code>w</code>.</p>
<p class="tableblock">For valid numbers, prints zeros after the sign and the base
indication and before the digits such that at least <code>w</code> characters
are printed ( not counting the fill characters caused by alignment formatting,
but still counting the extra fill character caused by <code>fill_sign()</code> ).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>p(int precision)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the precision. Effect varies according to the notation ( see below ).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="set_float_notation"></a><code>set_float_notation(<a href="#float_notation">float_notation</a>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sets the float notation ( see <a href="#float_notation">below</a> ).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hex()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>set_float_notation(float_notation::hex)</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fixed()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>set_float_notation(float_notation::fixed)</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sci()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>set_float_notation(float_notation::scientific)</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>gen()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to <code>set_float_notation(float_notation::general)</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>set_float_format(<a href="#float_format">float_format</a>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set all floating-point formatting options simultaneously.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>set_float_format(<a href="#default_float_format">default_float_format</a>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reset all floating-point formatting options to default.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>And the following observers:</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<colgroup>
<col style="width: 38.2%;">
<col style="width: 61.8%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Observer</th>
<th class="tableblock halign-left valign-top">Return type</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>get_float_format()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#float_format">float_format</a></code>, <code>{default_float_format}</code> or an implementation-defined type that
  sastisfies <em><a href="#FloatFormat">FloatFormat</a></em> requirements.</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="float_notation">Enumeration <code>float_notation</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
enum class float_notation {fixed, scientific, general, hex};
};</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>float_notation::hex</code></dt>
<dd>
<p>Hexadecimal</p>
</dd>
<dt class="hdlist1"><code>float_notation::fixed</code></dt>
<dd>
<p>If precision is not set, prints the smallest number of digits
such that the floating-point value can be exactly recovered.
If precision is set, it is the number of fractional digits.</p>
</dd>
<dt class="hdlist1"><code>float_notation::scientific</code></dt>
<dd>
<p>If precision is not set, prints the smallest number of digits
such that the floating-point value can be exactly recovered.
If precision is set, it is the number of fractional digits.</p>
</dd>
<dt class="hdlist1"><code>float_notation::general</code></dt>
<dd>
<p>If precision is not set, chooses the notation ( scientific or fixed ) that leads
to the smallest number or characters such that the floating-point value
can be exactly recovered.
   <br>
If precision is set, same effect as the <code>'g'</code> format flags in <code>printf</code>
( except that the lettercase is specified by the
<a href="#lettercase">lettercase</a> facet ):</p>
<div class="ulist">
<ul>
<li>
<p>The precision is the number of significant digts</p>
</li>
<li>
<p>If precision is 0, it is treated as 1</p>
</li>
<li>
<p>Trailing fractional zeros are removed unless <code>operator*</code> is used.</p>
</li>
<li>
<p>Selects the scientific notation iff the resulting exponent
is less than -4 or greater than or equal to the precision</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="FloatFormat">Type requirements <em>FloatFormat</em></h4>
<div class="paragraph">
<p>Given:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>F</code>, a <em>FloatFormat</em> type</p>
</li>
<li>
<p><code>f</code>, a value of type <code>F</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must hold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>F</code> is copy-constructible</p>
</li>
<li>
<p><code>F</code> is convertible to <code><a href="#float_format">float_format</a></code></p>
</li>
<li>
<p><code>F</code> has public member variables below:</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 19.1%;">
<col style="width: 19.1%;">
<col style="width: 61.8%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Member</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Semantics / effect</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>f.precision</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Floating-point precision. When negative, then precision is considered as not specified, which means that the number or significant digits is such that the value can be fully recovered by a parser. Otherwise, the effect depends on <code>notation</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>f.pad0wdith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>int</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Same as of format function <code><a href="#float_pad0">pad0</a></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>f.notation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="#float_notation">float_notation</a></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See enumeration <code><a href="#float_notation">float_notation</a></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>f.sign</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>showsign</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">See enumeration <code><a href="#showsign">showsign</a></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>f.showpoint</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equivalent to the <code>'#'</code> format flag in printf</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>f.punctuate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bool</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Activates numeric punctuation.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="float_format">Struct template <code>float_format</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

enum class float_notation {fixed, scientific, general, hex};

struct float_format
{
    int precision = -1;
    int pad0width = 0;
    float_notation notation = float_notation::general
    <a href="#showsign">showsign</a> sign = showsign::negative_only;
    bool showpoint = false;
    bool showpos = false;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="default_float_format">Struct template <code>default_float_format</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

struct default_float_format
{
    constexpr static int precision = -1;
    constexpr static int pad0width = 0;
    constexpr static <a href="#float_notation">float_notation</a> notation = <a href="#float_notation">float_notation</a>::general;
    constexpr static <a href="#showsign">showsign</a> sign = <a href="#showsign">showsign</a>::negative_only;
    constexpr static bool showpoint = false;
    constexpr static bool punctuate = false;

    constexpr operator float_format () const noexcept;
};
} // namespace strf</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="quantity_format_specifier">2.6. <em>FormatSpecifier</em> <code>quantity_format_specifier</code></h3>
<div class="paragraph">
<p>The <code>quantity_format_specifier</code> <em>FormatSpecifier</em> defines the following format functions:</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<colgroup>
<col style="width: 38.2%;">
<col style="width: 61.8%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Member function</th>
<th class="tableblock halign-left valign-top">Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>multi(std::integral auto count)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Causes the content to be printed <code>count</code> consecutives times</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>And the following observers:</p>
</div>
<table class="tableblock frame-all grid-rows stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Observer</th>
<th class="tableblock halign-left valign-top">Return type</th>
<th class="tableblock halign-left valign-top">Return value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>count()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::size_t</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scount()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>std::ptrdiff_t</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(std::ptrdiff_t) count()</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="string_precision_format_function">2.7. String precision</h3>
<div class="paragraph">
<p>( The <em>FormatSpecifier</em> that defines the function below is implementation-defined )</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>p(<a href="#width_t">width_t</a> limit)</code></dt>
<dd>
<p>Prints the whole string only if its width is not greater than <code>limit</code>.
Otherwise, prints its longest leading sub-string whose width
is not greater than <code>limit</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="transcoding_format_functions">2.8. Transcoding format functions</h3>
<div class="paragraph">
<p>( The <em>FormatSpecifier</em> that defines the functions below is implementation-defined )</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
transcode(Charset cs)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Transcodes the input string if <code>cs</code> is different from the
output charset, otherwise just copies it as in <code>memcpy</code>.
( The output charset is defined by the facet value
of the <code>{charset_c}&lt;CharOut&gt;</code> facet category,
where <code>CharOut</code> is the destination character type )</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
unsafe_transcode(Charset cs)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Same as in <code>trancode(cs)</code>, except that the behaviour is
undefined if the input string is not fully conformant
to the encoding represent by <code>cs</code>,
but it provides a better performance.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
sani(Charset cs)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>cs</code> is different from the ouput charset, transcodes the
input string just like in <code>transcode</code>. If they
are the same, sanitizes the input string.
That is, in both cases, any non-conformity to the input charset
is replaced by the replacement character ( <code>"\uFFFD"</code> or <code>'?'</code> ),
and causes the function
<code><a href="#transcoding_error_notifier">transcoding_error_notifier</a>::invalid_sequence</code>
to be called, if the <em><a href="#TranscodingErrorNotifierPtr">TranscodingErrorNotifierPtr</a></em>
facet object is not null.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">transcode()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>transcode(cs)</code> where <code>cs</code> is the facet value
for the <code>charset_c&lt;CharIn&gt;</code> facet category, where <code>CharIn</code>
is the character type of the input string.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">unsafe_transcode()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>unsafe_transcode(cs)</code> where <code>cs</code> is the facet value
for the <code>charset_c&lt;CharIn&gt;</code> facet category, where <code>CharIn</code>
is the character type of the input string.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">sani()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>sani(cs)</code> where <code>cs</code> is the facet value
for the <code>charset_c&lt;CharIn&gt;</code> facet category, where <code>CharIn</code>
is the character type of the input string.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto str = strf::to_string(strf::center(u" Hello! ", 16, '*').transcode());
assert(str == "**** Hello! ****");</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fmt">2.9. Callable object <code>fmt</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename T&gt;
using fmt_value_type = typename <a href="#fmt_type">fmt_type</a>&lt;T&gt;::value_type;

constexpr struct /*&#8230;&#8203;*/ {
    template &lt;typename T&gt;
    constexpr /*&#8230;&#8203;*/  operator()(T&amp;&amp; value) const;
} fmt;

} // namespace strf</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_member_function">Member function</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr /* see below...*/ operator()(T&amp;&amp; value) const;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>value</code>, if <code>std::remove_cvref_t&lt;T&gt;</code> is an instance of <code><a href="#value_and_format">value_and_format</a></code></p>
</li>
<li>
<p><code><a href="#fmt_type">fmt_type</a>&lt;T&gt;{ fmt_value_type&lt;T&gt;{ (T&amp;&amp;)value } }</code>, otherwise</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Return type</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>T&amp;&amp;</code>, if <code>std::remove_cvref&lt;T&gt;</code> is an instance of <code>value_and_format</code></p>
</li>
<li>
<p><code><a href="#fmt_type">fmt_type</a>&lt;T&gt;</code>, otherwise</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fmt_type">2.10. Type alias template <code>fmt_type</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename T&gt;
using fmt_type = /*&#8230;&#8203;*/;

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fmt_type&lt;T&gt;</code> is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>fmt_type&lt;T&gt;</code>, if <code>T</code> is a reference or has any cv-qualifier</p>
</li>
<li>
<p>otherwise, it is <code>T</code>, if <code>T</code> is an instance of <code><a href="#value_and_format">value_and_format</a></code></p>
</li>
<li>
<p>otherwise, it is <code><a href="#value_and_format">value_and_format</a>&lt;PrintableDef, Fmts...&gt;</code>, where:</p>
<div class="ulist">
<ul>
<li>
<p><code>PDef</code> is <code><a href="#printable_def_of">printable_def_of</a>&lt;T&gt;</code></p>
</li>
<li>
<p><code>Fmts...</code> is template paramenter pack used to define
<code>PrintableDef::<a href="#PrintableDef_format_specifiers">format_specifiers</a></code> (
 as a type alias to <code><a href="#tag">tag</a>&lt;Fmt...&gt;</code> ).</p>
<div class="ulist">
<ul>
<li>
<p>If <code>PrintableDef::format_specifiers</code> is not defined, <code>T</code> is <code><a href="#value_and_format">value_and_format</a>&lt;PrintableDef&gt;</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="value_and_format">2.11. Class template <code>value_and_format</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename PrintableDef, class... Fmts&gt;
class value_and_format;

} // namespace strf</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>PrintableDef</code> satisfies <em><a href="#PrintableDef">PrintableDef</a></em>.</p>
</li>
<li>
<p>All types in <code>Fmt...</code> satisfy <em><a href="#FormatSpecifier">FormatSpecifier</a></em>.</p>
</li>
<li>
<p>All types in <code>Fmt...</code> are different.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_synopsis">Synopsis</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename PrintableDef, class... Fmts&gt;
class value_and_format
    : public Fmts::template fn&lt;value_and_format&lt;ValueType, Fmts...&gt;&gt;...
{
public:
    using printable_def = PrintableDef;
    using value_type = typename PrintableDef::forwarded_type;

    constexpr explicit <a href="#value_and_format_v">value_and_format</a>(const value_type&amp; v);

    template &lt;typename... OtherFmts&gt;
    constexpr explicit <a href="#value_and_format_vaf2">value_and_format</a>
        ( const value_and_format&lt;PrintableDef, OtherFmts...&gt;&amp; f );

    template &lt;typename... OtherFmts&gt;
    constexpr explicit <a href="#value_and_format_vaf2_rr">value_and_format</a>
        ( value_and_format&lt;PrintableDef, OtherFmts...&gt;&amp;&amp; f );

    template &lt;typename OtherPrintableDef&gt;
    constexpr <a href="#value_and_format_v_v2wf">value_and_format</a>
        ( const value_type&amp; v
        , const value_and_format&lt;OtherPrintableDef, Fmts...&gt;&amp; f );

    template &lt;typename OtherPrintableDef&gt;
    constexpr <a href="#value_and_format_v_v2wf_rr">value_and_format</a>
        ( const value_type&amp; v
        , value_and_format&lt;OtherPrintableDef, Fmts...&gt;&amp;&amp; f );

    template &lt;typename... F, typename... FInit&gt;
    constexpr <a href="#value_and_format_v_t_i">value_and_format</a>
        ( const value_type&amp; v
        , <a href="#tag">tag</a>&lt;F...&gt;
        , FInit&amp;&amp;... finit );

    template
        &lt; typename OtherPrintableDef
        , typename... OtherFmts
        , typename Fmt
        , typename... FmtInitArgs &gt;
    constexpr <a href="#value_and_format_vaf2_t_i">value_and_format</a>
        ( const value_and_format&lt;PrintableDef, OtherFmts...&gt;&amp; other
        , <a href="#tag">tag</a>&lt;Fmt&gt;
        , FmtInitArgs&amp;&amp;... fmt_init );

    constexpr const value_type&amp; value() const;

    constexpr value_type&amp; value();

private:

    value_type value_; // exposition only
};

} // namespace strf</code></pre>
</div>
</div>
<div id="value_and_format_v" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr value_and_format(const value_type&amp; v);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializes <code>value_</code> with <code>v</code></p>
</li>
<li>
<p>Default initializes all public base class subobjects</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="value_and_format_vaf2" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename... OtherFmts&gt;
constexpr explicit value_and_format
    ( const value_and_format&lt;PrintableDef, OtherFmts...&gt;&amp; f );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializes <code>value_</code> with <code>f.value()</code></p>
</li>
<li>
<p>Initializes each public base class subobjects with the corresponding base class subobject of <code>f</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="value_and_format_vaf2_rr" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename... OtherFmts&gt;
constexpr explicit value_and_format
    ( value_and_format&lt;PrintableDef, OtherFmts...&gt;&amp;&amp; f );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializes <code>value_</code> with <code>static_cast&lt;value_type&amp;&amp;&gt;(f.value())</code></p>
</li>
<li>
<p>Initializes each public base class subobjects <code>b</code> with <code>std::move(bf)</code>, where <code>bf</code>
is the base class subobjects in <code>f</code> that corresponds to <code>b</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="value_and_format_v_v2wf" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename OtherPrintableDef&gt;
constexpr value_and_format
    ( const value_type&amp; v
    , const value_and_format&lt;OtherPrintableDef, Fmts...&gt;&amp; f );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializes <code>value_</code> with <code>v</code></p>
</li>
<li>
<p>Initializes each public base class subobjects with the corresponding base class subobject of <code>f</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="value_and_format_v_v2wf_rr" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename OtherPrintableDef&gt;
constexpr value_and_format
    ( const value_type&amp; v
    , value_and_format&lt;OtherPrintableDef, Fmts...&gt;&amp;&amp; f );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializes <code>value_</code> with <code>v</code></p>
</li>
<li>
<p>Initializes each public base class subobjects <code>b</code> with <code>std::move(bf)</code>, where <code>bf</code>
is the base class subobjects in <code>f</code> that corresponds to <code>b</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="value_and_format_v_t_i" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename... F, typename... FInit&gt;
constexpr value_and_format
    ( const value_type&amp; v
    , <a href="#tag">tag</a>&lt;F...&gt;
    , FInit&amp;&amp;... finit );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>sizeof...(F) == sizeof...(FInit)</code></p>
</li>
<li>
<p>There is no repeated type in <code>F...</code></p>
</li>
<li>
<p>All types in <code>F...</code> are also in <code>Fmts...</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effects</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializes <code>value_</code> with <code>v</code></p>
</li>
<li>
<p>For each type in <code>F...</code>, initializes the corresponding public base class subobjects
with the corresponging value in <code>std::forward&lt;FInit&gt;(finit)...</code></p>
</li>
<li>
<p>Default initializes the remaining public base class subobjects</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="value_and_format_vaf2_t_i" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template
    &lt; typename OtherPrintableDef
    , typename... OtherFmts
    , typename Fmt
    , typename... FmtInitArgs &gt;
template &lt;typename Fmt, typename FmtInit, typename... OtherFmts&gt;
constexpr value_and_format
    ( const value_and_format&lt;PrintableDef, OtherFmts...&gt;&amp; other
    , <a href="#tag">tag</a>&lt;Fmt&gt;
    , FmtInitArgs&amp;&amp;... args );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>Fmt</code> is one the types in <code>Fmts...</code></p>
</li>
<li>
<p><code>sizeof...(OtherFmts) == sizeof...(Fmts)</code> is true</p>
</li>
<li>
<p><code>value_type</code> must be constructible from <code>object.value()</code></p>
</li>
<li>
<p>Each public base class of this type, except the one that corresponds to <code>Fmt</code>,
must be constructible from a const lvalue reference of the corresponding
base sub-object of <code>other</code> ( the type first in <code>Fmts&#8230;&#8203;</code> corresponds to the first
in `OtherFmt&#8230;&#8203;, the second to the second and so on ).</p>
</li>
<li>
<p><code>Fmt</code> must be contructible from <code>FmtInitArgs&amp;&amp;...</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effects</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializes <code>value_</code> with <code>other.value()</code></p>
</li>
<li>
<p>Initializes the public base class subobject that corresponds to <code>Fmt</code>
with <code>std::forward&lt;FmtInitArgs&gt;(args)...</code></p>
</li>
<li>
<p>Initializes the other public base class subobjects with the corresponding
base class subobject of <code>other</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="value_and_format_value" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr const value_type&amp; value() const;
constexpr value_type&amp; value();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns <code>value_</code></p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_numeric_punctuation">3. Numeric punctuation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="numpunct_c">3.1. Facet category template <code>numpunct_c</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
template &lt;int Base&gt; struct numpunct_c {
    constexpr static bool constrainable = true;
    static constexpr <a href="#default_numpunct">default_numpunct</a>&lt;Base&gt; get_default() noexcept;
};
} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a type to be a facet of the <code>numpunct_c&lt;Base&gt;</code>,
it must satisfy <em>NumericPuntuation</em> type requirements</p>
</div>
</div>
<div class="sect2">
<h3 id="NumericPunctuation">3.2. Type requirement <em>NumericPunctuation</em></h3>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Base</code>, an integer <code>constexpr</code> equal to <code>2</code>, <code>8</code>, <code>10</code> or <code>16</code></p>
</li>
<li>
<p><code>X</code>, a <em>NumericPunctuation</em> type for <code>Base</code></p>
</li>
<li>
<p><code>x</code>, a const value of type <code>X</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must hold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>X is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a></p>
</li>
<li>
<p><code><a href="#facet_category">facet_category</a>&lt;X&gt;</code> is a type alias to <code>numpunct_c&lt;Base&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And following expressions are well-formed and satisfy the following corresponding conditions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">static_cast&lt;<a href="#numpunct">numpunct</a>&lt;Base&gt;&gt;(x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>( <code>X</code> is explicitly convertible to <code><a href="#numpunct">numpunct</a>&lt;Base&gt;</code> )</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.grouping()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#digits_grouping">digits_grouping</a></code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.distribute(digcount)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#digits_distribution">digits_distribution</a></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>x.grouping().<a href="#digits_grouping_distribute">distribute</a>(digcount)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.any_group_separation(digcount)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>bool</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>x.grouping().<a href="#digits_grouping_any_separator">any_separator</a>(digcount)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.thousands_sep_count(digcount)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>int</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>x.grouping().<a href="#digits_grouping_separators_count">separators_count</a>(digcount)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.thousands_sep()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>char32_t</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.decimal_point()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>char32_t</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="numpunct">3.3. Class template <code>numpunct</code></h3>
<div class="paragraph">
<p><code>numpunct&lt;<em>Base</em>&gt;</code> is a facet of the <code><a href="#numpunct_c">numpunct_c</a>&lt;_Base_&gt;</code> category,
and it satisfies the requirements of <em><a href="#NumericPunctuation">NumericPunctuation</a></em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;int Base&gt;
class numpunct {
public:
    using category = <a href="#numpunct_c">numpunct_c</a>&lt;Base&gt;;

    // constructors
    constexpr <a href="#numpunct_ctor_default">numpunct</a>() noexcept;
    constexpr numpunct(const numpunct&amp; ) noexcept;

    constexpr explicit <a href="#numpunct_ctor_grouping">numpunct</a>(<a href="#digits_grouping">digits_grouping</a>) noexcept;

    template &lt;typename... IntArgs&gt;
    constexpr explicit numpunct(int grp0, IntArgs... grps) noexcept;

    // assignment
    constexpr numpunct&amp; operator=(const numpunct&amp;) noexcept;

    // comparison
    constexpr bool operator==(const numpunct&amp; other) const noexcept;
    constexpr bool operator!=(const numpunct&amp; other) const noexcept;

    // observers
    constexpr char32_t   decimal_point() const noexcept;
    constexpr char32_t   thousands_sep() const noexcept;
    constexpr <a href="#digits_grouping">digits_grouping</a> grouping() const noexcept;

    // modifiers
    constexpr numpunct&amp;  decimal_point(char32_t ch) &amp; noexcept;
    constexpr numpunct&amp;&amp; decimal_point(char32_t ch) &amp;&amp; noexcept;

    constexpr numpunct&amp;  thousands_sep(char32_t ch) &amp; noexcept;
    constexpr numpunct&amp;&amp; thousands_sep(char32_t ch) &amp;&amp; noexcept;

    // utilities
    constexpr <a href="#digits_distribution">digits_distribution</a> <a href="#numpunct_thousands_distribute">distribute</a>(int digcount) const noexcept;
    constexpr bool <a href="#numpunct_any_group_separation">any_group_separation</a>(int digcount) const noexcept;
    constexpr int <a href="#numpunct_thousands_sep_count">thousands_sep_count</a>(int digcount) const noexcept;

private:
    char32_t decimal_point_ = U'.';  // exposition only
    char32_t thousands_sep_ = U',';  // exposition only
    <a href="#digits_grouping">digits_grouping</a> grouping_;     // exposition only
};</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_public_members">Public members</h4>
<div id="numpunct_ctor_default" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr numpunct() noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>decimal_point() == U'.'</code></p>
</li>
<li>
<p><code>thousands_separator() == U','</code></p>
</li>
<li>
<p><code>grouping().empty()</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="numpunct_ctor_grouping" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr numpunct(<a href="#digits_grouping">digits_grouping</a> grpng) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>decimal_point() == U'.'</code></p>
</li>
<li>
<p><code>thousands_separator() == U','</code></p>
</li>
<li>
<p><code>grouping() == grpng</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="numpunct_ctor_intgroups" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename... IntArgs&gt;
constexpr numpunct(int grp0, IntArgs... grps) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Preconditions
</td>
<td class="hdlist2">
<p>Same as of the constructor of <code>digits_grouping</code> ( see <a href="#digits_grouping_ctor_groups">here</a> ).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>decimal_point() == U'.'</code></p>
</li>
<li>
<p><code>thousands_sep() == U','</code></p>
</li>
<li>
<p><code>grouping() == <a href="#digits_grouping">digits_grouping</a>{grp0, grps...}</code>;</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="numpunct_thousands_sep_count" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">int thousands_sep_count(int digcount) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>grouping().<a href="#digits_grouping_separators_count">separators_count</a>(digcount))</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="numpunct_thousands_distribute" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr <a href="#digits_distribution">digits_distribution</a> distribute(unsiged digcount) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>grouping().<a href="#digits_grouping_distribute">distribute</a>(digcount))</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="numpunct_any_group_separation" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">bool any_group_separation(int digcount) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>grouping().<a href="#digits_grouping_any_separator">any_separator</a>(digcount)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="numpunct_get_decimal_point" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">char32_t decimal_point() const noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns the decimal point.</p>
</div>
</div>
</div>
<div id="numpunct_get_thousands_sep" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">char32_t thousands_sep() const noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns the thousands separator.</p>
</div>
</div>
</div>
<div id="numpunct_set_decimal_point" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">numpunct &amp;  decimal_point(char32_t ch) &amp;  noexcept;
numpunct &amp;&amp; decimal_point(char32_t ch) &amp;&amp; noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Changes the decimal point to <code>ch</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postcondition
</td>
<td class="hdlist2">
<p><code>decimal_point() == ch</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>*this</code> or <code>std::move(*this)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="numpunct_set_thousands_sep" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">numpunct &amp;  thousands_sep(char32_t ch) &amp;  noexcept;
numpunct &amp;&amp; thousands_sep(char32_t ch) &amp;&amp; noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Changes the thousands separtor to <code>ch</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postcondition
</td>
<td class="hdlist2">
<p><code>thousands_sep() == ch</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>*this</code> or <code>std::move(*this)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="default_numpunct">3.4. Class template <code>default_numpunct</code></h3>
<div class="paragraph">
<p><code>default_numpunct&lt;Base&gt;</code> is the default facet of the
<code><a href="#numpunct_c">numpunct_c</a>&lt;Base&gt;</code> category.
It is an empty class, optimized to represent the default
state of <code>numpunct&lt;Base&gt;</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
template &lt;int Base&gt;
class default_numpunct: {
public:
    using category = <a href="#numpunct_c">numpunct_c</a>&lt;Base&gt;;

    constexpr default_numpunct() noexcept= default; // no-op
    constexpr default_numpunct(const default_numpunct&amp; ) noexcept = default; // no-op
    constexpr default_numpunct&amp; operator=(const default_numpunct&amp;) noexcept; // no-op
    constexpr bool operator==(const default_numpunct&amp; other) const noexcept;
    constexpr bool operator!=(const default_numpunct&amp; other) const noexcept;

    constexpr <a href="#digits_grouping">digits_grouping</a> grouping() const
    constexpr <a href="#digits_distribution">digits_distribution</a> distribute(unsiged digcount) const

    constexpr bool any_group_separation(int digcount) const noexcept;
    constexpr int thousands_sep_count(int digcount) const noexcept;

    constexpr char32_t decimal_point() const noexcept;
    constexpr char32_t thousands_sep() const noexcept;
};
} // namespace strf</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_public_members_2">Public members</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool operator==(const default_numpunct&amp; other) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>true</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool operator!=(const default_numpunct&amp; other) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>false</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr <a href="#digits_grouping">digits_grouping</a> grouping() const</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code><a href="#digits_grouping">digits_grouping</a>{}</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr <a href="#digits_distribution">digits_distribution</a> distribute(unsiged digcount) const</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code><a href="#digits_distribution">digits_distribution</a>{{}, 0, digcount}</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool any_group_separation(int digcount) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>false</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">int thousands_sep_count(int digcount) const override;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>0</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">char32_t thousands_sep() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>U','</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">char32_t decimal_point() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>U'.'</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="no_grouping">3.5. Class template <code>no_grouping</code></h3>
<div class="paragraph">
<p><code>no_grouping&lt;_Base_&gt;</code> is a facet of the <code><a href="#numpunct_c">numpunct_c</a>&lt;_Base_</code>
category. The only reason for one to use <code>no_grouping</code>
rather than <code><a href="#numpunct">numpunct</a></code> is optimization. It is not possible to
change the thousaunds separator nor the grouping in a <code>no_grouping&lt;_Base_&gt;</code>
object. It is only possible to change its decimal point.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
template &lt;int Base&gt;
class no_grouping {
public:
    using category = <a href="#numpunct_c">numpunct_c</a>&lt;Base&gt;;

    constexpr no_grouping() = default;
    constexpr no_grouping(const no_grouping&amp; ) = default;
    constexpr no_grouping&amp; operator=(const no_grouping&amp;) noexcept;
    constexpr bool operator==(const no_grouping&amp; other) const noexcept;
    constexpr bool operator!=(const no_grouping&amp; other) const noexcept;

    constexpr <a href="#digits_grouping">digits_grouping</a> grouping() const
    constexpr <a href="#digits_distribution">digits_distribution</a> distribute(unsiged digcount) const

    constexpr bool any_group_separation(int digcount) const noexcept;
    constexpr int thousands_sep_count(int digcount) const noexcept;

    constexpr char32_t   decimal_point() const noexcept;
    constexpr no_grouping&amp;  decimal_point(char32_t ch) &amp; noexcept;
    constexpr no_grouping&amp;&amp; decimal_point(char32_t ch) &amp;&amp; noexcept;

    constexpr char32_t   thousands_sep() const noexcept;

private:
    char32_t decimal_point_ = U'.';  // exposition only
};

} // namespace strf</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_public_members_3">Public members</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool operator==(const no_grouping&amp; other) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>decimal_point() == other.decimal_point()</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool operator!=(const no_grouping&amp; other) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>decimal_point() != other.decimal_point()</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr <a href="#digits_grouping">digits_grouping</a> grouping() const</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code><a href="#digits_grouping">digits_grouping</a>{}</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr <a href="#digits_distribution">digits_distribution</a> distribute(unsiged digcount) const</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code><a href="#digits_distribution">digits_distribution</a>{{}, 0, digcount}</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool any_group_separation(int digcount) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>false</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">int thousands_sep_count(int digcount) const override;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>0</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">int thousands_sep_count(int digcount) const override;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>0</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">char32_t thousands_sep() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>U','</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">char32_t decimal_point() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">no_grouping &amp;  decimal_point(char32_t ch) &amp;  noexcept;
no_grouping &amp;&amp; decimal_point(char32_t ch) &amp;&amp; noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Changes the decimal point to <code>ch</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postcondition
</td>
<td class="hdlist2">
<p><code>decimal_point() == ch</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>*this</code> or <code>std::move(*this)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="digits_grouping">3.6. Class <code>digits_grouping</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
class digits_grouping {
public:
    constexpr static int grp_max = 31;
    constexpr static int grps_count_max = 6;

    // constructors
    constexpr <a href="#digits_grouping_default_ctor">digits_grouping</a>() noexcept;
    constexpr digits_grouping(const digits_grouping&amp;) noexcept;

    template &lt;typename... IntArgs&gt;
    constexpr explicit <a href="#digits_grouping_ctor_groups">digits_grouping</a>(int grp0, IntArgs... grps) noexcept;

    explicit <a href="#digits_grouping_ctor_str">digits_grouping</a>(const char* str) noexcept;

    // assignment
    constexpr digits_grouping&amp; operator=(const digits_grouping&amp;) noexcept;

    // comparison
    constexpr bool operator==(const digits_grouping&amp;) const noexcept;
    constexpr bool operator!=(const digits_grouping&amp;) const noexcept;

    // observers and utilities
    constexpr bool <a href="#digits_grouping_empty">empty</a>() const noexcept;
    constexpr bool <a href="#digits_grouping_any_separator">any_separator</a>(int digcount) const noexcept;
    constexpr int <a href="#digits_grouping_separators_count">separators_count</a>(int digcount) const noexcept;
    constexpr <a href="#digits_grouping_iterator">digits_grouping_iterator</a> get_iterator() const noexcept;
    constexpr <a href="#digits_distribution">digits_distribution</a> distribute(int digcount) const noexcept;
};
} // namespace strf</code></pre>
</div>
</div>
<div id="digits_grouping_default_ctor" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr explicit digits_grouping() noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>digits_grouping(-1)</code></p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postcondition
</td>
<td class="hdlist2">
<p><code><a href="#digits_grouping_empty">empty()</a></code> returns <code>true</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="digits_grouping_ctor_groups" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename... IntArgs&gt;
constexpr explicit digits_grouping(int grp0, IntArgs... grps) noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specifies the groups from the least significant ( first argument ) to the most significant.
If the last argument is <code>-1</code>, then the last group ( second-to-last argument ) is not to be repeated.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All arguments are convertible to <code>int</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Preconditions</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The value <code>g</code> of last argument is such that <code>g == -1 || (0 &lt; g &amp;&amp; g &lt;= <a href="#digits_grouping">grp_max</a>)</code> is <code>true</code>.</p>
</li>
<li>
<p>The value <code>g</code> of any argument but the last is such that <code>(0 &lt; g &amp;&amp; g &lt;= <a href="#digits_grouping">grp_max</a>)</code> is <code>true</code>.</p>
</li>
<li>
<p>The number of groups ( not counting the last argument if it&#8217;s <code>-1</code> ) is not greater than <code><a href="#digits_grouping">grps_count_max</a></code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="digits_grouping_ctor_str" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">dexplicit igits_grouping(const char* str) noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The characters in <code>str</code> specify the groups, starting from the least significant one.
If the last character is <code>'\xFF'</code>, then the last group is not repeated.
Passing the empty string (<code>""</code>) has the same effect as passing as <code>"\xFF"</code>, which has the same effect of the default constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>str != nullptr</code></p>
</li>
<li>
<p><code>str</code> is a null terminated string</p>
</li>
<li>
<p>For each character <code>ch</code> in <code>str</code> that is not the last character, <code>0 &lt; ch &amp;&amp; ch &lt;= <a href="#digits_grouping">grp_max</a></code> is <code>true</code></p>
</li>
<li>
<p>If <code>ch</code> is the last character <code>str</code>, then <code>ch == '\xFF' || (0 &lt; ch &amp;&amp; ch &lt;= <a href="#digits_grouping">grp_max</a>)</code> is <code>true</code></p>
</li>
<li>
<p>The number of groups ( not counting the last character if it is <code>'\xFF'</code> )
must not be greater than <code><a href="#digits_grouping">grps_count_max</a></code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="digits_grouping_empty" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool empty() const noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>empty()</code> return <code>true</code>, then there is no group. This means that
the thousands separator is absent regardless of the number of
digits.</p>
</div>
</div>
</div>
<div id="digits_grouping_any_separator" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool any_separator(int digcount) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>separators_count(digcount) != 0</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="digits_grouping_separators_count" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr int separators_count(int digcount) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The quantity of thousands separators that would appear
in <code>digcount</code> digits.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="digits_grouping_get_iterator" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr <a href="#digits_grouping_iterator">digits_grouping_iterator</a> get_iterator() const noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a <code><a href="#digits_grouping_iterator">digits_grouping_iterator</a></code> from this object.
It is supposed to be used when the digits
are to be written backwards, <em>i.e.</em> from the the least to the
most significant.</p>
</div>
</div>
</div>
<div id="digits_grouping_distribute" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr <a href="#digits_distribution">digits_distribution</a> distribute(int digcount) const noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Constructs a <code><a href="#digits_distribution">digits_distribution</a></code> from this object.
It is supposed to be used when the digits
are to be written forwards, <em>i.e.</em> from the the most to the
least significant.</p>
</div>
<div class="paragraph">
<p><code>digcount</code> is the quantity of digits.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Precondition</dt>
<dd>
<p><code>digcount &gt; 0</code></p>
</dd>
<dt class="hdlist1">Postconditions</dt>
<dd>
<p>The return value <code>dist</code> is such that</p>
<div class="ulist">
<ul>
<li>
<p><code>dist.highest_group &gt; 0</code></p>
</li>
<li>
<p>if <code>dist.<a href="#digits_distribution">middle_groups_count</a></code> is not <code>0</code>, then <code>dist.low_groups.empty()</code> is <code>false</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="digits_grouping_creator">3.7. Class <code>digits_grouping_creator</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
class digits_grouping_creator {
public:
    constexpr digits_grouping_creator() noexcept = default;
    constexpr digits_grouping_creator(const digits_grouping_creator&amp;) noexcept = delete;
    constexpr void push_high(int grp) noexcept;
    constexpr void push_high(int grp) noexcept;
    constexpr bool failed() const noexcept;
    constexpr <a href="#digits_grouping">digits_grouping</a> finish_no_more_sep() noexcept;
    constexpr <a href="#digits_grouping">digits_grouping</a> finish() noexcept;
};
} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes it is not easy instantiate to <code><a href="#digits_grouping">digits_grouping</a></code> through
one of its constructors, since it requires you to pass all groups at once.
So <code>digits_grouping_creator</code> provides an alternative and iterative way:
each group is passed one-by-one to <code>push_high</code> function,
from the least to the most significant.
After all groups are passed, <code>finish()</code> or <code>finish_no_more_sep()</code>
shall be called to create the resulting <code>digits_grouping</code> object.
<code>finish()</code> is used when the last group is supposed to be repeated,
while <code>finish_no_more_sep()</code> is for the opposite case.
Calling <code>push_high()</code> after that has undefined behaviour.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">strf::digits_grouping_creator creator;
creator.push_high(1);
creator.push_high(2);
creator.push_high(3);
assert(creator.finish() == strf::digits_grouping(1, 2, 3));</code></pre>
</div>
</div>
<div class="paragraph">
<p>If something wrong happens ( <code>push_high</code> called more than
<code>digits_grouping::grps_count_max</code>, or with an invalid argument
( 0 or greater than <code><a href="#digits_grouping">digits_grouping</a>::grp_max</code> ) )
, the return value of <code>failed()</code> becames <code>true</code>, and the return
value of <code>finish()</code> and <code>finish_no_more_sep()</code> becames <code><a href="#digits_grouping">digits_grouping</a>{}</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="digits_grouping_iterator">3.8. Class <code>digits_grouping_iterator</code></h3>
<div class="paragraph">
<p>This class provides a way to iterate through the groups of a <code><a href="#digits_grouping">digits_grouping</a></code>
object, from the least to the most significant.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
class digits_grouping_iterator {
public:
    // constructors
    digits_grouping_iterator() = delete;
    constexpr digits_grouping_iterator(const digits_grouping_iterator&amp;) noexcept = default;
    constexpr explicit digits_grouping_iterator(<a href="#digits_grouping">digits_grouping</a>) noexcept;

    // assignment
    constexpr digits_grouping_iterator&amp; operator=(const digits_grouping_iterator&amp;) noexcept;

    // comparison
    constexpr bool operator==(const digits_grouping_iterator&amp;) const noexcept;
    constexpr bool operator!=(const digits_grouping_iterator&amp;) const noexcept;

    // iteration
    constexpr int current() const noexcept;
    constexpr void advance() noexcept;
    constexpr bool is_last() const noexcept;
    constexpr bool shall_repeat_current() const noexcept;
    constexpr bool is_final() const noexcept;
    constexpr bool ended() const noexcept;
};
} // namespace strf</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr int current() noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns the current group.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Precondition
</td>
<td class="hdlist2">
<p><code>ended()</code> returns <code>false</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr void advance() noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Moves to the next (more significant) group.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Precondition
</td>
<td class="hdlist2">
<p><code>ended()</code> returns <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p>If the return value of <code>is_last()</code> is <code>true</code>, then it becames <code>false</code>
and return value of <code>ended()</code> becames <code>true</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool is_last() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>true</code> is this is the last group.
It is equall to <code>is_final() || shall_repaete_current()</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool shall_repated_current() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>true</code> is this is the last group and it shall be repeated.
It is equall to <code>(is_last() &amp;&amp; ! is_final())</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool is_final() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>true</code> is this is the last group and it shall not be repeated.
It is equall to <code>(is_last() &amp;&amp; ! shall_repeat_current())</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool ended() const noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns <code>true</code> when there is no group left.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">strf::digits_grouping grouping{1, 2, 3};
strf::digits_grouping_iterator it = grouping.get_iterator();

assert(it.current() == 1 &amp;&amp; ! it.is_last());
it.advance();
assert(it.current() == 2 &amp;&amp; ! it.is_last());
it.advance();
assert(it.current() == 3 &amp;&amp; it.shall_repeat_current());
it.advance();
assert(it.ended());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">strf::digits_grouping grouping{1, 2, 3, -1};
strf::digits_grouping_iterator it = grouping.get_iterator();

assert(it.current() == 1 &amp;&amp; ! it.is_last());
it.advance();
assert(it.current() == 2 &amp;&amp; ! it.is_last());
it.advance();
assert(it.current() == 3 &amp;&amp; it.is_final());
it.advance();
assert(it.ended());</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">strf::digits_grouping grouping{};
strf::digits_grouping_iterator it = grouping.get_iterator();
assert(it.ended());</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="digits_distribution">3.9. Class <code>digits_distribution</code></h3>
<div class="paragraph">
<p>This struct is designed to be used in algoritms that
print groups of digits separated by the <em>thousands separator</em>
from the most to the least significant.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
struct digits_distribution {
    <a href="#reverse_digits_groups">reverse_digits_groups</a> low_groups;
    int middle_groups_count;
    int highest_group;
};
} // namespace strf</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>highest_group</code> is the most significant group.</p>
</li>
<li>
<p><code>low_groups</code> contains the least signficant groups.</p>
</li>
<li>
<p><code>middle_groups_count</code> how many groups equal to <code>low_groups.highest_groups()</code> follow the highest group.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">strf::numpunct&lt;<em>Base</em>&gt; punct = &#8230;&#8203;;
strf::digits_distribution dist = punct.distribute(<em>digits_count</em>);
assert(dist.highest_groups != 0);

// step 1
&#8230;&#8203; // print the most significant dist.highest_group digits

// step 2 - print middle groups
if (dist.middle_groups_count) {
    auto mg = dist.low_groups.highest_group();
    dist.low_groups.pop_high();
    do {
        &#8230;&#8203; // print the separator, then mg digits
    } while (--dist.middle_groups_count);
}

// step 3 - least significant groups
while( ! dist.low_groups.empty()) {
    auto g = dist.low_groups.highest_group();
    dist.low_groups.pop_high();

    &#8230;&#8203; // prints the separator, then g digits
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reverse_digits_groups">3.10. Class <code>reverse_digits_groups</code></h3>
<div class="paragraph">
<p>The class <code>reverse_digits_groups</code> aims to be used in loops that
print groups of digits separated by the thousand separator from
the most to the least significant.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
class reverse_digits_groups {
public:
    constexpr static int grp_max = <a href="#digits_grouping">digits_grouping</a>::<a href="#digits_grouping">grp_max</a>;
    constexpr static int grps_count_max = <a href="#digits_grouping">digits_grouping</a>::<a href="#digits_grouping">grps_count_max</a>;

    constexpr reverse_digits_groups() noexcept;
    constexpr reverse_digits_groups(const reverse_digits_groups&amp;) noexcept;
    constexpr bool operator==(const reverse_digits_groups&amp; other) const noexcept;
    constexpr bool operator!=(const reverse_digits_groups&amp; other) const noexcept;
    constexpr reverse_digits_groups&amp; operator=(const reverse_digits_groups&amp; other) noexcept;
    constexpr void push_low(int group) noexcept;
    constexpr void pop_high() noexcept;
    constexpr int highest_group() const noexcept;
    constexpr bool empty() const noexcept;
};
} // namespace strf</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The meaning of "group" used in <code><a href="#reverse_digits_groups">reverse_digits_groups</a></code>
is different than in previous classes.</p>
</div>
<div class="paragraph">
<p>The value returned by <code><a href="#reverse_digits_groups">reverse_digits_groups</a>::highest_group()</code>
is expected to always be the actual number of digits in the group.
This why you prior need to pass the total number of digits to
<code>digits_distribution::<a href="#digits_grouping_distribute">distribute</a></code>
function: so that it can calculate how many digits actually
go in each group.</p>
</div>
<div class="paragraph">
<p>On the other hand, there is no similar need when you create a
<code><a href="#digits_grouping_iterator">digits_grouping_iterator</a></code> object (
<code>digits_distribution::<a href="#digits_grouping_iterator">iterator</a></code> has
no parameter ). So the value returned by
<code><a href="#digits_grouping_iterator">digits_grouping_iterator</a>::lowers_group()</code> may actually
be larger than the amount of remaining digits to print.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr int highest_group() const noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return the actual number of digits in the current group.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Postconditions</dt>
<dd>
<p>The return value is zero when <code>empty()</code> returns <code>true</code>. Otherwise, it is non-zero
and not greater than <code><a href="#digits_grouping">grp_max</a></code>;</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr void pop_high() noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<p>None when <code>empty()</code> returns <code>true</code>. Otherwise, moves the return value of <code>highest_group()</code> to the next (less significant) group.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_character_encodings">4. Character encodings</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="charset_id">4.1. Enumeration <code>charset_id</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
enum class charset_id : unsigned { };

constexpr charset_id  scid_ascii        = /* ... */;
constexpr charset_id  scid_utf8         = /* ... */;
constexpr charset_id  scid_utf16        = /* ... */;
constexpr charset_id  scid_utf32        = /* ... */;
constexpr charset_id  scid_iso_8859_1   = /* ... */;
constexpr charset_id  scid_iso_8859_2   = /* ... */;
constexpr charset_id  scid_iso_8859_3   = /* ... */;
constexpr charset_id  scid_iso_8859_4   = /* ... */;
constexpr charset_id  scid_iso_8859_5   = /* ... */;
constexpr charset_id  scid_iso_8859_6   = /* ... */;
constexpr charset_id  scid_iso_8859_7   = /* ... */;
constexpr charset_id  scid_iso_8859_8   = /* ... */;
constexpr charset_id  scid_iso_8859_9   = /* ... */;
constexpr charset_id  scid_iso_8859_10  = /* ... */;
constexpr charset_id  scid_iso_8859_11  = /* ... */;
constexpr charset_id  scid_iso_8859_13  = /* ... */;
constexpr charset_id  scid_iso_8859_14  = /* ... */;
constexpr charset_id  scid_iso_8859_15  = /* ... */;
constexpr charset_id  scid_iso_8859_16  = /* ... */;

constexpr charset_id  scid_windows_1250 = /* ... */;
constexpr charset_id  scid_windows_1251 = /* ... */;
constexpr charset_id  scid_windows_1252 = /* ... */;
constexpr charset_id  scid_windows_1253 = /* ... */;
constexpr charset_id  scid_windows_1254 = /* ... */;
constexpr charset_id  scid_windows_1255 = /* ... */;
constexpr charset_id  scid_windows_1256 = /* ... */;
constexpr charset_id  scid_windows_1257 = /* ... */;
constexpr charset_id  scid_windows_1258 = /* ... */;

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transcoding_error_notifier_c">4.2. Facet category <code>transcoding_error_notifier_c</code></h3>
<div class="paragraph">
<p>A facet of the <code>transcoding_error_notifier_c</code> category must satisfy the
<em><a href="#TranscodingErrorNotifierPtr">TranscodingErrorNotifierPtr</a></em> type requirements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
struct transcoding_error_notifier_c {
    static constexpr bool constrainable = false;
    static constexpr <a href="#transcoding_error_notifier_nullptr">transcoding_error_notifier_nullptr</a> get_default() noexcept {
        return {};
    }
};
} // namespace strf</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="TranscodingErrorNotifierPtr">Type requirement <em>TranscodingErrorNotifierPtr</em></h4>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X</code>, a <em>TranscodingErrorNotifierPtr</em> type</p>
</li>
<li>
<p><code>x</code>, a const value of type <code>X</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must hold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="#facet_category">facet_category</a>&lt;X&gt;</code> is a type alias to <code>transcoding_error_notifier_c</code></p>
</li>
<li>
<p><code>X</code> is <em>MoveConstructible</em></p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.get()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#transcoding_error_notifier">transcoding_error_notifier</a>*</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transcoding_error_notifier_nullptr">Struct <code>transcoding_error_notifier_nullptr</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

struct transcoding_error_notifier_nullptr {
    using category = transcoding_error_notifier_c;

    constexpr transcoding_error_notifier* get() const { return nullptr; }
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transcoding_error_notifier_ptr">Struct <code>transcoding_error_notifier_ptr</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

struct transcoding_error_notifier_ptr {
    using category = transcoding_error_notifier_c;

    constexpr transcoding_error_notifier* get() const { return ptr; }

    transcoding_error_notifier* ptr = nullptr;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transcoding_error_notifier">Class transcoding_error_notifier</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

class transcoding_error_notifier {
public:
    virtual ~transcoding_error_notifier() {}

    virtual void invalid_sequence
        ( int code_unit_size
        , const char* source_charset_name
        , const void* sequence_ptr
        , std::ptrdiff_t code_units_count )
    {
    }

    virtual void unsupported_codepoint
        ( const char* destination_charset_name
        , unsigned codepoint )
    {
    }
};

} // namespace strf</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transcode_flags">4.3. Enum <code>transcode_flags</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

enum class transcode_flags {
    none = 0,
    lax_surrogate_policy = 1,
    stop_on_invalid_sequence = 1 &lt;&lt; 1,
    stop_on_unsupported_codepoint = 1 &lt;&lt; 2
};

constexpr transcode_flags  operator|(transcode_flags a, transcode_flags b) noexcept;
constexpr transcode_flags  operator&amp;(transcode_flags a, transcode_flags b) noexcept;
constexpr transcode_flags&amp; operator|=(transcode_flags&amp; a, transcode_flags b) noexcept;
constexpr transcode_flags&amp; operator&amp;=(transcode_flags&amp; a, transcode_flags b) noexcept;

constexpr bool with_strict_surrogate_policy(transcode_flags f) noexcept;
constexpr bool with_lax_surrogate_policy(transcode_flags f) noexcept;
constexpr bool with_stop_on_invalid_sequence(transcode_flags f) noexcept;
constexpr bool with_stop_on_unsupported_codepoint(transcode_flags f) noexcept;

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>transcode_flags</code> is a flags enum, <em>i.e.</em> the value of a
<code>transcode_flags</code> can be a combination the above values.</p>
</div>
</div>
<div class="sect2">
<h3 id="transcode_stop_reason">4.4. Enum <code>transcode_stop_reason</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
enum class transcode_stop_reason : std::uint32_t {
    completed,
    insufficient_output_space,
    unsupported_codepoint,
    invalid_sequence
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>transcode_stop_reason</code> is used in the return type of the several trancode
functions of the library with the following semantics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>transcode_stop_reason::completed</code> implies that all input has been transcoded
(though some parts of it might be invalid and thus been replaced by the
 replacement character U+FFFD or <code>'?'</code> )</p>
</li>
<li>
<p><code>transcode_stop_reason::insufficient_output_space</code> implies that the transcoding stopped
because the destination is too small ( in case the destination is range
of character pointers ), or that the state of the <code><a href="destination_hpp.html#destination">destination</a>&lt;<em>DstCharT</em>&gt;</code> object is
(or became) <a href="destination_hpp.html#output_buffer_good">bad</a>.</p>
</li>
<li>
<p><code>transcode_stop_reason::invalid_sequence</code> implies that both the input has an
invalid sequence (<em>i.e.</em> it is not conformant to its encoding ) and the flag
<code><a href="#transcode_flags">transcode_flags</a>::stop_on_invalid_sequence</code> was set.</p>
</li>
<li>
<p><code>transcode_stop_reason::unsupported_codepoint</code> implies that both the input has a
condepoint that not encodable in the destination character encoding ( though it
is this a valid in the source character encoding, which may happen,
for instance, when converting UTF-8 to ISO 8859-1) and the flag
<code><a href="#transcode_flags">transcode_flags</a>::stop_on_unsupported_codepoint</code> was set.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>transcode_stop_reason</code> is not a flags enum, <em>i.e.</em> the value of a
<code>transcode_stop_reason</code> is always expected to one of the above values ( never a
combination of them )</p>
</div>
</div>
<div class="sect2">
<h3 id="charset_c">4.5. Facet category template <code>charset_c</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename CharT&gt;
struct charset_c {
    static constexpr bool constrainable = false;
    static constexpr <a href="#static_charset_constexpr">utf</a>&lt;CharT&gt; get_default() noexcept;
};

template &lt;typename CharT, <a href="#charset_id">charset_id</a> CSId&gt;
struct <a href="#facet_traits">facet_tratis</a>&lt;<a href="#static_charset">static_charset</a>&lt;CharT, CSId&gt;&gt;
{
    using category = charset_c&lt;CharT&gt;;
};

template &lt;typename CharT&gt;
struct <a href="#facet_traits">facet_tratis</a>&lt;<a href="#dynamic_charset">dynamic_charset</a>&lt;CharT&gt;&gt;
{
    using category = charset_c&lt;CharT&gt;;
};
} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a type to be a facet of <code>charset_c&lt;CharT&gt;</code> it has
to be a <em><a href="#Charset">Charset</a></em> type for <code>CharT</code>. The library provides
two class templates that satisfy that: <code><a href="#static_charset">static_charset</a></code>
and <code><a href="#dynamic_charset">dynamic_charset</a></code></p>
</div>
</div>
<div class="sect2">
<h3 id="transcode_dest">4.6. Type alias template <code>transcode_dest</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename CharT&gt;
using transcode_dest = <a href="destination_hpp.html#output_buffer">output_buffer</a>&lt;CharT, 3&gt;;

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transcode_result">4.7. Struct template <code>transcode_result</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename SrcCharT, typename DstCharT&gt;
struct transcode_result {
    const SrcCharT* src_ptr;
    DstCharT* dst_ptr;
    <a href="#transcode_stop_reason">transcode_stop_reason</a> stop_reason;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transcode_size_result">4.8. Struct template <code>transcode_size_result</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename CharT&gt;
struct transcode_size_result {
    std::ptrdiff_t ssize;
    const CharT* src_ptr;
    <a href="#transcode_stop_reason">transcode_stop_reason</a> stop_reason;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="count_codepoints_result">4.9. Struct template <code>count_codepoints_result</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename CharT&gt;
struct count_codepoints_result {
    std::ptrdiff_t count;
    const CharT* ptr;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="charset_function_pointers">4.10. Aliases for pointers to functions</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename SrcCharT, typename DstCharT&gt;
using transcode_f = <a href="#transcode_result">transcode_result</a>&lt;CharT&gt; (*)
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier
    , <a href="#transcode_flags">transcode_flags</a> flags );

template &lt;typename SrcCharT&gt;
using transcode_size_f = <a href="#transcode_size_result">transcode_size_result</a>&lt;ScrCharT&gt; (*)
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , std::ptrdiff_t limit
    , <a href="#transcode_flags">transcode_flags</a> flags );

template &lt;typename CharT&gt;
using write_replacement_char_f = void(*)( <a href="#transcode_dest">transcode_dest</a>&lt;CharT&gt;&amp; );

using validate_f = int (*)(char32_t ch);

using encoded_char_size_f = int (*) (char32_t ch);

template &lt;typename CharT&gt;
using encode_char_f = CharT*(*) (CharT* dest, char32_t ch);

template &lt;typename CharT&gt;
using encode_fill_f = void (*)
    ( <a href="#transcode_dest">transcode_dest</a>&lt;CharT&gt;&amp;
    , std::ptrdiff_t count
    , char32_t ch );

template &lt;typename CharT&gt;
using count_codepoints_fast_f = count_codepoints_result&lt;CharT&gt; (*)
    ( const CharT* src
    , const CharT* src_end
    , std::ptrdiff_t max_count );

template &lt;typename CharT&gt;
using count_codepoints_f = count_codepoints_result&lt;CharT&gt; (*)
    ( const CharT* src
    , const CharT* src_end
    , std::ptrdiff_t max_count );

template &lt;typename CharT&gt;
using decode_unit_f = char32_t (*) ( CharT );

template &lt;typename SrcCharT, typename DstCharT&gt;
using find_transcoder_f = <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;SrcCharT, DstCharT&gt; (*)
    ( <a href="#charset_id">charset_id</a> );

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Transcoder">4.11. Type requirement <em>Transcoder</em></h3>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharT</code>, one of the types: <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code> or <code>wchar_t</code></p>
</li>
<li>
<p><code>DstCharT</code>, one of the types: <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code> or <code>wchar_t</code></p>
</li>
<li>
<p><code>X</code>, a <em>Transcoder</em> type from <code>SrcCharT</code> to <code>DstCharT</code></p>
</li>
<li>
<p><code>x</code>, an expression of type <code>X</code> or <code>const X</code></p>
</li>
<li>
<p><code>src</code>, a value of type <code>const SrcCharT*</code></p>
</li>
<li>
<p><code>src_end</code>, a value of type <code>const SrcCharT*</code> pointing immediately after
the last character of the string that begins at <code>str</code></p>
</li>
<li>
<p><code>dst</code>, a value of type <code>DstCharT*</code></p>
</li>
<li>
<p><code>dst_end</code>, a value of type <code>DstCharT*</code> pointing immediately after
the last element of the array that begins at <code>dst</code></p>
</li>
<li>
<p><code>limit</code> is value of type <code>std::ptrdiff_t</code></p>
</li>
<li>
<p><code>err_notifier</code>, is a pointer of type <code><a href="#transcoding_error_notifier">transcoding_error_notifier</a></code></p>
</li>
<li>
<p><code>flags</code>, a value of type <code><a href="#transcode_flags">transcode_flags</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must hold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a>.</p>
</li>
<li>
<p><code>X</code> supports the following syntax and semantics:</p>
</li>
</ul>
</div>
<div id="Transcoder_src_code_unit" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">X::src_code_unit</code></pre>
</div>
</div>
<div class="paragraph">
<p>A type alias to <code>SrcCharT</code></p>
</div>
</div>
</div>
<div id="Transcoder_dst_code_unit" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">X::dst_code_unit</code></pre>
</div>
</div>
<div class="paragraph">
<p>A type alias to <code>DstCharT</code></p>
</div>
</div>
</div>
<div id="Transcoder_transcode" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.transcode(src, src_end, dst, dst_end, err_notifier, flags)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Precondition</dt>
<dd>
<p><code>x.transcode_func() != nullptr</code> is <code>true</code></p>
</dd>
<dt class="hdlist1">Return type</dt>
<dd>
<p><code><a href="#transcode_result">transcode_result</a></code></p>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Converts the content of <code>src</code> from one encoding to another writing
the result to <code>dst</code>.</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>As this function iterates from <code>src</code> to <code>src_end</code>, if it reads a sequence that is invalid
( non-conformant to the source character encoding ) then it calls
<code>err_notifier-&gt;<a href="#transcoding_error_notifier">invalid_sequence</a>(ch_size, name, seq, count)</code>,
if <code>err_notifer</code> is not null, where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ch_size</code> is equal to <code>sizeof(SrcCharT)</code></p>
</li>
<li>
<p><code>name</code> is the name of the source character encoding (<em>e.g.</em>, <code>"UTF-8"</code>)</p>
</li>
<li>
<p><code>seq</code> points to the first character of the invalid sequence.</p>
</li>
<li>
<p><code>count</code> is number of code units of the invalid sequence</p>
<div class="ulist">
<ul>
<li>
<p>Note: The value of both following expression shall be <code>true</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">(const SrcCharT*)seq &gt;= src</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">(const SrcCharT*)seq + count &lt;= src_end</code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>After that, if <code>flags</code> has the bit flag <code>stop_on_invalid_sequence</code>, then the function shall
stop and return a value with <code><a href="#transcode_result">stop_reason</a></code> equal to
<code>transcode_stop_reason::invalid_sequence</code>. Otherwise, the function shall write a
replacement character (which is U+FFFD or <code>'?'</code>, depending on the destination encoding)
and continue the iteration after the invalid sequence. Note: the presence of a
surrogate codepoint ( that is considered to be and invalid sequence )
shall not be considered an invalid sequence if the flag
<code>transcode_flags::lax_surrogate_policy</code> is set in <code>flags</code>.</p>
</div>
<div class="paragraph">
<p>Similarly, when the function reads a codepoint that is not supported by the destination
encoding but also not equal U+FFFD, it calls (if <code>err_notifier</code> is not null)
<code>err_notifier-&gt;<a href="#transcoding_error_notifier">unsupported_codepoint</a>(dst_charset_name, code)</code>,
where <code>dst_charset_name</code> is the name of the destination character encoding,
and <code>code</code> is such codepoint.</p>
</div>
<div class="paragraph">
<p>After that, if <code>flags</code> has the flag <code>stop_on_unsupported_codepoint</code>, then the function shall
stop and return a value with <code><a href="#transcode_result">stop_reason</a></code> equal to
<code>transcode_stop_reason::unsupported_codepoint</code>. Otherwise, the function shall write a
replacement character (which is U+FFFD or <code>'?'</code>, depending on the destination encoding)
and continue the iteration after the usupported codepoint.</p>
</div>
<div class="paragraph">
<p>If the input contains the U+FFFD codepoint then it should not be treated as unsupported
even if it is. This means that <code>err_notifier-&gt;unsupported_codepoint</code>
shall not be called in this case, nor should this cause the interation to stop.
Instead, the function should just write <code>'?'</code> when the destination encoding
does not support U+FFFD</p>
</div>
<div class="paragraph">
<p><code>transcode_stop_reason::insufficient_output_space</code> should only be returned if
there is still something to be written but there is no space left
(<em>i.e.</em>, the distance <code>(dst_end - dst)</code> is too small).
For instance, if the input starts with an invalid sequence and
<code>flags</code> has <code>stop_on_invalid_sequence</code> set, then, even if
<code>dst_end</code> is equal to <code>dst</code> the returned <code>stop_reason</code> shall <strong>not</strong> be
<code>transcode_stop_reason::insufficient_space</code>; it should instead be
shall be <code>transcode_stop_reason::invalid_sequence</code>.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Return value</dt>
<dd>
<p>A value <code>res</code> such that</p>
<div class="ulist">
<ul>
<li>
<p><code>res.<strong>stop_reason</strong></code> is <code>transcode_stop_reason::completed</code> unless for
any of the cases explained above.</p>
</li>
<li>
<p><code>res.<strong>src_ptr</strong></code> points immediately after the last element in the range <code>[src, src_end)</code>
that has been transcoded.</p>
</li>
<li>
<p><code>res.<strong>dst_ptr</strong></code> points immediately after the last element in the range <code>[dst, dst_end)</code>
that has been written</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="Transcoder_unsafe_transcode" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.unsafe_transcode(src, src_end, dst, dst_end, err_notifier, flags)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The input has no invalid sequence</p>
</li>
<li>
<p><code>x.unsafe_transcode_() != nullptr</code> is <code>true</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Return type</dt>
<dd>
<p><code><a href="#transcode_result">transcode_result</a></code></p>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Exactly the same as <code>x.transcode(src, src_end, dst, dst_end, err_notifier, flags)</code>,
except that the behaviour is undefined if the input contains any
invalid sequence.</p>
<div class="paragraph">
<p>Note that if the flag <code>transcode_flags::lax_surrogate_policy</code> is set
in <code>flags</code>, then the presence of a surrogate codepoint in <code>[src, src_end)</code>
is not to be considered as an invalid sequence, and thus shall <strong>not</strong> cause
undefined behaviour.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="Transcoder_transcode_size" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.transcode_size(src, src_end, limit, flags)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Precondition</dt>
<dd>
<p><code>x.transcode_func() != nullptr</code> is <code>true</code></p>
</dd>
<dt class="hdlist1">Return type</dt>
<dd>
<p><code><a href="#transcode_size_result">transcode_size_result</a></code></p>
</dd>
<dt class="hdlist1">Return value</dt>
<dd>
<p>A value <code>res</code> such that</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>res.<strong>src_ptr</strong></code> is equal to <code><em>tr_res</em>.src_ptr</code> ( see below )</p>
</li>
<li>
<p><code>res.<strong>stop_reason</strong></code> is equal to <code><em>tr_res</em>.stop_reason</code></p>
</li>
<li>
<p><code>res.<strong>ssize</strong></code> equals to <code><em>tr_res</em>.dst_ptr - dst</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>, where <code><em>tr_res</em></code> is the value that
<code>x.transcode(src, src_end, dst, dst + limit, nullptr, flags)</code>
would return, assuming <code>[dst, dst + limit)</code> is a valid memory area.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="Transcoder_unsafe_transcode_size" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.unsafe_transcode_size(src, src_end, limit, flags)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Precondition
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>The input has no invalid sequence</p>
</li>
<li>
<p><code>x.unsafe_transcode_() != nullptr</code> is <code>true</code></p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#transcode_size_result">transcode_size_result</a></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Exactly the same as <code>x.transcode_size(src, src_end, limit, flags)</code>,
except that the behaviour is undefined if the input contains any
invalid sequence.</p>
<div class="paragraph">
<p>Note that if the flag <code>transcode_flags::lax_surrogate_policy</code> is set
in <code>flags</code>, then the presence of a surrogate codepoint in <code>[src, src_end)</code>
is not to be considered as an invalid sequence, and thus shall <strong>not</strong> cause
undefined behaviour.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Transcoder_transcode_func" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.transcode_func()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#charset_function_pointers">transcode_f</a>&lt;SrcCharT, DstCharT&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A function pointer such that
<code>x.transcode_func() (src, src_end, dst, dst_end, derr_notifier, flags)</code>
has the same effect as
<code>x.<a href="#Transcoder_transcode">transcode</a>(src, src_end, dst, dst_end, err_notifier, flags)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Transcoder_unsafe_transcode_func" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.unsafe_transcode_func()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#charset_function_pointers">transcode_f</a>&lt;SrcCharT, DstCharT&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A function pointer such that
<code>x.unsafe_transcode_func() (src, src_end, dst, dst_end, err_notifier, flags)</code>
has the same effect as
<code>x.<a href="#Transcoder_unsafe_transcode">unsafe_transcode</a>(src, src_end, dst, dst_end, err_notifier, flags)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Transcoder_transcode_size_func" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.transcode_size_func()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#charset_function_pointers">transcode_size_f</a>&lt;SrcCharT&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A function pointer such that
<code>x.transcode_size_func() (src, src_end, limit, flags)</code> has the same
effect as <code>x.<a href="#Transcoder_transcode_size">transcode_size</a>(src, src_end, limit, flags)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Transcoder_unsafe_transcode_size_func" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.unsafe_transcode_size_func()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#charset_function_pointers">transcode_size_f</a>&lt;SrcCharT&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A function pointer such that
<code>x.unsafe_transcode_size_func() (src, src_end, limit, flags)</code> has the same
effect as <code>x.<a href="#Transcoder_unsafe_transcode_size">unsafe_transcode_size</a>(src, src_end, limit, flags)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<hr>
<div id="Transcoder_null" class="exampleblock">
<div class="content">
<div class="paragraph">
<div class="title">Definition</div>
<p>A <strong>null transcoder</strong> is an object of an <em>Transcoder</em>
type where the <code>transcode_func</code> function returns <code>nullptr</code>.</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There are two class templates that satisfy <em>Transcoder</em>:
      <code><a href="#static_transcoder">static_transcoder</a></code> and <code><a href="#dynamic_transcoder">dynamic_transcoder</a></code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="Charset">4.12. Type requirement <em>Charset</em></h3>
<div class="paragraph">
<p>An object whose type is a <em>Charset</em> represents a character encoding.
In this documentation the terms <em>charset</em>, <em>encoding</em> and
<em>character encoding</em> are used interchangeably.</p>
</div>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CharT</code>, one of the follwoing types: <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code> or <code>wchar_t</code></p>
</li>
<li>
<p><code>OtherCharT</code>, one of the folowing types : <code>char</code>, <code>char8_t</code>, <code>char16_t</code> or <code>wchar_t</code></p>
</li>
<li>
<p><code>X</code>, a <em>Charset</em> type for type <code>CharT</code></p>
</li>
<li>
<p><code>x</code>, an expression of type <code>X</code> or <code>const X</code></p>
</li>
<li>
<p><code>ptr</code>, a value of type <code>CharT*</code></p>
</li>
<li>
<p><code>src</code>, a value of type <code>const CharT*</code></p>
</li>
<li>
<p><code>src_end</code>, a value of type <code>const SrcCharT*</code> pointing immediately after
the last character of the string that begins at <code>str</code></p>
</li>
<li>
<p><code>dest</code>, an lvalue reference of type <code><a href="#transcode_dest">transcode_dest</a>&lt;CharT&gt;</code></p>
</li>
<li>
<p><code>src_size</code>, a value of type <code>std::ptrdiff_t</code> equal to the size of
the array pointed by <code>src</code></p>
</li>
<li>
<p><code>count</code>, a value of type <code>std::ptrdiff_t</code></p>
</li>
<li>
<p><code>max_count</code>, a value of type <code>std::ptrdiff_t</code></p>
</li>
<li>
<p><code>ch32</code>, a value of type <code>char32_t</code></p>
</li>
<li>
<p><code>ch</code>, a value of type <code>CharT</code></p>
</li>
<li>
<p><code>cs_id</code>, value of type <code><a href="#charset_id">charset_id</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must hold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X</code> is either an instance of the <code><a href="#static_transcoder">static_transcoder</a></code> or <code><a href="#dynamic_charset">dynamic_charset</a></code> class template</p>
</li>
<li>
<p><code>X</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a></p>
</li>
<li>
<p><code><a href="#facet_category">facet_category</a>&lt;X&gt;</code> must be <code><a href="#charset_c">charset_c</a>&lt;CharT&gt;</code></p>
</li>
<li>
<p><code>X</code> satisfies the following syntax and semantics:</p>
</li>
</ul>
</div>
<div id="Charset_code_unit" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">X::code_unit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Type alias to <code>CharT</code></p>
</div>
</div>
</div>
<div id="Charset_id" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.id()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#charset_id">charset_id</a></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The <code><a href="#charset_id">charset_id</a></code> that corresponds to this encoding.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Charset_name" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.name()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>const char*</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The name of this encoding. Examples: <code>"UTF-8"</code>, <code>"ASCII"</code>, <code>"ISO-8859-1"</code>, <code>"windows-1252"</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Charset_replacement_char" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.replacement_char()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>char32_t</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The character used to signalize an error. Usually it is the <a href="https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character">replacement character &#xFFFD;</a> if it is supported by this encoding, or the question mark <code>'?'</code> otherwise.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.write_replacement_char(dest)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Writes into <code>dest</code> the codepoint returned by <code>x.replacement_char()</code> encoded in this charset.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>void</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.replacement_char_size()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>int</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The number of characters that <code>x.write_replacement_char(dest)</code> writes into <code>dest</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.encoded_char_size(ch32)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>int</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The size of the string containing the UTF-32 character <code>ch32</code>,
if <code>ch32</code> is supported in this encoding. Otherwise,
<code>x.replacement_char_size()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postcondition
</td>
<td class="hdlist2">
<p>The return value must be greater than zero.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p>This function does not check whether <code>ch32</code> is a legal code point, only if
it is possible to write it in this encoding. For example, if this is encoding
is UTF-32, this function considers as valid any value for <code>ch32</code> ( even if
is is greater than <code>0x10FFFF</code> ). Surrogates characters are also not sanitized.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.validate(ch32)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>int</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The size of the string encoding <code>ch32</code>,
if <code>ch32</code> is a valid codepoint and supported in this encoding. Otherwise, <code>-1</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.encode_char(ptr, ch32)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Encodes into <code>ptr</code> the UTF-32 character <code>ch32</code>, without sanitizing.
If this encoding is not able to encode <code>ch32</code>,
then encodes instead the return of <code>x.replacement_char()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>CharT*</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postcondition
</td>
<td class="hdlist2">
<p><code>x.encode_char(ptr, ch32) - ptr == x.encoded_char_size(ch32)</code> is <code>true</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The position just after the last writen character.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p>This function does not check whether <code>ch32</code> is a legal code point, only if
it is possible to write it in this encoding. For example, if this is encoding
is UTF-32, this function considers as valid any value for <code>ch32</code> ( even if
is is greater than <code>0x10FFFF</code> ). Surrogates characters are also not sanitized.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.encode_fill(dest, count, ch32)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Writes <code>count</code> times into <code>dest</code> the UTF-32 character <code>ch32</code> encoded into
this encoding, if it is supported. Otherwise writes <code>x.replacement_char()</code>
instead.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>void</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p><code>encode_fill</code> does not check whether <code>ch32</code> is a legal code point, only if
it is possible to write it in this encoding. For example, if this is encoding
is UTF-32, <code>encode_fill</code> considers as valid any value for <code>ch32</code> ( even if
is is greater than <code>0x10FFFF</code> ). Surrogates characters are also not sanitized.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Charset_count_codepoints_fast" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.count_codepoints_fast(src, src_end, max_count)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#count_codepoints_result">count_codepoints_result</a>&lt;CharT&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>{c, ptr}</code>, where:</p>
<div class="ulist">
<ul>
<li>
<p><code>c</code> is the number of Unicode code points in <code>src</code>,
if such value is less than <code>max_count</code>.
Otherwise, <code>c</code> is equal to <code>max_count</code>.</p>
</li>
<li>
<p><code>ptr</code> is the greatest pointer not greater than <code>src_end</code> such that
<code>x.count_codepoints_fast(src, ptr, std::numeric_limits&lt;std::ptrdiff_t&gt;::max()).count</code>
is equal to <code>c</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Posconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>c &lt;= max_count</code> is <code>true</code></p>
</li>
<li>
<p><code>ptr &lt;= src_end</code> is <code>true</code></p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p>If the input is non-conformant to the corresponding character encoding,
this function may return an incorrect value. For instance, for UTF-8
this function may simply count the bytes that are not continuation bytes.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Charset_count_codepoints" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.count_codepoints(src, src_end, max_count)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Counts the codepoints until it is equal to <code>max_count</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#count_codepoints_result">count_codepoints_result</a>&lt;CharT&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>{c, ptr}</code>, where:</p>
<div class="ulist">
<ul>
<li>
<p><code>c</code> is equal to <code>std::min(max_count, u32len)</code>, where <code>u32len</code> is the
length of the UTF-32 string that would be generated by converting
<code>src</code> from this encoding to UTF-32.</p>
</li>
<li>
<p><code>ptr</code> is the greatest pointer not greater than <code>src_end</code> such that
<code>x.count_codepoints(src, ptr, std::numeric_limits&lt;std::ptrdiff_t&gt;::max()).count</code>
 is equal to <code>c</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Posconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>c &lt;= max_count</code> is <code>true</code></p>
</li>
<li>
<p><code>ptr &lt;= src_end</code> is <code>true</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Charset_decode_unit" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.decode_unit(ch)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Decodes <code>ch</code> from this encoding to UTF-32.
If <code>ch</code> is an invalid character that is not a surrogate, returns U'\uFFFD'
( surrogates codepoints as not sanitized ).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>char32_t</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.encode_char_func()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#charset_function_pointers">encode_char_f</a>&lt;CharT&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A function pointer such that <code>x.encode_char_func() (ch32)</code> has
the same effect as <code>x.encode_char(ch32)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.encode_fill_func()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#charset_function_pointers">encode_fill_f</a>&lt;CharT&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A function pointer such that <code>x.encode_fill_func() (dest, count, ch32)</code>
has the same effect as <code>x.encode_fill(dest, count, ch32)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.write_replacement_char_func()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#charset_function_pointers">write_replacement_char_f</a>&lt;CharT&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A function pointer such that <code>x.write_replacement_char_func() (dest)</code>
has the same effect as <code>x.write_replacement_char(dest)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.validate_func()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#charset_function_pointers">validate_f</a></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A function pointer such that <code>x.validate_func() (ch32)</code>
returns the same value as <code>x.validate(ch32)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Charset_from_u32" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.from_u32()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p>A <em><a href="#Transcoder">Transcoder</a></em> type <code>T</code>, such that
<code>T::<a href="#Transcoder_src_code_unit">src_code_unit</a></code> is <code>char32_t</code> and
<code>T::<a href="#Transcoder_dst_code_unit">dst_code_unit</a></code> is <code>CharT</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A transcoder that converts UTF-32 to this encoding.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Charset_to_u32" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.to_u32()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p>A <em><a href="#Transcoder">Transcoder</a></em> type <code>T</code>, such that
<code>T::<a href="#Transcoder_src_code_unit">src_code_unit</a></code> is <code>CharT</code> and
<code>T::<a href="#Transcoder_dst_code_unit">dst_code_unit</a></code> is <code>char32_t</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A transcoder that converts this encoding to UTF-32.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Charset_sanitizer" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.sanitizer()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p>A <em><a href="#Transcoder">Transcoder</a></em> from <code>CharT</code> to <code>CharT</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A transcoder that converts this encoding to this encoding,
<em>i.e.</em> a sanitizer of this encoding.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Charset_find_transcoder_to" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">( Optional )</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.find_transcoder_to(<a href="#tag">tag</a>&lt;OtherCharT&gt;, cs_id)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, OtherCharT&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A transcoder that converts this encoding to the encoding
corresponding to <code>cs_id</code>, or an
<a href="#Transcoder_null">null transcoder</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Charset_find_transcoder_from" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">( Optional )</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.find_transcoder_from(<a href="#tag">tag</a>&lt;OtherCharT&gt;, cs_id)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;OtherCharT, CharT&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A transcoder that converts the encoding corresponding to
<code>cs_id</code> to this encoding, or an
<a href="#Transcoder_null">null transcoder</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="Charset_to_dynamic" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.to_dynamic()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A <code><a href="#dynamic_charset">dynamic_charset</a>&lt;CharT&gt;</code> object equivalent to this one.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You shall not create an <em>Charset</em> for <code>char32_t</code>, since <code>char32_t</code>
           is reserved for UTF-32.
           The library internaly assumes in many occasions that the encoding
           is UTF-32 when <code>CharT</code> is <code>char32_t</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="static_transcoder">4.13. Class template <code>static_transcoder</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;class SrcCharT, class DstCharT, <a href="#charset_id">charset_id</a> Src, <a href="#charset_id">charset_id</a> Dest&gt;
class static_transcoder;

// sanitizers
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_ascii, scid_ascii&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_1, scid_iso_8859_1&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_2, scid_iso_8859_2&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_3, scid_iso_8859_3&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_4, scid_iso_8859_4&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_5, scid_iso_8859_5&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_6, scid_iso_8859_6&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_7, scid_iso_8859_7&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_8, scid_iso_8859_8&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_9, scid_iso_8859_9&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_10, scid_iso_8859_10&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_11, scid_iso_8859_11&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_13, scid_iso_8859_13&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_14, scid_iso_8859_14&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_15, scid_iso_8859_15&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_16, scid_iso_8859_16&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1250, scid_windows_1250&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1251, scid_windows_1251&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1252, scid_windows_1252&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1253, scid_windows_1253&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1254, scid_windows_1254&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1255, scid_windows_1255&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1256, scid_windows_1256&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1257, scid_windows_1257&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1258, scid_windows_1258&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf8, scid_utf8&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf16, scid_utf16&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_utf32&gt;;

// to UTF-32
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_ascii, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_1, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_2, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_3, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_4, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_5, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_6, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_7, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_8, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_9, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_10, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_11, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_13, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_14, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_15, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_iso_8859_16, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1250, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1251, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1252, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1253, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1254, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1255, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1256, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1257, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_windows_1258, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf8, scid_utf32&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf16, scid_utf32&gt;;

// from UTF-32
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_ascii&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_1&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_2&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_3&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_4&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_5&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_6&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_7&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_8&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_9&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_10&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_11&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_13&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_14&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_15&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_iso_8859_16&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_windows_1250&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_windows_1251&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_windows_1252&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_windows_1253&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_windows_1254&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_windows_1255&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_windows_1256&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_windows_1257&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_windows_1258&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_utf8&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf32, scid_utf16&gt;;

// others
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf8, scid_utf16&gt;;
template &lt;class SrcCharT, class DstCharT&gt;
class static_transcoder&lt;SrcCharT, DstCharT, scid_utf16, scid_utf8&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>static_transcoder</code> class template has no generic implementation.
Instead, the library provides the template specializations listed above.
All of them are empty classes, and are <em><a href="#Transcoder">Transcoder</a></em>, and their
member functions <code><a href="#Transcoder_transcode_func">transcode_func</a></code>
and <code><a href="#Transcoder_transcode_size_func">transcode_size_func</a></code>
never return <code>nullptr</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="static_charset">4.14. Class template <code>static_charset</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;class CharT, <a href="#charset_id">charset_id</a>&gt;
class static_charset;

template &lt;class CharT&gt; class static_charset&lt;CharT, scid_ascii&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_1&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_2&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_3&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_4&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_5&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_6&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_7&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_8&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_9&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_10&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_11&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_13&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_14&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_15&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_iso_8859_16&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_windows_1250&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_windows_1251&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_windows_1252&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_windows_1253&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_windows_1254&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_windows_1255&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_windows_1256&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_windows_1257&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_windows_1258&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_utf8&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_utf16&gt;;
template &lt;class CharT&gt; class static_charset&lt;CharT, scid_utf32&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>static_charset</code> class template has no generic implementation.
Instead, the library provides the template specializations listed above.
All of them are empty classes, and are <em><a href="#Charset">Charset</a></em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="dynamic_transcoder">4.15. Class template <code>dynamic_transcoder</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;class SrcCharT, class DstCharT&gt;
class dynamic_transcoder {
public:
    constexpr dynamic_transcoder() noexcept;

    constexpr dynamic_transcoder
        ( const dynamic_transcoder&amp; other) noexcept = default;

    template &lt;<a href="#charset_id">charset_id</a> SrcCh, <a href="#charset_id">charset_id</a> DstCh&gt;
    constexpr explicit dynamic_transcoder
        ( <a href="#static_transcoder">static_transcoder</a>&lt;SrcCh, DestCh&gt; st );

    <a href="#transcode_result">transcode_result</a>&lt;SrcCharT, DstCharT&gt; transcode
        ( const SrcCharT* src
        , const SrcCharT* src_end
        , DstCharT* dst
        , DstCharT* dst_end
        , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier
        , <a href="#transcode_flags">transcode_flags</a> flags ) const;

    <a href="#transcode_result">transcode_result</a>&lt;SrcCharT, DstCharT&gt; unsafe_transcode
        ( const SrcCharT* src
        , const SrcCharT* src_end
        , DstCharT* dst
        , DstCharT* dst_end
        , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier
        , <a href="#transcode_flags">transcode_flags</a> flags ) const;

    <a href="#transcode_size_result">transcode_size_result</a>&lt;SrcCharT&gt; transcode_size
        ( const SrcCharT* src
        , const SrcCharT* src_end
        , std::ptrdiff_t limit
        , <a href="#transcode_flags">transcode_flags</a> flags ) const;

    <a href="#transcode_size_result">transcode_size_result</a>&lt;SrcCharT&gt; unsafe_transcode_size
        ( const SrcCharT* src
        , const SrcCharT* src_end
        , std::ptrdiff_t limit
        , <a href="#transcode_flags">transcode_flags</a> flags ) const;

    constexpr <a href="#charset_function_pointers">transcode_f</a>&lt;SrcCharT, DstCharT&gt; transcode_func() const noexcept;
    constexpr <a href="#charset_function_pointers">transcode_size_f</a>&lt;SrcCharT&gt; transcode_size_func() const noexcept;
};

} // namespace strf</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr dynamic_transcoder() noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>transcode_func() == nullptr</code></p>
</li>
<li>
<p><code>transcode_size_func() == nullptr</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr dynamic_transcoder
    ( const dynamic_transcoder&amp; other) noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Trivial copy constructor</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>transcode_func() == other.transcode_func()</code></p>
</li>
<li>
<p><code>transcode_size_func() == other.transcode_size_func()</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;<a href="#charset_id">charset_id</a> Src, <a href="#charset_id">charset_id</a> Dest&gt;
constexpr explicit dynamic_transcoder
    ( <a href="#static_transcoder">static_transcoder</a>&lt;Src, Dest&gt; other );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>transcode_func() == other.transcode_func()</code></p>
</li>
<li>
<p><code>transcode_size_func() == other.transcode_size_func()</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#transcode_result">transcode_result</a>&lt;SrcCharT, DstCharT&gt; transcode
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier
    , <a href="#transcode_flags">transcode_flags</a> flags ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls <code>transcode_func()(src, src_end, dst, dst_end, err_notifier, flags)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#transcode_result">transcode_result</a>&lt;SrcCharT, DstCharT&gt; unsafe_transcode
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier
    , <a href="#transcode_flags">transcode_flags</a> flags ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls <code>unsafe_transcode_func()(src, src_end, dst, dst_end, err_notifier, flags)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#transcode_size_result">transcode_size_result</a>&lt;SrcCharT&gt; transcode_size
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , std::ptrdiff_t limit
    , <a href="#transcode_flags">transcode_flags</a> flags ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls <code>transcode_size_func()(src, src_end, limit, flags)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#transcode_size_result">transcode_size_result</a>&lt;SrcCharT&gt; unsafe_transcode_size
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , std::ptrdiff_t limit
    , <a href="#transcode_flags">transcode_flags</a> flags ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls <code>unsafe_transcode_size_func()(src, src_end, limit, flags)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic_charset_data">4.16. Struct template <code>dynamic_charset_data</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;class CharT&gt;
struct dynamic_charset_data {
    const char* name;
    <a href="#charset_id">charset_id</a> id;
    char32_t replacement_char;
    int replacement_char_size;
    <a href="#charset_function_pointers">validate_f</a> validate_func;
    <a href="#charset_function_pointers">encoded_char_size_f</a> encoded_char_size_func;
    <a href="#charset_function_pointers">encode_char_f</a>&lt;CharT&gt; encode_char_func;
    <a href="#charset_function_pointers">encode_fill_f</a>&lt;CharT&gt; encode_fill_func;
    <a href="#charset_function_pointers">count_codepoints_fast_f</a>&lt;CharT&gt; count_codepoints_fast_func;
    <a href="#charset_function_pointers">count_codepoints_f</a>&lt;CharT&gt; count_codepoints_func;

    <a href="#charset_function_pointers">write_replacement_char_f</a>&lt;CharT&gt; write_replacement_char_func;
    <a href="#charset_function_pointers">decode_unit_f</a>&lt;CharT&gt; decode_unit_func;

    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, CharT&gt; sanitizer;
    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;char32_t, CharT&gt; from_u32;
    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, char32_t&gt; to_u32;

    <a href="#charset_function_pointers">find_transcoder_f</a>&lt;wchar_t, CharT&gt; find_transcoder_from_wchar;
    <a href="#charset_function_pointers">find_transcoder_f</a>&lt;CharT, wchar_t&gt; find_transcoder_to_wchar;

    <a href="#charset_function_pointers">find_transcoder_f</a>&lt;char16_t, CharT&gt; find_transcoder_from_char16;;
    <a href="#charset_function_pointers">find_transcoder_f</a>&lt;CharT, char16_t&gt; find_transcoder_to_char16;

    <a href="#charset_function_pointers">find_transcoder_f</a>&lt;char, CharT&gt; find_transcoder_from_char;
    <a href="#charset_function_pointers">find_transcoder_f</a>&lt;CharT, char&gt; find_transcoder_to_char;

#if defined (__cpp_char8_t)
    <a href="#charset_function_pointers">find_transcoder_f</a>&lt;char8_t, CharT&gt; find_transcoder_from_char8;
    <a href="#charset_function_pointers">find_transcoder_f</a>&lt;CharT, char8_t&gt; find_transcoder_to_char8;
#else
    void* find_transcoder_from_char8 = nullptr;
    void* find_transcoder_to_char8 = nullptr;
#endif

};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic_charset">4.17. Class template <code>dynamic_charset</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;class CharT&gt;
class dynamic_charset {
public:

    using code_unit = CharT;

    explicit dynamic_charset(const dynamic_charset&amp; other) = default;

    explicit dynamic_charset(const <a href="#dynamic_charset_data">dynamic_charset_data</a>&lt;CharT&gt;&amp; d );

    template &lt;charset_id CharsetID&gt;
    explicit dynamic_charset(const <a href="#static_charset">static_charset</a>&lt;CharT, CharsetID&gt;&amp; d );

    dynamic_charset&amp; operator=(const dynamic_charset&amp; other) noexcept;

    bool operator==(const dynamic_charset&amp; other) const noexcept;

    bool operator!=(const dynamic_charset&amp; other) const noexcept;

    void swap(dynamic_charset&amp; other) noexcept;

    dynamic_charset to_dynamic() const noexcept;

    const char* name() const noexcept;

    constexpr <a href="#charset_id">charset_id</a> id() const noexcept;

    constexpr char32_t replacement_char() const noexcept;

    constexpr int replacement_char_size() const noexcept;

    constexpr int validate(char32_t ch) const; // noexcept

    constexpr int encoded_char_size(char32_t ch) const; // noexcept

    code_unit* encode_char(code_unit* dest, char32_t ch) const; // noexcept

    void encode_fill
        ( <a href="#transcode_dest">transcode_dest</a>&lt;CharT&gt;&amp; dest, std::ptrdiff_t count, char32_t ch ) const;

    std::ptrdiff_t count_codepoints_fast
        ( const code_unit* src, const code_unit* src_end
        , std::ptrdiff_t max_count ) const;

    std::ptrdiff_t count_codepoints
        ( const code_unit* src, const code_unit* src_end
        , std::ptrdiff_t max_count ) const;

    void write_replacement_char(<a href="#transcode_dest">transcode_dest</a>&lt;CharT&gt;&amp; dest) const;

    char32_t decode_unit(code_unit ch) const;

    <a href="#charset_function_pointers">encode_char_f</a>&lt;CharT&gt; encode_char_func() const noexcept;

    <a href="#charset_function_pointers">encode_fill_f</a>&lt;CharT&gt; encode_fill_func() const noexcept;

    <a href="#charset_function_pointers">write_replacement_char_f</a>&lt;CharT&gt; write_replacement_char_func() const noexcept;

    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;char32_t, CharT&gt; from_u32() const;

    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, char32_t&gt; to_u32() const;

    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, CharT&gt; sanitizer() const;

    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, wchar_t&gt; find_transcoder_to
        ( <a href="#tag">tag</a>&lt;wchar_t&gt;, <a href="#charset_id">charset_id</a> id) const;

    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;wchar_t, CharT&gt; find_transcoder_from
        ( <a href="#tag">tag</a>&lt;wchar_t&gt;, <a href="#charset_id">charset_id</a> id) const;

    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, char16_t&gt; find_transcoder_to
        ( <a href="#tag">tag</a>&lt;char16_t&gt;, <a href="#charset_id">charset_id</a> id) const;

    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;char16_t, CharT&gt; find_transcoder_from
        ( <a href="#tag">tag</a>&lt;char16_t&gt;, <a href="#charset_id">charset_id</a> id) const;

    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, char&gt; find_transcoder_to
        ( <a href="#tag">tag</a>&lt;char&gt;, <a href="#charset_id">charset_id</a> id) const;

    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;char, CharT&gt; find_transcoder_from
        ( <a href="#tag">tag</a>&lt;char&gt;, <a href="#charset_id">charset_id</a> id) const;

#if defined (__cpp_char8_t)
    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, char8_t&gt; find_transcoder_to
        ( <a href="#tag">tag</a>&lt;char8_t&gt;, <a href="#charset_id">charset_id</a> id) const;

    <a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;char8_t, CharT&gt; find_transcoder_from
        ( <a href="#tag">tag</a>&lt;char8_t&gt;, <a href="#charset_id">charset_id</a> id) const;
#endif

private:

    const <a href="#dynamic_charset_data">dynamic_charset_data</a>* data; // exposition only
};</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">dynamic_charset(const dynamic_charset&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Trivial copy constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p><code>this-&gt;data = other.data</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">dynamic_charset(const <a href="#dynamic_charset_data">dynamic_charset_data</a>&lt;CharT&gt;&amp; d);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p><code>this-&gt;data = d</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;charset_id CharsetID&gt;
dynamic_charset(const <a href="#static_charset">static_charset</a>&lt;CharT, CharsetID&gt;&amp; cs);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to <code>dynamic_charset(cs.to_dynamic())</code></p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">dynamic_charset&amp; operator=(const dynamic_charset&amp; other) noexcept</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p><code>this-&gt;data = other.data</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">bool operator==(const dynamic_charset&amp; other) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data == other.data</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">bool operator!=(const dynamic_charset&amp; other) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data != other.data</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">void swap(dynamic_charset&amp; other) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Equivalent to <code>std::swap(this-&gt;data, other.data)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">dynamic_charset to_dynamic() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>*this</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">const char* name() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;name</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr <a href="#charset_id">charset_id</a> id() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;id</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr char32_t replacement_char() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;replacement_char</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr int replacement_char_size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;replacement_char_size</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr int validate(char32_t ch) const; // noexcept</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns <code>this-&gt;data-&gt;validate_func(ch)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr int encoded_char_size(char32_t ch) const; // noexcept</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns <code>this-&gt;data-&gt;encoded_char_size_func(ch)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">code_unit* encode_char(code_unit* dest, char32_t ch) const; // noexcept</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns <code>this-&gt;data-&gt;encoded_char_func(ch)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">void encode_fill
    ( <a href="#transcode_dest">transcode_dest</a>&lt;CharT&gt;&amp; dest, std::ptrdiff_t count, char32_t ch ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns
<code>this-&gt;data-&gt;encode_fill_func(dest, count, ch)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">std::ptrdiff_t count_codepoints_fast
    ( const code_unit* src, const code_unit* src_end
    , std::ptrdiff_t max_count ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns <code>this-&gt;data-&gt;count_codepoints_fast_func(src, src_end, max_count)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">std::ptrdiff_t count_codepoints
    ( const code_unit* src, const code_unit* src_end
    , std::ptrdiff_t max_count ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns
<code>this-&gt;data-&gt;count_codepoints_func(src, src_end, max_count)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">void write_replacement_char(<a href="#transcode_dest">transcode_dest</a>&lt;CharT&gt;&amp; dest) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls <code>this-&gt;data-&gt;write_replacement_char_func(dest)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">char32_t decode_unit(code_unit ch) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns <code>this-&gt;data-&gt;decode_unit_func(ch)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#charset_function_pointers">encode_char_f</a>&lt;CharT&gt; encode_char_func() const noexcept;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#charset_function_pointers">encode_fill_f</a>&lt;CharT&gt; encode_fill_func() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;encode_fill_func</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#charset_function_pointers">write_replacement_char_f</a>&lt;CharT&gt; write_replacement_char_func() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;write_replacement_char_func</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;char32_t, CharT&gt; from_u32() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;from_u32</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, char32_t&gt; to_u32() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;to_u32</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, CharT&gt; sanitizer() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;sanitizer</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, char&gt; find_transcoder_to
    ( <a href="#tag">tag</a>&lt;char&gt;, <a href="#charset_id">charset_id</a> id ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;transcoder_finder_to_char(id)</code> if such function pointer
is not null. Otherwise returns <code><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, char&gt;{}</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;char, CharT&gt; find_transcoder_from
    ( <a href="#tag">tag</a>&lt;char&gt;, <a href="#charset_id">charset_id</a> id ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;transcoder_finder_from_char(id)</code> if such function pointer
is not null. Otherwise returns <code><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;char, CharT&gt;{}</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, char8_t&gt; find_transcoder_to
    ( <a href="#tag">tag</a>&lt;char8_t&gt;, <a href="#charset_id">charset_id</a> id ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;transcoder_finder_to_char8(id)</code> if such function pointer
is not null. Otherwise returns <code><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, char8_t&gt;{}</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;char8_t, CharT&gt; find_transcoder_from
    ( <a href="#tag">tag</a>&lt;char8_t&gt;, <a href="#charset_id">charset_id</a> id ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;transcoder_finder_from_char8(id)</code> if such function pointer
is not null. Otherwise returns <code><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;char8_t, CharT&gt;{}</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, char16_t&gt; find_transcoder_to
    ( <a href="#tag">tag</a>&lt;char16_t&gt;, <a href="#charset_id">charset_id</a> id ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;transcoder_finder_to_char16(id)</code> if such function pointer
is not null. Otherwise returns <code><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, char16_t&gt;{}</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;char16_t, CharT&gt; find_transcoder_from
    ( <a href="#tag">tag</a>&lt;char16_t&gt;, <a href="#charset_id">charset_id</a> id ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;transcoder_finder_from_char16(id)</code> if such function pointer
is not null. Otherwise returns <code><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;char16_t, CharT&gt;{}</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, wchar_t&gt; find_transcoder_to
    ( <a href="#tag">tag</a>&lt;wchar_t&gt;, <a href="#charset_id">charset_id</a> id ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;transcoder_finder_to_wchar(id)</code> if such function pointer
is not null. Otherwise returns <code><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;CharT, wchar_t&gt;{}</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;wchar_t, CharT&gt; find_transcoder_from
    ( <a href="#tag">tag</a>&lt;wchar_t&gt;, <a href="#charset_id">charset_id</a> id ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;transcoder_finder_from_wchar(id)</code> if such function pointer
is not null. Otherwise returns <code><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;wchar_t, CharT&gt;{}</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="find_transcoder">4.18. Function template <code>find_transcoder</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;class SrcCharset, class DstCharset&gt;
auto find_transcoder(SrcCharset src, DstCharset dest);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements</dt>
<dd>
<p><code>SrcCharset</code> and <code>DstCharset</code> are <em><a href="#Charset">Charset</a></em> types.</p>
</dd>
<dt class="hdlist1">Return type</dt>
<dd>
<p>A type that is <em><a href="#Transcoder">Transcoder</a></em></p>
</dd>
<dt class="hdlist1">Return value</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Returns the default value of <code><a href="#static_transcoder">static_transcoder</a>&lt;SrcID, DestID&gt;</code>
if such template instantiation is defined and
<code>SrcCharset</code> is ( or derives from ) <code><a href="#static_charset">static_charset</a>&lt;SrcID&gt;</code> and
<code>DstCharset</code> is ( or derives from ) <code><a href="#static_charset">static_charset</a>&lt;DestID&gt;</code>;</p>
</li>
<li>
<p>otherwise, returns <code>src.<a href="#Charset_sanitizer">sanitizer</a>()</code> if
<code>src.<a href="#Charset_id">id</a>()</code> is equal to <code>dest.<a href="#Charset_id">id</a>()</code>
and <code>SrcCharset::<a href="#Charset_code_unit">code_unit</a></code> is the same type as <code>DstCharset::<a href="#Charset_code_unit">code_unit</a></code>;</p>
</li>
<li>
<p>otherwise, returns <code>src.<a href="#Charset_to_u32">to_u32</a>()</code>
if <code>DstCharset::<a href="#Charset_code_unit">code_unit</a></code> is <code>char32_t</code>;</p>
</li>
<li>
<p>otherwise, returns <code>dest.<a href="#Charset_from_u32">from_u32</a>()</code>
if <code>SrcCharset::<a href="#Charset_code_unit">code_unit</a></code> is <code>char32_t</code>;</p>
</li>
<li>
<p>otherwise, returns
<code>src.<a href="#Charset_find_transcoder_to">find_transcoder_to</a>(dest_ch, dest.id())</code>
if such expression
is well-formed and returns a <a href="#Transcoder_null">non null transcoder</a>
, where <code>dest_ch</code> is <code><a href="#tag">tag</a>&lt;DstCharset::<a href="#Charset_code_unit">code_unit</a>&gt;{}</code></p>
</li>
<li>
<p>otherwise, returns
<code>dest.<a href="#Charset_find_transcoder_from">find_transcoder_from</a>(src_ch, src.id())</code>
 if such expression is well-formed, where <code>src_sh</code> is <code><a href="#tag">tag</a>&lt;SrcCharset::<a href="#Charset_code_unit">code_unit</a>&gt;{}</code></p>
</li>
<li>
<p>otherwise returns <code><a href="#dynamic_transcoder">dynamic_transcoder</a>&lt;SrcCharset::<a href="#Charset_code_unit">code_unit</a>, DstCharset::<a href="#Charset_code_unit">code_unit</a>&gt;{}</code>,
<em>i.e.</em> an <a href="#Transcoder_null">null transcoder</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When <code>find_transcoder</code> returns an <a href="#Transcoder_null">null transcoder</a>
, you still can use <code><a href="#decode_encode">decode_encode</a></code> and <code>decode_encode_size</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="decode_encode_result">4.19. Struct template <code>decode_encode_result</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename CharT&gt;
struct decode_encode_result {
    const CharT* stale_src_ptr;
    DstCharT* dst_ptr;
    std::int32_t u32dist;
    <a href="#transcode_stop_reason">transcode_stop_reason</a> stop_reason;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="decode_encode_size_result">4.20. Struct template <code>decode_encode_size_result</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename CharT&gt;
struct decode_encode_size_result {
    std::ptrdiff_t ssize;
    const CharT* stale_src_ptr;
    std::int32_t u32dist;
    <a href="#transcode_stop_reason">transcode_stop_reason</a> stop_reason;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="decode_encode">4.21. Function template <code>decode_encode</code> </h3>
<div class="paragraph">
<p>The purpose of the following function templates
( <code>decode_encode</code>, <code>decode_encode_size</code>,
  <code>unsafe_decode_encode</code>, <code>unsafe_decode_encode_size</code> ) is to
  compensate the fact that the library does not provide a
  specialization of <code>static_transcoder</code>
  for every possible combination of two character encodings.
  In other words, while <code><a href="#find_transcoder">find_transcoder</a></code> may fail
  ( <em>i.e.</em>, return a <a href="#Transcoder_null">null transcoder</a> ),
  <code>decode_encode</code> works with any
  combinations of two <em><a href="#Charset">Charset</a></em> objects.</p>
</div>
<div class="paragraph">
<p><code>decode_encode</code> transcodes from one encoding to another using a pivot
buffer; <em>i.e.</em> it transcodes the input string to UTF-32 and then
from UTF-32 to the destination encoding.</p>
</div>
<div class="paragraph">
<p>The perfomance is naturally expected to be lower than of the <code>trancode</code>
function of a <em><a href="#Transcoder">Transcoder</a></em> object with the same source and destination
encodings ( assuming there is one ).
That&#8217;s why it&#8217;s usually better to use the
<code><a href="#transcode">transcode</a></code> global function template instead, which delegates to
<code>decode_encode</code> only when <code><a href="#find_transcoder">find_transcoder</a></code> fails.</p>
</div>
<div class="paragraph">
<p>There is two main sets of overloads:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#decode_encode_pointers">Overload group 1</a>: whose destination is a range of pointers</p>
</li>
<li>
<p><a href="#decode_encode_dest">Overload group 2</a>: whose destination is a <code><a href="destination_hpp.html#destination">destination</a></code> object reference
==== <code>decode_encode</code> overloads that write to a range of pointers <a id="decode_encode_pointers"></a></p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename SrcCharT, typename DstCharT&gt;
<a href="#decode_encode_result">decode_encode_result</a>&lt;SrcCharT&gt; decode_encode
    ( <a href="#charset_function_pointers">transcode_f</a>&lt;SrcCharT, char32_t&gt; to_u32
    , <a href="#charset_function_pointers">transcode_f</a>&lt;char32_t, DstCharT&gt; from_u32
    , const SrcCharT* src
    , const SrcCharT* src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>to_u32</code> is the value returned by
<code>src_charset.<a href="#Charset_to_u32">to_u32</a>().<a href="#Transcoder_transcode_func">transcode_func</a>()</code>,
where <code>src_charset</code> is a <em><a href="#Charset">Charset</a></em> object that represents the
source character encoding.</p>
</li>
<li>
<p><code>from_u32</code> is the value returned by
<code>dst_charset.<a href="#Charset_from_u32">from_u32</a>().<a href="#Transcoder_transcode_func">transcode_func</a>()</code> or
<code>dst_charset.<a href="#Charset_from_u32">from_u32</a>().<a href="#Transcoder_unsafe_transcode_func">unsafe_transcode_func</a>()</code>,
where <code>dst_charset</code> is a <em><a href="#Charset">Charset</a></em> object that represents the
destination character encoding.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p><code>decode_encode</code> has the same effects as calling
<code><em>T</em>::<a href="#Transcoder_transcode">transcode</a>(src, src_end, dst, dst_end, notifier, flags)</code>,
if <code><em>T</em></code> were a <em><a href="#Transcoder">Transcoder</a></em> class that transcodes from the source
character encoding to the destination character encoding.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Return value</dt>
<dd>
<p>A <code><a href="#decode_encode_result">decode_encode_result</a></code> value <code>res</code>, such that</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>res.<strong>stop_reason</strong></code> ( see <code><a href="#transcode_stop_reason">transcode_stop_reason</a></code>)</p>
</li>
<li>
<p><code>res.<strong>stale_src_ptr</strong></code> is <strong>not</strong> the pointer past the last read element in the input range <code>[src, src_end)</code>. Instead, it points <code>res.<strong>u32dist</strong></code> codepoints before that.</p>
<div class="paragraph">
<p>The pointer past the last read element would actually be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"> <em>src_charset</em> .<a href="#Charset_to_u32">to_u32</a>() .<a href="#Transcoder_transcode_size">transcode_size</a>
     (res.<strong>stale_ptr</strong>, src_end, res.<strong>u32dist</strong>, flags)
     .<a href="#transcode_size_result">src_ptr</a></code></pre>
</div>
</div>
<div class="paragraph">
<p>, where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><em>src_charset</em></code> is a <em><a href="#Charset">Charset</a></em> object that describes the source character encoding</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT &gt;
<a href="#decode_encode_result">decode_encode_result</a>&lt;SrcCharT&gt; decode_encode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT* src
    , const SrcCharT* src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Equivalent to</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">decode_encode
    ( src_charset.{to_u32}().{Transcoder_transcode_func}()
    , dst_charset.{from_u32}().{Transcoder_transcode_func}()
    , src, src_end, dst, dst_end, err_notifier, flags )</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharset</code> and <code>DstCharset</code> satisfy <em><a href="#Charset">Charset</a></em></p>
</li>
<li>
<p><code>SrcCharset::code_unit</code> is the same type as <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharset::code_unit</code> is the same type as <code>DstCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; template &lt;class&gt; class SrcCharsetTmpl
         , template &lt;class&gt; class DstCharsetTmpl
         , typename SrcCharT
         , typename DstCharT &gt;
<a href="#decode_encode_result">decode_encode_result</a>&lt;SrcCharT&gt; decode_encode
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect and postconditions</dt>
<dd>
<p>Equivalent to</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">decode_encode
    ( SrcCharsetTmpl&lt;SrcCharT&gt;(), DstCharsetTmpl&lt;DstCharT&gt;()
    , src, src_end, dst, dst_end, err_notifier, flags )</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>DstCharsetTmpl&lt;DstCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;::code_unit</code> is <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharsetTmpl&lt;DstCharT&gt;::code_unit</code> is <code>DstCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="decode_encode_dest"><code>decode_encode</code> overloads that write to a <code>destination&lt;DestCharT&gt;&amp;</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
template &lt;typename SrcCharT, typename DstCharT&gt;
<a href="#decode_encode_size_result">decode_encode_size_result</a>&lt;SrcCharT&gt; decode_encode
    ( <a href="#charset_function_pointers">transcode_f</a>&lt;SrcCharT, char32_t&gt; to_u32
    , <a href="#charset_function_pointers">transcode_f</a>&lt;char32_t, DstCharT&gt; from_u32
    , const SrcCharT* src
    , const SrcCharT* src_end
    , <a href="destination_hpp.html#destination">destination</a>&lt;DstCharT&gt;&amp; dst
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to the <code>decode_encode</code> overload that writes to a range of pointers
( see <a href="#decode_encode_pointers">here</a> ), but writes instead to a
<code><a href="destination_hpp.html#destination">destination</a>&lt;DstCharT&gt;&amp;</code>.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT &gt;
inline STRF_HD <a href="#decode_encode_size_result">decode_encode_size_result</a>&lt;SrcCharT&gt; decode_encode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT* src
    , const SrcCharT* src_end
    , <a href="destination_hpp.html#destination">destination</a>&lt;DstCharT&gt;&amp; dst
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none )

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">decode_encode
    ( src_charset.{to_u32}().{Transcoder_transcode_func}()
    , dst_charset.{from_u32}().{Transcoder_unsafe_transcode_func}()
    , src, src_end, dst, err_notifier, flags )</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; template &lt;class&gt; class SrcCharsetTmpl
         , template &lt;class&gt; class DstCharsetTmpl
         , typename SrcCharT
         , typename DstCharT &gt;
<a href="#decode_encode_size_result">decode_encode_size_result</a>&lt;SrcCharT&gt; decode_encode
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , <a href="destination_hpp.html#destination">destination</a>&lt;DstCharT&gt;&amp; dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">decode_encode
    ( SrcCharsetTmpl&lt;SrcCharT&gt;(), DstCharsetTmpl&lt;DstCharT&gt;()
    , src, src_end, dst, err_notifier, flags )</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="decode_encode_size">4.22. Function template <code>decode_encode_size</code></h3>
<div class="paragraph">
<p><code>decode_encode_size</code> is used to calculate the ammount of
characters that <code><a href="#decode_encode">decode_encode</a></code> writes. It also uses a pivot
buffer, which is why it&#8217;s usually better to use <code><a href="#transcode_size">transcode_size</a></code>
instead.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename SrcCharT&gt;
<a href="#decode_encode_size_result">decode_encode_size_result</a>&lt;SrcCharT&gt; decode_encode_size
    ( <a href="#charset_function_pointers">transcode_f</a>&lt;SrcCharT, char32_t&gt; to_u32
    , <a href="#charset_function_pointers">transcode_size_f</a>&lt;char32_t&gt; size_calc_func
    , const SrcCharT* src
    , const SrcCharT* src_end
    , std::ptrdiff_t limit
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions</dt>
<dd>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>to_u32</code> is the value returned by
<code>src_charset.<a href="#Charset_to_u32">to_u32</a>().<a href="#Transcoder_transcode_func">transcode_func</a>()</code>,
where <code>src_charset</code> is a <em><a href="#Charset">Charset</a></em> object that represents the
source character encoding.</p>
</li>
<li>
<p><code>size_calc_func</code> is the value returned by
<code>dst_charset.<a href="#Charset_from_u32">from_u32</a>().<a href="#Transcoder_transcode_size_func">transcode_size_func</a>()</code> or
<code>dst_charset.<a href="#Charset_from_u32">from_u32</a>().<a href="#Transcoder_unsafe_transcode_size_func">unsafe_transcode_size_func</a>()</code>
 where <code>dst_charset</code> is a <em><a href="#Charset">Charset</a></em> object that represents the
 destination character encoding.</p>
</li>
<li>
<p>All the preconditions of
<code>src_charset.<a href="#Charset_to_u32">to_u32</a>().<a href="#Transcoder_transcode_func">transcode_func</a>()</code></p>
</li>
</ul>
</div>
</div>
</div>
</dd>
<dt class="hdlist1">Return value</dt>
<dd>
<p>A <code><a href="#decode_encode_result">decode_encode_result</a></code> value <code>res</code>, such that</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>res.<strong>ssize</strong></code> is equal to <code><em>res2</em>.ssize</code></p>
</li>
<li>
<p><code>res.<strong>stop_reason</strong></code> is equal to <code><em>res2</em>.stop_reason</code></p>
</li>
<li>
<p><code>res.<strong>stale_src_ptr</strong></code> is <strong>not</strong> the pointer past the last read element in the input range <code>[src, src_end)</code>. Instead, it points <code>res.<strong>u32dist</strong></code> codepoints before that.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>, where <code><em>res2</em></code> is the value that would be returned by
<code><em>T</em>::<a href="#Transcoder_transcode_size">transcode_size</a>(src, src_end, limit, flags)</code>,
it <code><em>T</em></code> were a <em><a href="#Transcoder">Transcoder</a></em> class that transcodes from the
source character encoding to the destination character encoding.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; typename SrcCharset, typename DstCharset, typename SrcCharT &gt;
<a href="#decode_encode_size_result">decode_encode_size_result</a>&lt;SrcCharT&gt; decode_encode_size
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT* src
    , const SrcCharT* src_end
    , std::ptrdiff_t limit
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<p>Same as:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">decode_encode_size
    ( src_charset.<a href="#Charset_to_u32">to_u32</a>().<a href="#Transcoder_transcode_func">transcode_func</a>()
    , dst_charset.<a href="#Charset_from_u32">from_u32</a>().<a href="#Transcoder_unsafe_transcode_size_func">unsafe_transcode_size_func</a>()
    , src, src_end, limit, flags )</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharset</code> and <code>DstCharset</code> satisfy <em><a href="#Charset">Charset</a></em></p>
</li>
<li>
<p><code>SrcCharset::code_unit</code> is the same type as <code>SrcCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; template &lt;class&gt; class SrcCharsetTmpl
         , typename DstCharset
         , typename SrcCharT &gt;
<a href="#decode_encode_size_result">decode_encode_size_result</a>&lt;SrcCharT&gt; decode_encode_size
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , std::ptrdiff_t limit
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<p>Same as:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">decode_encode_size
    ( SrcCharsetTmpl&lt;SrcCharT&gt;(), DstCharset(), src, src_end, limit, flags )</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>SrcCharset::code_unit</code> is the same type as <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharset</code> satisfy <em><a href="#Charset">Charset</a></em></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unsafe_decode_encode">4.23. Function template <code>unsafe_decode_encode</code> </h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

1template &lt;typename SrcCharT, typename DstCharT&gt;
<a href="#decode_encode_result">decode_encode_result</a>&lt;SrcCharT&gt; unsafe_decode_encode
    ( <a href="#charset_function_pointers">transcode_f</a>&lt;SrcCharT, char32_t&gt; to_u32
    , <a href="#charset_function_pointers">transcode_f</a>&lt;char32_t, DstCharT&gt; from_u32
    , const SrcCharT* src
    , const SrcCharT* src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions</dt>
</dl>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>to_u32</code> is the value returned by
<code>src_charset.<a href="#Charset_to_u32">to_u32</a>().<a href="#Transcoder_unsafe_transcode_func">unsafe_transcode_func</a>()</code>,
where <code>src_charset</code> is a <em><a href="#Charset">Charset</a></em> object that represents the
sournce character encoding.</p>
</li>
<li>
<p><code>from_u32</code> is the value returned by
<code>dst_charset.<a href="#Charset_from_u32">from_u32</a>().<a href="#Transcoder_unsafe_transcode_func">unsafe_transcode_func</a>()</code>,
where <code>dst_charset</code> is a <em><a href="#Charset">Charset</a></em> object that represents the
destination character encoding.</p>
</li>
<li>
<p>All the perconditions of
<code>src_charset.<a href="#Charset_to_u32">to_u32</a>().<a href="#Transcoder_unsafe_transcode_func">unsafe_transcode_func</a>()</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
</dl>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p><code>unsafe_decode_encode</code> has the same effects as calling
<code><em>T</em>::<a href="#Transcoder_unsafe_transcode">unsafe_transcode</a>(src, src_end, dst, dst_end, notifier, flags)</code>,
if <code><em>T</em></code> were a <em><a href="#Transcoder">Transcoder</a></em> class that transcodes from
the source character encoding to the destination character encoding.</p>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<p>A <code><a href="#decode_encode_result">decode_encode_result</a></code> value <code>res</code>, such that</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>res.<strong>stop_reason</strong></code> is equal to <code><em>res2</em>.ssize</code></p>
</li>
<li>
<p><code>res.<strong>dst_ptr</strong></code> is equal to <code><em>res2</em>.dst_ptr</code></p>
</li>
<li>
<p><code>res.<strong>stale_src_ptr</strong></code> is <strong>not</strong> the pointer past the last read element in the input range <code>[src, src_end)</code>. Instead, it points <code>res.<strong>u32dist</strong></code> codepoints before that.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>, where <code><em>res2</em></code> is the value that would be returned by
<code><em>T</em>::<a href="#Transcoder_unsafe_transcode">unsafe_transcode</a>(src, src_end, dst, dst_end, notifier, flags)</code>,
if <code><em>T</em></code> were a <em><a href="#Transcoder">Transcoder</a></em> class that transcodes from
the source character encoding to the destination character encoding.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT &gt;
<a href="#decode_encode_result">decode_encode_result</a>&lt;SrcCharT&gt; unsafe_decode_encode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT* src
    , const SrcCharT* src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Equivalent to</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">unsafe_decode_encode
    ( src_charset.<a href="#Charset_to_u32">to_u32</a>().<a href="#Transcoder_unsafe_transcode_func">unsafe_transcode_func</a>()
    , dst_charset.<a href="#Charset_from_u32">from_u32</a>().<a href="#Transcoder_unsafe_transcode_func">unsafe_transcode_func</a>()
    , src, src_end, dst, dst_end, err_notifier, flags )</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharset</code> and <code>DstCharset</code> satisfy <em><a href="#Charset">Charset</a></em></p>
</li>
<li>
<p><code>SrcCharset::code_unit</code> is the same type as <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharset::code_unit</code> is the same type as <code>DstCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; template &lt;class&gt; class SrcCharsetTmpl
         , template &lt;class&gt; class DstCharsetTmpl
         , typename SrcCharT
         , typename DstCharT &gt;
<a href="#decode_encode_result">decode_encode_result</a>&lt;SrcCharT&gt; unsafe_decode_encode
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect and postconditions</dt>
<dd>
<p>Equivalent to</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">unsafe_decode_encode
    ( SrcCharsetTmpl&lt;SrcCharT&gt;(), DstCharsetTmpl&lt;DstCharT&gt;()
    , src, src_end, dst, dst_end, err_notifier, flags )</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>DstCharsetTmpl&lt;DstCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;::code_unit</code> is <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharsetTmpl&lt;DstCharT&gt;::code_unit</code> is <code>DstCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unsafe_decode_encode_size">4.24. Function template <code>unsafe_decode_encode_size</code></h3>
<div class="paragraph">
<p><code>unsafe_decode_encode_size</code> is used to calculate the ammount of
characters that <code>unsafe_decode_encode</code> writes.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
template &lt;typename SrcCharT&gt;
<a href="#decode_encode_size_result">decode_encode_size_result</a>&lt;SrcCharT&gt; unsafe_decode_encode_size
    ( <a href="#charset_function_pointers">transcode_f</a>&lt;SrcCharT, char32_t&gt; to_u32
    , <a href="#charset_function_pointers">transcode_size_f</a>&lt;char32_t&gt; size_calc_func
    , const SrcCharT* src
    , const SrcCharT* src_end
    , std::ptrdiff_t limit
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Preconditions</dt>
</dl>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>to_u32</code> is the value returned by
<code>src_charset.<a href="#Charset_to_u32">to_u32</a>().<a href="#Transcoder_unsafe_transcode_func">unsafe_transcode_func</a>()</code>,
where <code>src_charset</code> is a <em><a href="#Charset">Charset</a></em> object that represents the
source character encoding.</p>
</li>
<li>
<p><code>size_calc_func</code> is the value returned by
<code>dst_charset.<a href="#Charset_from_u32">from_u32</a>().<a href="#Transcoder_unsafe_transcode_size_func">unsafe_transcode_size_func</a>()</code>
 where <code>dst_charset</code> is a <em><a href="#Charset">Charset</a></em> object that represents the
 destination character encoding.</p>
</li>
<li>
<p>All the preconditions of
<code>src_charset.<a href="#Charset_to_u32">to_u32</a>().<a href="#Transcoder_unsafe_transcode_func">unsafe_transcode_func</a>()</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<p>A <code><a href="#decode_encode_result">decode_encode_result</a></code> value <code>res</code>, such that</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>res.<strong>ssize</strong></code> is equal to <code><em>res2</em>.ssize</code></p>
</li>
<li>
<p><code>res.<strong>stop_reason</strong></code> is equal to <code><em>res2</em>.stop_reason</code></p>
</li>
<li>
<p><code>res.<strong>stale_ptr</strong></code> is <strong>not</strong> the pointer past the last read element in the input range <code>[src, src_end)</code>. Instead, it points <code>res.<strong>u32dist</strong></code> codepoints before that.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>, where <code><em>res2</em></code> is the value that would be returned by
<code><em>T</em>::<a href="#Transcoder_transcode_size">unsafe_transcode_size</a>(src, src_end, limit, flags)</code>,
if <code><em>T</em></code> were a <em><a href="#Transcoder">Transcoder</a></em> class that transcodes from the source
character encoding to the destination character encoding.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; typename SrcCharset, typename DstCharset, typename SrcCharT &gt;
<a href="#decode_encode_size_result">decode_encode_size_result</a>&lt;SrcCharT&gt; unsafe_decode_encode_size
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT* src
    , const SrcCharT* src_end
    , std::ptrdiff_t limit
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<p>Same as:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">unsafe_decode_encode_size
    ( src_charset.<a href="#Charset_to_u32">to_u32</a>().<a href="#Transcoder_unsafe_transcode_func">unsafe_transcode_func</a>()
    , dst_charset.<a href="#Charset_from_u32">from_u32</a>().<a href="#Transcoder_unsafe_transcode_size_func">unsafe_transcode_size_func</a>()
    , src, src_end, limit, flags )</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharset</code> and <code>DstCharset</code> satisfy <em><a href="#Charset">Charset</a></em></p>
</li>
<li>
<p><code>SrcCharset::code_unit</code> is the same type as <code>SrcCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; template &lt;class&gt; class SrcCharsetTmpl
         , typename DstCharset
         , typename SrcCharT &gt;
<a href="#decode_encode_size_result">decode_encode_size_result</a>&lt;SrcCharT&gt; unsafe_decode_encode_size
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , std::ptrdiff_t limit
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<p>Same as:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">unsafe_decode_encode_size
    ( SrcCharsetTmpl&lt;SrcCharT&gt;(), DstCharset(), src, src_end, limit, flags )</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>SrcCharset::code_unit</code> is the same type as <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharset</code> satisfy <em><a href="#Charset">Charset</a></em></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transcode">4.25. Function template <code>transcode</code></h3>
<div class="paragraph">
<p>There is two main sets of overloads:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#transcode_pointers">Overload group 1</a>: whose destination is a range of pointers</p>
</li>
<li>
<p><a href="#transcode_to_dest">Overload group 2</a>: whose destination is a <code><a href="destination_hpp.html#destination">destination</a></code> object reference</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="transcode_pointers"><code>transcode</code> overloads that write to a range of pointers</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT &gt;
<a href="#decode_encode_result">decode_encode_result</a>&lt;SrcCharT&gt; transcode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT* src
    , const SrcCharT* src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto func = <a href="#find_transcoder">find_transcoder</a>(src_charset, dst_charset).<a href="#Transcoder_transcode_func">transcode_func</a>()
if (func != nullptr) {
    auto result = func(src, src_end, dst, dst_end, err_notifier, flags);
    return {result.ptr, result.dst_ptr, 0, result.stop_reason};
}
return <a href="#decode_encode">decode_encode</a> ( src_charset, dst_charset, src, src_end
                     , dst, dst_end, err_notifier, flags );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharset</code> and <code>DstCharset</code> satisfy <em><a href="#Charset">Charset</a></em></p>
</li>
<li>
<p><code>SrcCharset::code_unit</code> is the same type as <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharset::code_unit</code> is the same type as <code>DstCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; template &lt;class&gt; class SrcCharsetTmpl
         , template &lt;class&gt; class DstCharsetTmpl
         , typename SrcCharT, typename DstCharT &gt;
<a href="#decode_encode_result">decode_encode_result</a>&lt;SrcCharT&gt; transcode
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Same as:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">transcode
    ( SrcCharsetTmpl&lt;SrcCharT&gt;()
    , DstCharsetTmpl&lt;DstCharT&gt;()
    , src, src_end, dst, dst_end, err_notifier, flags );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>DstCharsetTmpl&lt;DstCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;::code_unit</code> is <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharsetTmpl&lt;DstCharT&gt;::code_unit</code> is <code>DstCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transcode_to_dest"><code>transcode</code> overloads that write to <code>destination&lt;DestCharT&gt;&amp;</code></h4>
<div id="transcode_1" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename SrcCharT, typename DstCharT&gt;
{ <a href="#transcode_size_result">transcode_size_result</a>&lt;SrcCharT&gt; transcode
    ( <a href="#charset_function_pointers">transcode_f</a>&lt;SrcCharT, DstCharT&gt; func
    , const SrcCharT* src
    , const SrcCharT* src_end
    , <a href="destination_hpp.html#destination">destination</a>&lt;DstCharT&gt;&amp; dst
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Contrary to the other overloads of <code>transcode</code> global function template,
this one never calls any overload of <code>decode_encode</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Uses <code>func</code> to transcode the input range (<code>src, src_end</code>), writting the
result to <code>dst</code></p>
</dd>
<dt class="hdlist1">Return value</dt>
<dd>
<p>A <code><a href="#transcode_size_result">transcode_size_result</a></code> value <code>res</code>, such that:</p>
<div class="ulist">
<ul>
<li>
<p><code>res.<strong>stop_reason</strong></code> ( see <code><a href="#transcode_stop_reason">transcode_stop_reason</a></code>)</p>
</li>
<li>
<p><code>res.<strong>src_ptr</strong></code> points immediately after the last element in the range <code>[src, src_end)</code>
that has been transcoded.</p>
</li>
<li>
<p><code>res.<strong>ssize</strong></code> is the amount of code units written to <code>dst</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT &gt;
<a href="#decode_encode_size_result">decode_encode_size_result</a>&lt;SrcCharT&gt; transcode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT* src
    , const SrcCharT* src_end
    , <a href="destination_hpp.html#destination">destination</a>&lt;DstCharT&gt;&amp; dst
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto func = <a href="#find_transcoder">find_transcoder</a>(src_charset, dst_charset).<a href="#Transcoder_transcode_func">transcode_func</a>();
if (func != nullptr) {
    auto result = <a href="#transcode_1">trancode</a>(src, src_end, dst, err_notifier, flags);
    return {result.ssize, result.src_ptr, 0, result.stop_reason};
}
const auto src_to_u32 = src_charset.to_u32().transcode_func();
const auto u32_to_dst = dst_charset.from_u32().unsafe_transcode_func();
return <a href="#decode_encode_dest">decode_encode</a>
    ( src_to_u32, u32_to_dst
    , src, src_end, dst, err_notifier, flags );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharset</code> and <code>DstCharset</code> satisfy <em><a href="#Charset">Charset</a></em></p>
</li>
<li>
<p><code>SrcCharset::code_unit</code> is the same type as <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharset::code_unit</code> is the same type as <code>DstCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; template &lt;class&gt; class SrcCharsetTmpl
         , template &lt;class&gt; class DstCharsetTmpl
         , typename SrcCharT, typename DstCharT &gt;
<a href="#decode_encode_result">decode_encode_result</a>&lt;SrcCharT&gt; transcode
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , <a href="destination_hpp.html#destination">destination</a>&lt;DstCharT&gt;&amp; dst
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Same as:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">transcode
    ( SrcCharsetTmpl&lt;SrcCharT&gt;()
    , DstCharsetTmpl&lt;DstCharT&gt;()
    , src, src_end, dst, err_notifier, flags );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>DstCharsetTmpl&lt;DstCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;::code_unit</code> is <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharsetTmpl&lt;DstCharT&gt;::code_unit</code> is <code>DstCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transcode_size">4.26. Function template <code>transcode_size</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; typename SrcCharset, typename DstCharset, typename SrcCharT &gt;
<a href="#decode_encode_size_result">decode_encode_size_result</a>&lt;SrcCharT&gt; transcode_size
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT* src
    , const SrcCharT* src_end
    , std::ptrdiff_t limit
    , strf::transcode_flags flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect and Return value</dt>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto func = <a href="#find_transcoder">find_transcoder</a>(src_charset, dst_charset).<a href="#Transcoder_transcode_size_func">transcode_size_func</a>()
if (func != nullptr) {
    auto result = func(src, src_end, limit, flags);
    return {result.ssize, result.src_ptr, 0, result.stop_reason};
}
return <a href="#decode_encode_size">decode_encode_size</a> (src_charset, dst_charset, src, src_end, limit, flags);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharset</code> and <code>DstCharset</code> satisfy <em><a href="#Charset">Charset</a></em></p>
</li>
<li>
<p><code>SrcCharset::code_unit</code> is the same type as <code>SrcCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; template &lt;class&gt; class SrcCharsetTmpl
         , typename DstCharset
         , typename SrcCharT &gt;
<a href="#decode_encode_size_result">decode_encode_size_result</a>&lt;SrcCharT&gt; transcode_size
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , std::ptrdiff_t limit
    , strf::transcode_flags flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect and Return value</dt>
<dd>
<p>Same as</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">transcode_size
    ( SrcCharsetTmpl&lt;SrcCharT&gt;(), DstCharset(), src, src_end, limit, flags )</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>DstCharset</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;::code_unit</code> is <code>SrcCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unsafe_transcode">4.27. Function template <code>unsafe_transcode</code></h3>
<div class="paragraph">
<p>There is two main sets of overloads:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#unsafe_transcode_pointers">Overload group 1</a>: whose destination is a range of pointers</p>
</li>
<li>
<p><a href="#unsafe_transcode_to_dest">Overload group 2</a>: whose destination is a <code><a href="destination_hpp.html#destination">destination</a></code> object reference</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="unsafe_transcode_pointers"><code>unsafe_transcode</code> overloads that write to a range of pointers</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT &gt;
void unsafe_transcode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT* src
    , const SrcCharT* src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto func = <a href="#find_transcoder">find_transcoder</a>(src_charset, dst_charset).<a href="#Transcoder_unsafe_transcode_func">unsafe_transcode_func</a>()
if (func != nullptr) {
    auto res = func(src, src_end, dst, dst_end, err_notifier);
    return {res.src_ptr, res.dst_ptr, 0, res.stop_reason};
}
return <a href="#unsafe_decode_encode">unsafe_decode_encode</a>
        ( src_charset, dst_charset, src, src_end, dst, dst_end, err_notifier, flags );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharset</code> and <code>DstCharset</code> satisfy <em><a href="#Charset">Charset</a></em></p>
</li>
<li>
<p><code>SrcCharset::code_unit</code> is the same type as <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharset::code_unit</code> is the same type as <code>DstCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; template &lt;class&gt; class SrcCharsetTmpl
         , template &lt;class&gt; class DstCharsetTmpl
         , typename SrcCharT, typename DstCharT &gt;
void unsafe_transcode
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , DstCharT* dst
    , DstCharT* dst_end
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Same as:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">unsafe_transcode
    ( SrcCharsetTmpl&lt;SrcCharT&gt;()
    , DstCharsetTmpl&lt;DstCharT&gt;()
    , src, src_end, dst, dst_end, err_notifier, flags );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>DstCharsetTmpl&lt;DstCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;::code_unit</code> is <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharsetTmpl&lt;DstCharT&gt;::code_unit</code> is <code>DstCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="unsafe_transcode_to_dest"><code>unsafe_transcode</code> overloads that write to <code>destination&lt;DestCharT&gt;&amp;</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; typename SrcCharset, typename DstCharset
         , typename SrcCharT, typename DstCharT &gt;
<a href="#decode_encode_size_result">decode_encode_size_result</a>&lt;SrcCharT&gt; unsafe_transcode
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT* src
    , const SrcCharT* src_end
    , <a href="destination_hpp.html#destination">destination</a>&lt;DstCharT&gt;&amp; dst
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto func = <a href="#find_transcoder">find_transcoder</a>(src_charset, dst_charset).<a href="#Transcoder_unsafe_transcode_func">unsafe_transcode_func</a>();
if (func != nullptr) {
    auto result = <a href="#transcode_1">trancode</a>(src, src_end, dst, err_notifier, flags);
    return {result.ssize, result.src_ptr, 0, result.stop_reason};
}
const auto src_to_u32 = src_charset.to_u32().unsafe_transcode_func();
const auto u32_to_dst = dst_charset.from_u32().unsafe_transcode_func();
return <a href="#decode_encode_dest">decode_encode</a>
    ( src_to_u32, u32_to_dst
    , src, src_end, dst, err_notifier, flags );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharset</code> and <code>DstCharset</code> satisfy <em><a href="#Charset">Charset</a></em></p>
</li>
<li>
<p><code>SrcCharset::code_unit</code> is the same type as <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharset::code_unit</code> is the same type as <code>DstCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; template &lt;class&gt; class SrcCharsetTmpl
         , template &lt;class&gt; class DstCharsetTmpl
         , typename SrcCharT, typename DstCharT &gt;
<a href="#decode_encode_result">decode_encode_result</a>&lt;SrcCharT&gt; unsafe_transcode
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , <a href="destination_hpp.html#destination">destination</a>&lt;DstCharT&gt;&amp; dst
    , <a href="#transcoding_error_notifier">transcoding_error_notifier</a>* err_notifier = nullptr
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Same as:</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">unsafe_transcode
    ( SrcCharsetTmpl&lt;SrcCharT&gt;()
    , DstCharsetTmpl&lt;DstCharT&gt;()
    , src, src_end, dst, err_notifier, flags );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>DstCharsetTmpl&lt;DstCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;::code_unit</code> is <code>SrcCharT</code></p>
</li>
<li>
<p><code>DstCharsetTmpl&lt;DstCharT&gt;::code_unit</code> is <code>DstCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="unsafe_transcode_size">4.28. Function template <code>unsafe_transcode_size</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; typename SrcCharset, typename DstCharset, typename SrcCharT &gt;
std::ptrdiff_t unsafe_transcode_size
    ( SrcCharset src_charset
    , DstCharset dst_charset
    , const SrcCharT* src
    , const SrcCharT* src_end
    , std::ptrdiff_t limit
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect and Return value</dt>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto func = <a href="#find_transcoder">find_transcoder</a>(src_charset, dst_charset).<a href="#Transcoder_unsafe_transcode_size_func">unsafe_transcode_size_func</a>()
if (func != nullptr) {
    auto res = func(src, src_end, limit, flags);
    return {res.ssize, res.src_ptr, 0, res.stop_reason}
}
return <a href="#unsafe_decode_encode_size">unsafe_decode_encode_size</a> (src_charset, dst_charset, src, src_end, limit, flags);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharset</code> and <code>DstCharset</code> satisfy <em><a href="#Charset">Charset</a></em></p>
</li>
<li>
<p><code>SrcCharset::code_unit</code> is the same type as <code>SrcCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; template &lt;class&gt; class SrcCharsetTmpl
         , typename DstCharset
         , typename SrcCharT &gt;
std::ptrdiff_t unsafe_transcode_size
    ( const SrcCharT* src
    , const SrcCharT* src_end
    , std::ptrdiff_t limit
    , <a href="#transcode_flags">transcode_flags</a> flags = transcode_flags::none );

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect and Return value</dt>
<dd>
<p>Same as</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">unsafe_transcode_size
    ( SrcCharsetTmpl&lt;SrcCharT&gt;(), DstCharset(), src, src_end, limit, flags )</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>DstCharset</code> is an instance of <code><a href="#static_charset">static_charset</a></code></p>
</li>
<li>
<p><code>SrcCharsetTmpl&lt;SrcCharT&gt;::code_unit</code> is <code>SrcCharT</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="static_charset_aliases">4.29. Type aliases for charsets</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;class CharT&gt;
using ascii_t = static_charset&lt;CharT, scid_ascii&gt;;

template &lt;class CharT&gt;
using iso_8859_1_t = static_charset&lt;CharT, scid_iso_8859_1&gt;;

template &lt;class CharT&gt;
using iso_8859_2_t = static_charset&lt;CharT, scid_iso_8859_2&gt;;

template &lt;class CharT&gt;
using iso_8859_3_t = static_charset&lt;CharT, scid_iso_8859_3&gt;;

template &lt;class CharT&gt;
using iso_8859_4_t = static_charset&lt;CharT, scid_iso_8859_4&gt;;

template &lt;class CharT&gt;
using iso_8859_5_t = static_charset&lt;CharT, scid_iso_8859_5&gt;;

template &lt;class CharT&gt;
using iso_8859_6_t = static_charset&lt;CharT, scid_iso_8859_6&gt;;

template &lt;class CharT&gt;
using iso_8859_7_t = static_charset&lt;CharT, scid_iso_8859_7&gt;;

template &lt;class CharT&gt;
using iso_8859_8_t = static_charset&lt;CharT, scid_iso_8859_8&gt;;

template &lt;class CharT&gt;
using iso_8859_9_t = static_charset&lt;CharT, scid_iso_8859_9&gt;;

template &lt;class CharT&gt;
using iso_8859_10_t = static_charset&lt;CharT, scid_iso_8859_10&gt;;

template &lt;class CharT&gt;
using iso_8859_11_t = static_charset&lt;CharT, scid_iso_8859_11&gt;;

template &lt;class CharT&gt;
using iso_8859_13_t = static_charset&lt;CharT, scid_iso_8859_13&gt;;

template &lt;class CharT&gt;
using iso_8859_14_t = static_charset&lt;CharT, scid_iso_8859_14&gt;;

template &lt;class CharT&gt;
using iso_8859_15_t = static_charset&lt;CharT, scid_iso_8859_15&gt;;

template &lt;class CharT&gt;
using iso_8859_16_t = static_charset&lt;CharT, scid_iso_8859_16&gt;;

template &lt;class CharT&gt;
using windows_1250_t = static_charset&lt;CharT, scid_windows_1250&gt;;

template &lt;class CharT&gt;
using windows_1251_t = static_charset&lt;CharT, scid_windows_1251&gt;;

template &lt;class CharT&gt;
using windows_1252_t = static_charset&lt;CharT, scid_windows_1252&gt;;

template &lt;class CharT&gt;
using windows_1253_t = static_charset&lt;CharT, scid_windows_1253&gt;;

template &lt;class CharT&gt;
using windows_1254_t = static_charset&lt;CharT, scid_windows_1254&gt;;

template &lt;class CharT&gt;
using windows_1255_t = static_charset&lt;CharT, scid_windows_1255&gt;;

template &lt;class CharT&gt;
using windows_1256_t = static_charset&lt;CharT, scid_windows_1256&gt;;

template &lt;class CharT&gt;
using windows_1257_t = static_charset&lt;CharT, scid_windows_1257&gt;;

template &lt;class CharT&gt;
using windows_1258_t = static_charset&lt;CharT, scid_windows_1258&gt;;

template &lt;class CharT&gt;
using utf8_t = static_charset&lt;CharT, scid_utf8&gt;;

template &lt;class CharT&gt;
using utf16_t = static_charset&lt;CharT, scid_utf16&gt;;

template &lt;class CharT&gt;
using utf32_t = static_charset&lt;CharT, scid_utf32&gt;;

template &lt;class CharT&gt;
using utf_t = /* see below */;

} // namespace strf</code></pre>
</div>
</div>
<div id="utf_t" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;class CharT&gt;
using utf_t = /* ... */;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>utf_t&lt;CharT&gt;</code> is an alias to <code>utf8_t&lt;CharT&gt;</code>, <code>utf16_t&lt;CharT&gt;</code> or <code>utf32_t&lt;CharT&gt;</code>,
depending on the value of <code>sizeof(CharT)</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="static_charset_constexpr">4.30. Template variable for charsets</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;class CharT&gt; constexpr ascii_t&lt;CharT&gt;         ascii = {};

template &lt;class CharT&gt; constexpr iso_8859_1_t&lt;CharT&gt;    iso_8859_1 = {};
template &lt;class CharT&gt; constexpr iso_8859_2_t&lt;CharT&gt;    iso_8859_2 = {};
template &lt;class CharT&gt; constexpr iso_8859_3_t&lt;CharT&gt;    iso_8859_3 = {};
template &lt;class CharT&gt; constexpr iso_8859_4_t&lt;CharT&gt;    iso_8859_4 = {};
template &lt;class CharT&gt; constexpr iso_8859_5_t&lt;CharT&gt;    iso_8859_5 = {};
template &lt;class CharT&gt; constexpr iso_8859_6_t&lt;CharT&gt;    iso_8859_6 = {};
template &lt;class CharT&gt; constexpr iso_8859_7_t&lt;CharT&gt;    iso_8859_7 = {};
template &lt;class CharT&gt; constexpr iso_8859_8_t&lt;CharT&gt;    iso_8859_8 = {};
template &lt;class CharT&gt; constexpr iso_8859_9_t&lt;CharT&gt;    iso_8859_9 = {};
template &lt;class CharT&gt; constexpr iso_8859_10_t&lt;CharT&gt;   iso_8859_10 = {};
template &lt;class CharT&gt; constexpr iso_8859_11_t&lt;CharT&gt;   iso_8859_11 = {};
template &lt;class CharT&gt; constexpr iso_8859_13_t&lt;CharT&gt;   iso_8859_13 = {};
template &lt;class CharT&gt; constexpr iso_8859_14_t&lt;CharT&gt;   iso_8859_14 = {};
template &lt;class CharT&gt; constexpr iso_8859_15_t&lt;CharT&gt;   iso_8859_15 = {};
template &lt;class CharT&gt; constexpr iso_8859_16_t&lt;CharT&gt;   iso_8859_16 = {};

template &lt;class CharT&gt; constexpr windows_1250_t&lt;CharT&gt;  windows_1250 = {};
template &lt;class CharT&gt; constexpr windows_1251_t&lt;CharT&gt;  windows_1251 = {};
template &lt;class CharT&gt; constexpr windows_1252_t&lt;CharT&gt;  windows_1252 = {};
template &lt;class CharT&gt; constexpr windows_1253_t&lt;CharT&gt;  windows_1253 = {};
template &lt;class CharT&gt; constexpr windows_1254_t&lt;CharT&gt;  windows_1254 = {};
template &lt;class CharT&gt; constexpr windows_1255_t&lt;CharT&gt;  windows_1255 = {};
template &lt;class CharT&gt; constexpr windows_1256_t&lt;CharT&gt;  windows_1256 = {};
template &lt;class CharT&gt; constexpr windows_1257_t&lt;CharT&gt;  windows_1257 = {};
template &lt;class CharT&gt; constexpr windows_1258_t&lt;CharT&gt;  windows_1258 = {};

template &lt;class CharT&gt; constexpr utf8_t&lt;CharT&gt;          utf8 = {};
template &lt;class CharT&gt; constexpr utf16_t&lt;CharT&gt;         utf16 = {};
template &lt;class CharT&gt; constexpr utf32_t&lt;CharT&gt;         utf32 = {};
template &lt;class CharT&gt; constexpr <a href="#utf_t">utf_t</a>&lt;CharT&gt;           utf = {};

} // namespace strf</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="width_calculation">5. Width Calculation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="width_calculator_c">5.1. Facet category <code>width_calculator_c</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

struct width_calculator_c
{
    static constexpr bool constrainable = true;

    static constexpr <a href="#width_as_u32len">width_as_u32len</a> get_default() noexcept;
};

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a type to be a facet of the <code>width_calculator_c</code> category, it has to
satisfy the <em><a href="#WidthCalculator">WidthCalculator</a></em> requirements.</p>
</div>
<div class="sect3">
<h4 id="WidthCalculator">Type requirement <em>WidthCalculator</em></h4>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CharT</code>, one of the types: <code>char</code>, <code>char8_t</code>, <code>char16_t</code>, <code>char32_t</code> or <code>wchar_t</code></p>
</li>
<li>
<p><code>CharsetT</code>, a <em><a href="#Charset">Charset</a></em> type for type <code>CharT</code></p>
</li>
<li>
<p><code>charset</code>, a value of type <code>CharsetT</code></p>
</li>
<li>
<p><code>ch</code> a value of type <code>CharT</code></p>
</li>
<li>
<p><code>limit</code>, a value of type <code><a href="#width_t">width_t</a></code></p>
</li>
<li>
<p><code>str</code>, a value of type <code>const CharT*</code>
pointing to a string encoded according to <code>charset</code>.</p>
</li>
<li>
<p><code>str_end</code>, a value of type <code>const CharT*</code> pointing immediately after
the last character of the string that begin at <code>str</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a type <code>X</code> to be a <em>WidthCalculator</em>, given an object <code>x</code> of type <code>X</code>,
the following syntax and requirements have to be satisfied:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">X::category</code></pre>
</div>
</div>
<div class="paragraph">
<p>A type alias to <code><a href="#width_calculator_c">width_calculator_c</a></code>.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.char_width(charset, ch)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#width_t">width_t</a></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The width of <code>ch</code> when encoded according to <code>charset</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.str_width(charset, limit, str, str_end)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#width_t">width_t</a></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The width of the string <code>str</code> if it is less than <code>limit</code>.
Otherwise, it can be any value that is greater than or
equal to <code>limit</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">x.str_width_and_pos(charset, limit, str, str_end)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calculates the size and width of the longest substring
of [<code>str</code>, <code>str_end</code>) whose width is not greater than <code>limit</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#width_and_ptr">width_and_ptr</a>&lt;CharT&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A value <code>ret</code> of type <code><a href="#width_and_ptr">width_and_ptr</a>&lt;CharT&gt;</code>, such that</p>
<div class="ulist">
<ul>
<li>
<p><code>ret.ptr</code> is the greatest pointer not greater than <code>str_end</code>
such that the width of [<code>str</code>, <code>ret.ptr</code>)
is not greater than <code>limit</code>.</p>
</li>
<li>
<p><code>ret.width</code> is the width of the substring  [<code>str</code>, <code>ret.ptr</code>).</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The library provides three classes that
      satisfy <em>WidthCalculator</em>: <code><a href="#fast_width">fast_width</a></code>, <code><a href="#width_as_fast_u32len">width_as_fast_u32len</a></code>,
      <code><a href="#width_as_u32len">width_as_u32len</a></code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="width_and_ptr">Struct <code>width_and_ptr</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename CharT&gt;
struct width_and_ptr {
    <a href="#width_t">width_t</a> width;
    const CharT* ptr = nullptr;
};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fast_width">5.2. Class <code>fast_width_t</code></h3>
<div class="paragraph">
<p>Class <code>fast_width_t</code> is a facet of the category <code><a href="#width_calculator_c">width_calculator_c</a></code>
that evaluates the width of a string as its size.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">class fast_width_t final
{
public:
    using category = <a href="#width_calculator_c">width_calculator_c</a>;

    template &lt;typename Charset&gt;
    constexpr <a href="#width_t">width_t</a> <a href="#fast_width_char_width">char_width</a>
        ( Charset
        , typename Charset::<a href="#Charset_code_unit">code_unit</a> ) const noexcept;

    template &lt;typename Charset&gt;
    constexpr <a href="#width_t">width_t</a> <a href="#fast_width_str_width">str_width</a>
        ( Charset
        , <a href="#width_t">width_t</a> limit
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const noexcept;

    template &lt;typename Charset&gt;
    auto <a href="#fast_width_str_width_and_pos">str_width_and_pos</a>
        ( Charset
        , <a href="#width_t">width_t</a> limit
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const noexcept
        -&gt; <a href="#width_and_ptr">width_and_ptr</a>&lt;typename Charset::<a href="#Charset_code_unit">code_unit</a>&gt;;
};

constexpr fast_width_t fast_width {};</code></pre>
</div>
</div>
<div id="fast_width_char_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
constexpr <a href="#width_t">width_t</a> char_width
    ( Charset
    , typename Charset::<a href="#Charset_code_unit">code_unit</a> ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>1</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="fast_width_str_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
constexpr <a href="#width_t">width_t</a> str_width
    ( Charset
    , <a href="#width_t">width_t</a> limit
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p>0, if <code>limit</code> is not positive</p>
</li>
<li>
<p>otherwise the length of [<code>str</code>, <code>str_end</code>) , if such length is not greater than <code>limit</code></p>
</li>
<li>
<p>otherwise, <code>limit</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="fast_width_str_width_and_pos" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
auto str_width_and_pos
    ( Charset
    , <a href="#width_t">width_t</a> limit
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const noexcept
    -&gt; <a href="#width_and_ptr">width_and_ptr</a>&lt;typename Charset::<a href="#Charset_code_unit">code_unit</a>&gt;;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The return value <code>ret</code> is such that</p>
<div class="ulist">
<ul>
<li>
<p>If <code>limit</code> is not positive, then <code>ret.width</code> is <code>0</code> and <code>ret.ptr</code> is <code>str</code></p>
</li>
<li>
<p>otherwise, if <code>limit.floor()</code> is less than the length of [<code>str</code>, <code>str_end</code>),
then <code>ret.width</code> is equal to <code>limit.floor()</code>
and <code>ret.ptr</code> is equal to <code>str + limit.floor()</code></p>
</li>
<li>
<p>otherwise, <code>ret.width</code> is equal to the length of [<code>str</code>, <code>str_end</code>),
and <code>ret.ptr</code> is equal to <code>str_end</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="width_as_fast_u32len">5.3. Class <code>width_as_fast_u32len_t</code></h3>
<div class="paragraph">
<p>Class <code>width_as_fast_u32len_t</code> is a facet of the category <code><a href="#width_calculator_c">width_calculator_c</a></code>.
It evaluates the width of a string as the number of Unicode code points.
However, to gain performance, differently from <code><a href="#width_as_u32len">width_as_u32len</a></code>,
it assumes that the string is totally conformant to its encoding.
For example, if the charset is UTF-8 then <code>str_width</code>
may simply return the number of bytes whose bit pattern does not
characterizes it as a <a href="https://en.wikipedia.org/wiki/UTF-8#Encoding">continuation byte</a>
( <code>10xxxxxx</code> ).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">class width_as_fast_u32len_t final
{
public:
    using category = <a href="#width_calculator_c">width_calculator_c</a>;

    template &lt;typename Charset&gt;
    constexpr <a href="#width_t">width_t</a> <a href="#width_as_fast_u32len_char_width">char_width</a>
        ( Charset cs
        , typename Charset::<a href="#Charset_code_unit">code_unit</a> ) const noexcept;

    template &lt;typename Charset&gt;
    <a href="#width_t">width_t</a> <a href="#width_as_fast_u32len_str_width">str_width</a>
        ( Charset cs
        , <a href="#width_t">width_t</a> limit
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const noexcept;

    template &lt;typename Charset&gt;
    auto <a href="#width_as_fast_u32len_str_width_and_pos">str_width_and_pos</a>
        ( Charset cs
        , <a href="#width_t">width_t</a> limit
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const noexcept
        -&gt; <a href="#width_and_ptr">width_and_ptr</a>&lt;typename Charset::<a href="#Charset_code_unit">code_unit</a>&gt;;
};

constexpr width_as_fast_u32len_t width_as_fast_u32len {};</code></pre>
</div>
</div>
<div id="width_as_fast_u32len_char_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
constexpr <a href="#width_t">width_t</a> char_width
    ( Charset
    , typename Charset::<a href="#Charset_code_unit">code_unit</a> ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>1</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="width_as_fast_u32len_str_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
<a href="#width_t">width_t</a> str_width
    ( Charset cs
    , <a href="#width_t">width_t</a> limit
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>0</code>, if <code>limit</code> is not positive</p>
</li>
<li>
<p>otherwise,
<code>cs.<a href="#Charset_count_codepoints_fast">count_codepoints_fast</a>(str, str_end, limit.ceil()).count</code>,
 if such value is not greater than <code>width_t::max</code>,</p>
</li>
<li>
<p>otherwise, <code>width_t::max</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="width_as_fast_u32len_str_width_and_pos" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
auto str_width_and_pos
    ( Charset cs
    , <a href="#width_t">width_t</a> limit
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const noexcept
    -&gt; <a href="#width_and_ptr">width_and_ptr</a>&lt;typename Charset::<a href="#Charset_code_unit">code_unit</a>&gt;;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The return value <code>ret</code> is such that</p>
<div class="ulist">
<ul>
<li>
<p>If <code>limit</code> is not positive, then <code>ret.width</code> is <code>0</code> and <code>ret.ptr</code> is <code>str</code>;</p>
</li>
<li>
<p>otherwise, <code>ret.width</code> is equal to <code>ret2.count</code> and <code>ret.ptr</code> is equal to <code>ret2.ptr</code>,
where <code>ret2</code> is the return of
<code>cs.<a href="#Charset_count_codepoints_fast">count_codepoints_fast</a>(str, str_end, lim.floor())</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="width_as_u32len">5.4. Class <code>width_as_u32len_t</code></h3>
<div class="paragraph">
<p>Class <code>width_as_fast_u32len_t</code> is a facet of the category <code><a href="#width_calculator_c">width_calculator_c</a></code>.
It evaluates the width of a string as the number of Unicode code points,
assuming that any non-conformity to its corresponding charset is replaced
by one codepoint ( since it should be replaced by the
<a href="https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character">replacement character <code>"\uFFFD"</code> (&#65533;) </a> ).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">class width_as_u32len_t final
{
public:
    using category = <a href="#width_calculator_c">width_calculator_c</a>;

    template &lt;typename Charset&gt;
    constexpr <a href="#width_t">width_t</a> <a href="#width_as_u32len_char_width">char_width</a>
        ( Charset cs
        , typename Charset::<a href="#Charset_code_unit">code_unit</a> ) const noexcept;

    template &lt;typename Charset&gt;
    <a href="#width_t">width_t</a> <a href="#width_as_u32len_str_width">str_width</a>
        ( Charset cs
        , <a href="#width_t">width_t</a> limit
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const noexcept;

    template &lt;typename Charset&gt;
    auto <a href="#width_as_u32len_str_width_and_pos">str_width_and_pos</a>
        ( Charset cs
        , <a href="#width_t">width_t</a> limit
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const noexcept
        -&gt; <a href="#width_and_ptr">width_and_ptr</a>&lt;typename Charset::<a href="#Charset_code_unit">code_unit</a>&gt;;
};

constexpr width_as_u32len_t width_as_u32len = {};</code></pre>
</div>
</div>
<div id="width_as_u32len_char_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
constexpr <a href="#width_t">width_t</a> char_width
    ( Charset
    , typename Charset::<a href="#Charset_code_unit">code_unit</a> ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>1</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="width_as_u32len_str_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
<a href="#width_t">width_t</a> str_width
    ( Charset cs
    , <a href="#width_t">width_t</a> limit
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>0</code>, if <code>limit</code> is not positive</p>
</li>
<li>
<p>otherwise,
<code>cs.<a href="#Charset_count_codepoints">count_codepoints</a>(str, str_end, limit.ceil()).count</code>,
 if such value is not greater than <code>width_t::max</code>,</p>
</li>
<li>
<p>otherwise, <code>width_t::max</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="width_as_u32len_str_width_and_pos" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
auto str_width_and_pos
    ( Charset cs
    , <a href="#width_t">width_t</a> limit
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const noexcept
    -&gt; <a href="#width_and_ptr">width_and_ptr</a>&lt;typename Charset::<a href="#Charset_code_unit">code_unit</a>&gt;;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The return value <code>ret</code> is such that</p>
<div class="ulist">
<ul>
<li>
<p>If <code>limit</code> is not positive, then <code>ret.width</code> is <code>0</code> and <code>ret.ptr</code> is <code>str</code>;</p>
</li>
<li>
<p>otherwise, <code>ret.width</code> is equal to <code>ret2.count</code> and <code>ret.ptr</code> is equal to <code>ret2.ptr</code>,
where <code>ret2</code> is the return of
<code>cs.<a href="#Charset_count_codepoints">count_codepoints</a>(str, str_end, lim.floor())</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="std_width_calc">5.5. Class <code>std_width_calc</code></h3>
<div class="paragraph">
<p>The facet <code>std_width_calc</code> calculates the width just as
<a href="https://timsong-cpp.github.io/cppwp/n4868/format#string.std-11">specified</a> to <code>std::format</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">class std_width_calc {
public:
    using category = <a href="#width_calculator_c">width_calculator_c</a>;

    template &lt;typename Charset&gt;
    static <a href="#width_t">width_t</a> <a href="#std_width_calc_char_width">char_width</a>
        ( Charset cs
        , typename Charset::<a href="#Charset_code_unit">code_unit</a> ) const;

    template &lt;typename Charset&gt;
    static <a href="#width_t">width_t</a> <a href="#std_width_calc_str_width">str_width</a>
        ( Charset cs
        , <a href="#width_t">width_t</a> limit
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const;

    template &lt;typename Charset&gt;
    static auto <a href="#std_width_calc_str_width_and_pos">str_width_and_pos</a>
        ( Charset cs
        , <a href="#width_t">width_t</a> limit
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
        , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const
        -&gt; <a href="#width_and_ptr">width_and_ptr</a>&lt;typename Charset::<a href="#Charset_code_unit">code_unit</a>&gt;;
};</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_member_functions">Member functions</h4>
<div id="std_width_calc_char_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
static <a href="#width_t">width_t</a> char_width
    ( Charset cs
    , typename Charset::<a href="#Charset_code_unit">code_unit</a> ch) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"> (  (0x1100 &lt;= ch32 &amp;&amp; ch32 &lt;= 0x115F)
||  (0x2329 &lt;= ch32 &amp;&amp; ch32 &lt;= 0x232A)
||  (0x2E80 &lt;= ch32 &amp;&amp; ch32 &lt;= 0x303E)
||  (0x3040 &lt;= ch32 &amp;&amp; ch32 &lt;= 0xA4CF)
||  (0xAC00 &lt;= ch32 &amp;&amp; ch32 &lt;= 0xD7A3)
||  (0xF900 &lt;= ch32 &amp;&amp; ch32 &lt;= 0xFAFF)
||  (0xFE10 &lt;= ch32 &amp;&amp; ch32 &lt;= 0xFE19)
||  (0xFE30 &lt;= ch32 &amp;&amp; ch32 &lt;= 0xFE6F)
||  (0xFF00 &lt;= ch32 &amp;&amp; ch32 &lt;= 0xFF60)
||  (0xFFE0 &lt;= ch32 &amp;&amp; ch32 &lt;= 0xFFE6)
|| (0x1F300 &lt;= ch32 &amp;&amp; ch32 &lt;= 0x1F64F)
|| (0x1F900 &lt;= ch32 &amp;&amp; ch32 &lt;= 0x1F9FF)
|| (0x20000 &lt;= ch32 &amp;&amp; ch32 &lt;= 0x2FFFD)
|| (0x30000 &lt;= ch32 &amp;&amp; ch32 &lt;= 0x3FFFD) )  ? width_t(2) : width_t(1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>, where <code>ch32</code> is the return value of <code>cs.decode_unit(ch)</code></p>
</div>
</div>
</div>
<div id="std_width_calc_str_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
static <a href="#width_t">width_t</a> str_width
    ( Charset cs
    , <a href="#width_t">width_t</a> limit
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<p><code>std::min(limit, w)</code>, where <code>w</code> is the sum
of the grapheme clusters widths in the UTF-32 string
obtained by converting <code>str</code> to UTF-32 via <code>cs</code>, <em>i.e.</em> by calling</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">cs.<a href="#Charset_to_u32">to_u32</a>().<a href="#Transcoder_transcode">transcode</a>(str, str_end, /* &#8230;&#8203; */, nullptr )</code></pre>
</div>
</div>
<div class="paragraph">
<p>The width of each grapheme cluster is assumed to be equal to the width
of its first codepoints <code>ch32</code>, which is assumed to equal to
<code><a href="#std_width_calc_char_width">char_width</a>(<a href="strf_hpp.html.html#static_charset_constexpr">utf</a>&lt;char32_t&gt;, ch32)</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="std_width_calc_str_width_and_pos" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Charset&gt;
static auto str_width_and_pos
    ( Charset cs
    , <a href="#width_t">width_t</a> limit
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str
    , const typename Charset::<a href="#Charset_code_unit">code_unit</a>* str_end ) const
    -&gt; <a href="#width_and_ptr">width_and_ptr</a>&lt;typename Charset::<a href="#Charset_code_unit">code_unit</a>&gt;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<p>a value <code>r</code> such that</p>
<div class="ulist">
<ul>
<li>
<p><code>r.width</code> is same value returned by <code>str_width(cs, limit, str, str_end )</code></p>
</li>
<li>
<p><code>r.ptr</code> is greatest pointer not greater than <code>str_end</code> such that the expression
below evaluates to <code>true</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">str_width(cs, strf::width_t::max(), str, r.ptr) &lt;= limit</code></pre>
</div>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="width_t">5.6. Class <code>width_t</code></h3>
<div class="paragraph">
<p><code>width_t</code> is an signed type that implements
<a href="https://en.wikipedia.org/wiki/Q_(number_format)">Q16.16</a> arithmetics and
is used to represent width of textual content when
<a href="#alignment_format">text alignment formatting</a> is used.
The value of <code>width_t(1)</code> corresponds to one <a href="https://en.wikipedia.org/wiki/En_(typography)">en</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

class width_t {
public:
    struct from_underlying_tag{};
    constexpr width_t() noexcept;
    constexpr width_t(std::integral auto) noexcept;
    constexpr width_t(const width_t&amp;) noexcept;
    constexpr width_t(from_underlying_tag, std::int32_t) noexcept;

    constexpr width_t&amp; operator=(const width_t&amp; other) noexcept;
    constexpr width_t&amp; operator=(std::int16_t&amp; x) noexcept;

    constexpr bool operator==(const width_t&amp; other) const noexcept;
    constexpr bool operator!=(const width_t&amp; other) const noexcept;
    constexpr bool operator&lt;(const width_t&amp; other) const noexcept;
    constexpr bool operator&gt;(const width_t&amp; other) const noexcept;
    constexpr bool operator&lt;=(const width_t&amp; other) const noexcept;
    constexpr bool operator&gt;=(const width_t&amp; other) const noexcept;

    constexpr std::int16_t floor() const noexcept;
    constexpr std::int32_t ceil() const noexcept;
    constexpr std::int32_t round() const noexcept;

    constexpr width_t operator-() const noexcept;
    constexpr width_t operator+() const noexcept;
    constexpr width_t&amp; operator+=(width_t other) noexcept;
    constexpr width_t&amp; operator-=(width_t other) noexcept;
    constexpr width_t&amp; operator*=(std::int16_t m) noexcept;
    constexpr width_t&amp; operator/=(std::int16_t d) noexcept;
    constexpr width_t&amp; operator*=(width_t other) noexcept;
    constexpr width_t&amp; operator/=(width_t other) noexcept;

    constexpr std::int32_t underlying_value() const noexcept;
    constexpr static width_t from_underlying(std::int32_t) noexcept;

    constexpr static width_t max() noexcept; // maximum possible value
    constexpr static width_t min() noexcept; // minimum possible value

private:
    std::int32_t _underlying_value; // exposition only
};

constexpr width_max = width_t::max();
constexpr width_min = width_t::min();

constexpr bool operator==(width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator==(std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator!=(width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator!=(std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator&lt; (width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator&lt; (std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator&lt;=(width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator&lt;=(std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator&gt; (width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator&gt; (std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator&gt;=(width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator&gt;=(std::int16_t lhs, width_t rhs) noexcept;

constexpr width_t operator+(width_t lhs, width_t rhs) noexcept;
constexpr width_t operator+(std::int16_t lhs, width_t rhs) noexcept;
constexpr width_t operator+(width_t lhs, std::int16_t rhs) noexcept;
constexpr width_t operator-(width_t lhs, width_t rhs) noexcept;
constexpr width_t operator-(std::int16_t lhs, width_t rhs) noexcept;
constexpr width_t operator-(width_t lhs, std::int16_t rhs) noexcept;
constexpr width_t operator*(width_t lhs, width_t rhs) noexcept;
constexpr width_t operator*(std::int16_t lhs, width_t rhs) noexcept;
constexpr width_t operator*(width_t lhs, std::int16_t rhs) noexcept;
constexpr width_t operator/(width_t lhs, width_t rhs) noexcept;
constexpr width_t operator/(std::int16_t lhs, width_t rhs) noexcept;
constexpr width_t operator/(width_t lhs, std::int16_t rhs) noexcept;


constexpr width_t sat_add(width_t, width_t) noexcept;
constexpr width_t sat_add(width_t w, std::integral auto i) noexcept;
constexpr width_t sat_add(std::integral auto i, width_t w) noexcept;

constexpr width_t sat_sub(width_t, width_t) noexcept;
constexpr width_t sat_sub(width_t w, std::integral auto i) noexcept;
constexpr width_t sat_sub(std::integral auto i, width_t w) noexcept;

constexpr width_t sat_mul(width_t, width_t) noexcept;
constexpr width_t sat_mul(width_t w, std::integral auto i) noexcept;
constexpr width_t sat_mul(std::integral auto i, width_t w) noexcept;

constexpr /* integral type */ compare(width_t, width_t) noexcept;
constexpr /* integral type */ compare(width_t w, std::integral auto i) noexcept;
constexpr /* integral type */ compare(std::integral auto i, width_t w) noexcept;

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>to-do</em></p>
</div>
</div>
<div class="sect2">
<h3 id="width_literal">5.7. <code>width_t</code> literal <code>_w</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
namespace width_literal {

template &lt;char...C&gt;
constexpr <a href="#width_t">width_t</a> operator "" _w()

} // namespace width_literal
} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>The suffix <code>_w</code> can be aplied in floating-points literals in fixed notations as well
as integer literals.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">using namespace strf::width_literal;

strf::width_t x = 1.5_w;
x += 0.25_w;
x += 1_w;
assert(x == 2.75_w);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_requirements_of_printable_types">6. Requirements of printable types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section provides what one needs to be known to add a new printable type
or override an existing one.</p>
</div>
<div class="sect2">
<h3 id="Printable">6.1. Type requirement <em>Printable</em></h3>
<div class="paragraph">
<p>A type <code>T</code> is <em>Printable</em> if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>printable_def_of&lt;T&gt;</code> is defined and is a  <em><a href="#PrintableDef">PrintableDef</a></em> type</p>
</li>
<li>
<p><code>printable_def_of&lt;T&gt;::<a href="#PrintableDef_forwarded_type">forwarded_type</a></code> is implicitly convertible from <code>T</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="printable_def_of">6.2. Type alias template <code>printable_def_of</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

struct printable_tag;

template &lt;typename T&gt; struct printable_def;

template &lt;typename T&gt; using printable_def_of = /* see below... */;

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>printable_def_of&lt;T&gt;</code> is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>printable_def_of&lt;std::remove_cvref&lt;T&gt;&gt;</code>, if <code>T</code> is a reference type or has any cv-qualifier</p>
</li>
<li>
<p>otherwise, it is <code>PrintableDef</code>, when <code>T</code> is <code><a href="#value_and_format">value_and_format</a>&lt;PrintableDef, /*... */&gt;</code></p>
</li>
<li>
<p>otherwise, it is <code>printable_def&lt;T&gt;</code> if such template specialization is defined</p>
</li>
<li>
<p>otherwise, it is <code>decltype(get_printable_def(printable_tag{}, std::declval&lt;T&gt;()))</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="PrintableDef">6.3. Type requirement <em>PrintableDef</em></h3>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>T</code>, a <em>PrintableDef</em> type.</p>
</li>
<li>
<p><code>P</code>, a <em><a href="#Printable">Printable</a></em> type such that <code><a href="#printable_def_of">printable_def_of</a>&lt;P&gt;</code> is <code>T</code>.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_member_types">Member types</h4>
<div id="PrintableDef_representative" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">T::representative</code></pre>
</div>
</div>
<div class="paragraph">
<p>The type used as the template argument in <code><a href="#get_facet">get_facet</a></code>.
This means it is the type that is tested by the
the <em>UnaryTypeTrait</em> template argument passed to
<code><a href="#constrain">constrain</a></code> or <code><a href="#constrained_fpe">constrained_fpe</a></code>.</p>
</div>
<div class="paragraph">
<p><code>T::representative</code> is optional if <code>T</code> is an intance of <code>prinatable_def</code>.
When <code>prinatable_def&lt;R&gt;</code> does not define <code>representative</code>,
it assumed to be <code>R</code>.</p>
</div>
</div>
</div>
<div id="PrintableDef_forwarded_type" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">T::forwarded_type</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>forwarded_type</code> must be implicitly convertible from <code>P</code>,
and must be copy-constructible. And its copy-constructor should be fast.
( <code>forwarded_type</code> is usually <code>P</code> or <code>const P&amp;</code> )</p>
</div>
<div class="paragraph">
<p><code>forwarded_type</code> is used intead of <code>P</code> as the storage type in some
situations ( for example, the objects created by <code>fmt</code> and <code><a href="#join">join</a></code> ).</p>
</div>
</div>
</div>
<div id="PrintableDef_is_overridable" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">( Optional )</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">T::is_overridable</code></pre>
</div>
</div>
<div class="paragraph">
<p>A type alias to either <code>std::true_type</code> or <code>std::false_type</code>.
It influences the behavior of <code><a href="#make_printer">make_printer</a></code>.
Assumed to be <code>std::false_type</code> if not defined.</p>
</div>
</div>
</div>
<div id="PrintableDef_format_specifiers" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">( Optional )</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">T::format_specifiers</code></pre>
</div>
</div>
<div class="paragraph">
<p>A type alias to <code><a href="#tag">tag</a>&lt;F...&gt;</code>, where all types in <code>F...</code> satisfy
<em><a href="#FormatSpecifier">FormatSpecifier</a></em>.
It affects the return type of <code><a href="#fmt">fmt</a></code>.
Assumed to be <code><a href="#tag">tag</a>&lt;&gt;</code> if not defined.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="PrintableDef_functions">Member static function templates</h4>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>T</code>, a <em>PrintableDef</em> type.</p>
</li>
<li>
<p><code>CharT</code>, a character type</p>
</li>
<li>
<p><code>fpack</code>, a value of type <code><a href="#facets_pack">facets_pack</a>&lt;/*... */&gt;</code></p>
</li>
<li>
<p><code>pre</code>, a value of type <code><a href="#premeasurements">premeasurements</a>&lt;/*... */&gt;</code></p>
</li>
<li>
<p><code>dst</code>, an non-const lvalue reference of type <code><a href="destination_hpp.html#destination">destination</a>&lt;CharT&gt;</code></p>
</li>
<li>
<p><code>v</code>, a value of type <code>T::forwarded_type</code> or <code><a href="#value_and_format">value_and_format</a>&lt;T, F...&gt;</code>,
where <code>F...</code> is such that <code>T::format_specifiers</code> is an alias to <code><a href="#tag">tag</a>&lt;F...&gt;</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>At least one of the function templates below must be defined:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">( Optional )</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">T::print(dst, fpack, v);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return Type
</td>
<td class="hdlist2">
<p>void</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Prints <code>v</code> into <code>dst</code> taking into account the facets in <code>fpack</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">( Optional )</div>
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto c = T::make_printer(<a href="#tag">tag</a>&lt;CharT&gt;{}, pre, fpack, v);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>make_printer</code> function has two purposes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>to return a callable object <code>c</code> such that <code>c(dst)</code> prints <code>v</code> into <code>dst</code>
taking into account the facets in <code>fpack</code></p>
</li>
<li>
<p>To measure the size and/or width (or none, depeding on the type <code>pre</code> )
of the content that <code>c</code> prints when invoked.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>pre</code> acts as an output variable:
If <code>pre-&gt;<a href="#premeasurements">width_demanded</a></code> is <code>true</code>, then the width of content
that <code>c</code> prints shall be added to the <a href="#width_accumulator">accumulated_size</a> of <code>pre</code>.</p>
</div>
<div class="paragraph">
<p>If <code>pre-&gt;<a href="#premeasurements">size_demanded</a></code> is <code>true</code>, then the size of content that
<code>c</code> prints ( or a value greater than that ) shall be added into the
<a href="#size_accumulator">accumulated_size</a> of <code>pre</code>.</p>
</div>
<div class="paragraph">
<p><code>c(dst)</code> must not call <code>dst.recycle()</code>
if the value of <code>dst.space()</code> immediately before calling <code>c(dst)</code>
is greater than or equal to such calculated size.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="representative_of_printable">6.4. Type alias template <code>representative_of_printable</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename T&gt;
using representative_of_printable = /* see bellow */ ;

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Given <code><em>PDef</em></code>, the type <code><a href="#printable_def_of">printable_def_of</a>&lt;T&gt;</code>, <code>representative_of_printable&lt;T&gt;</code> is an alias to
<code>PDef::<a href="#PrintableDef_representative">representative</a></code>, assuming such
type member alias is defined.
Otherwise, it is <code><em>R</em></code>, if <code>PDef</code> is <code>printable_def&lt;R&gt;</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="is_printable_and_overridable">6.5. Variable template <code>is_printable_and_overridable</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename T&gt;
using is_printable_and_overridable = &#8230;&#8203; /*see below*/;

template &lt;typename T&gt;
constexpr bool is_printable_and_overridable_v = is_printable_and_overridable&lt;T&gt;::value;

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>is_printable_and_overridable&lt;T&gt;</code> is an alias to
<code><a href="#printable_def_of">printable_def_of</a>&lt;T&gt;::<a href="#PrintableDef_is_overridable">is_overridable</a></code>
if such type is defined, otherwise it is an alias to <code>std::false_type</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="forwarded_printable_type">6.6. Type alias template <code>forwarded_printable_type</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename T&gt;
using forwarded_printable_type = typename <a href="#printable_def_of">printable_def_of</a>&lt;T&gt;::<a href="#PrintableDef_forwarded_type">forwarded_type</a>;

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="printable_overrider_c">6.7. Template facet category <code>printable_overrider_c</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename R&gt;
struct printable_overrider_c {
    static constexpr bool constrainable = true;

    constexpr static <a href="#dont_override">dont_override</a>&lt;R&gt; get_default() noexcept {
        return {};
    }
};

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>The template parameter <code>R</code> shall be the same as the <code><a href="#representative_of_printable">representative_of_printable</a>&lt;P&gt;</code>,
where <code>P</code> the printable type to be overriden.</p>
</div>
</div>
<div class="sect2">
<h3 id="printable_overrider_c_of">6.8. Type alias <code>printable_overrider_c_of</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
template &lt;typename Printable&gt;
using printable_overrider_c_of =
    printable_overrider_c&lt; representative_of_printable&lt;Printable&gt; &gt;;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dont_override">6.9. Struct template <code>dont_override</code></h3>
<div class="paragraph">
<p><code>dont_override&lt;_T_&gt;</code> is the default facet of <code>printable_overrider_c&lt;_T&gt;</code> category.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename T&gt;
struct dont_override {
    using category = printable_overrider_c&lt;R&gt;;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="make_printer">6.10. Function template <code>make_printer</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename CharT, typename Pre, typename FPack, typename Arg&gt;
constexpr /*...*/ make_printer(Pre* pre, const FPack&amp; facets, const Arg&amp; arg);

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code><a href="#printable_def_of">printable_def_of</a>&lt;Arg&gt;::<a href="#PrintableDef_is_overridable">is_overridable</a>::value</code> is <code>true</code>,
<code>make_printer</code> returns</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#get_facet">get_facet</a>
    &lt; <a href="#printable_overrider_c">printable_overrider_c</a>&lt;<a href="#representative_of_printable">representative_of_printable</a>&lt;Arg&gt;&gt;
    , <a href="#representative_of_printable">representative_of_printable</a>&lt;Arg&gt; &gt;
    (facets)
    .make_printer(<a href="#tag">tag</a>&lt;CharT&gt;{}, pre, facets, arg);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otherwise, it returns</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">{printable_def  _of}&lt;Arg&gt;::make_printer(<a href="#tag">tag</a>&lt;CharT&gt;{}, pre, facets, arg)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="premeasurements">6.11. Class template <code>premeasurements</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

enum class width_presence: bool { no = false, yes = true };
enum class size_presence : bool { no = false, yes = true };

template &lt;size_presence SizePresence, width_presence WidthPresence&gt;
class premeasurements
    : public <a href="#size_accumulator">size_accumulator</a>&lt;static_cast&lt;bool&gt;(SizePresence)&gt;
    , public <a href="#width_accumulator">width_accumulator</a>&lt;static_cast&lt;bool&gt;(WidthPresence)&gt;
{
public:

    static constexpr bool size_demanded = static_cast&lt;bool&gt;(SizePresence);
    static constexpr bool width_demanded = static_cast&lt;bool&gt;(WidthPresence);
    static constexpr bool no_demands  = ! size_demanded &amp;&amp; ! width_demanded;
    static constexpr bool something_demanded = size_demanded || width_demanded;
    static constexpr bool size_and_width_demanded = size_demanded &amp;&amp; width_demanded;

    constexpr premeasurements() noexcept = default;
    constexpr explicit premeasurements(<a href="#width_t">width_t</a> initial_width) noexcept;

    ~premeasurements() = default;
};

} // namespace strf</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_constructors">Constructors</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr premeasurements() noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Default-construct each of the base classes.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr explicit premeasurements(<a href="#width_t">width_t</a> width_limit) noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirement</dt>
<dd>
<p><code>WidthPresence</code> is <code>width_presence::yes</code>, otherwise this constructor
does not participate in overload resolution.</p>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Initializes <code><a href="#width_accumulator">width_accumulator</a></code> base
with <code>width_limit</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="size_accumulator">6.12. Class template <code>size_accumulator</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
template &lt;bool Active&gt;
class size_accumulator
{
public:
    explicit constexpr size_accumulator() noexcept;
    explicit constexpr size_accumulator(std::integral auto initial_size) noexcept;

    constexpr void add_size(std::integral auto s) noexcept;

    constexpr std::ptrdiff_t accumulated_ssize() const noexcept;
    constexpr std::size_t accumulated_usize() const noexcept;
};
} // namespace strf</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_member_functions_2">Member functions</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">explicit constexpr size_accumulator() noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Postcondition</dt>
<dd>
<p><code>accumulated_ssize() == 0</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">explicit constexpr size_accumulator(std::integral auto initial_size) noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirement</dt>
<dd>
<p><code>Active</code> is <code>true</code>, otherwise this constructor
does not participate in overload resolution.</p>
</dd>
<dt class="hdlist1">Postcondition</dt>
<dd>
<p><code>accumulated_ssize() == initial_size &gt;= 0 ? initial_size : 0</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div id="size_accumulator_add_size" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr void add_size(std::integral auto s) noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">When <code>Active</code> is <code>false</code></dt>
<dd>
<p>None</p>
</dd>
<dt class="hdlist1">When <code>Active</code> is <code>true</code> </dt>
<dd>
<p>The internally stored size value ( that is returned by <code>accumulated_ssize()</code> ) is incremented by the value <code>(s &gt;= 0 ? s : 0)</code>.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="size_accumulator_accumulated_usize" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr std::size_t accumulated_usize() const noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">When <code>Active</code> is <code>false</code></dt>
<dd>
<p><code>0</code></p>
</dd>
<dt class="hdlist1">When <code>Active</code> is <code>true</code> </dt>
<dd>
<p>The internally stored size value.</p>
</dd>
</dl>
</div>
</div>
</div>
<div id="size_accumulator_accumulated_ssize" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr std::ptrdiff_t accumulated_ssize() const noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<p><code>static_cast&lt;std::ptrdiff_t&gt;(accumulated_usize())</code></p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="width_accumulator">6.13. Class template <code>width_accumulator</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
template &lt;bool Active&gt;
class width_accumulator
{
public:
    constexpr width_accumulator() noexcept;

    constexpr explicit width_accumulator(<a href="#width_t">width_t</a> width_limit) noexcept;

    constexpr void add_width(<a href="#width_t">width_t</a>) noexcept;

    constexpr void checked_add_width(<a href="#width_t">width_t</a>) noexcept;

    constexpr <a href="#width_t">width_t</a> accumlated_width() const noexcept;

    constexpr <a href="#width_t">width_t</a> remaining_width() const noexcept;

    constexpr bool has_remaining_width() const noexcept;

    constexpr bool remaining_width_greater_than(width_t w) const noexcept

    constexpr saturate_width(width_t w) noexcept;

private:
    width_t limit_ = width_max; // exposition-only
    width_t width_ = 0;         // exposition-only
}
} // namespace strf</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_member_functions_3">Member functions</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr explicit width_accumulator(<a href="#width_t">width_t</a> width_limit) noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requiment</dt>
<dd>
<p><code>Active</code> is <code>true</code>, otherwise this constructor
does not participate in overload resolution.</p>
</dd>
<dt class="hdlist1">Postcondition</dt>
<dd>
<p><code>remaining_width() == width_limit &gt; 0 ? width_limit : 0</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr width_accumulator() noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Postcondition</dt>
<dd>
<p><code>remaining_width() == (Active ? <a href="#width_t">width_max</a> : 0)</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr void  checked_add_width(<a href="#width_t">width_t</a> w) noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>None if <code>Active</code> is <code>false</code>, otherwise does</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">if (w &gt; 0 &amp;&amp; width_ &lt; limit_) {
    width_ = ( w &gt;= limit_ - width_
             ? limit_
             : width_ + w );
}</code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr void add_width(<a href="#width_t">width_t</a> w) noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>None if <code>Active</code> is <code>false</code>, otherwise does <code>width_ += w</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr width_t accumulated_width() noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<p><code>Active ? (width_ &#8656; limit_ ? width_ : limit_) : 0</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr width_t remaining_width() noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<p><code>Active ? (width_ &lt; limit_ ? limit_ - width_ : 0) : 0</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool has_remaining_width() noexcept;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<p><code>Active &amp;&amp; width_ &lt; limit_</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr bool remaining_width_greater_than(strf::width_t w) const noexcept</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return value</dt>
<dd>
<p><code>Active &amp;&amp; width_ + w &lt; limit_</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr saturate_width(width_t w) noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Effect: None if <code>Active</code> is <code>false</code>, otherwise do <code>width_ = limit_</code>
Postcondition:: <code>remaining_width() == 0</code></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="measure">6.14. Function template <code>measure</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt; typename CharT
         , <a href="#premeasurements">size_presence</a> SizePresence
         , <a href="#premeasurements">width_presence</a> WidthPresence
         , typename... FPE
         , typename... Args &gt;
void measure
    ( <a href="#premeasurements">premeasurements</a>&lt;SizePresence, WidthPresence&gt;* pre
    , const <a href="#facets_pack">facets_pack</a>&lt;FPE...&gt;&amp; facets
    , const Args&amp;... args );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Calculates the size and/or width of the result of printing the arguments <code>args...</code></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All types in <code>Args...</code> are <em><a href="#Printable">Printable</a></em></p>
</li>
<li>
<p>All types in <code>FPE...</code> are <em><a href="#FacetsPackElement">FacetsPackElement</a></em>
( since this is a requirement of <code><a href="#facets_pack">facets_pack</a></code> ).</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effects</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>When <code>SizePresence</code> is <code>size_presence::yes</code>, do the equivalent to the following
<a href="https://en.cppreference.com/w/cpp/language/fold">fold expression</a>:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">(..., <a href="#make_printer">make_printer</a>&lt;CharT&gt;(pre, facets, args) );</code></pre>
</div>
</div>
</li>
<li>
<p>When <code>WidthPresence</code> is <code>width_presence::yes</code> but <code>SizePresence</code> is <code>size_presence::no</code>,
do  <code><a href="#make_printer">make_printer</a>&lt;CharT&gt;(pre, facets, a)</code> for each argument  <code>a</code> in <code>args</code>
<code>pre-&gt;<a href="#width_accumulator">has_remaining_width</a>()</code> returns <code>false</code>.
This implies that not necessarily all arguments in <code>args...</code> are used.</p>
</li>
<li>
<p>Does nothing if <code>SizePresence</code> is <code>size_presence::no</code> and <code>WidthPresence</code> is <code>width_presence::no</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_facets_pack">7. facets_pack</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="facets_pack">7.1. Class template <code>facets_pack</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename ... FPE&gt;
class facets_pack;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p>All types in <code>FPE...</code> satisfy
<a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_member_functions_4">Member functions</h4>
<div class="sect4">
<h5 id="_constructors_2">Constructors</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr facets_pack(const facets_pack&amp; other) = default;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<p>Initializes each element in this object with the corresponding element in <code>other</code></p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>(std::is_copy_constructible_v&lt;FPE&gt; &amp;&amp; ...)</code> is <code>true</code>,
otherwise this constructor does not participate in overload resolution.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr facets_pack(facets_pack&amp;&amp; other) = default;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<p>Initializes each element from the
rvalue reference of the corresponding element in <code>other</code></p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>(std::is_move_constructible_v&lt;FPE&gt; &amp;&amp; ...)</code> is <code>true</code>, otherwise this
constructor does not participate in overload resolution.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr facets_pack() = default;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<p>Default-initializes each element</p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>(std::is_default_constructible_v&lt;FPE&gt; &amp;&amp; ...)</code> is <code>true</code>, otherwise this
constructor does not participate in overload resolution.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename... U&gt;
constexpr explicit facets_pack(U&amp;&amp;... u)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<p>Initializes each element with the corresponding value in <code>std::forward&lt;U&gt;(u)...</code>.</p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p>This constructor does not participate in overload resolution, unless the following conditions are met</p>
<div class="ulist">
<ul>
<li>
<p><code>sizeof...(U) != 0</code> is <code>true</code></p>
</li>
<li>
<p><code>sizeof...(U) == sizeof...(FPE)</code> is <code>true</code></p>
</li>
<li>
<p><code>( std::is_constructible_v&lt;FPE, U&gt; &amp;&amp; ... )</code> is <code>true</code></p>
</li>
<li>
<p>if <code>sizeof...(U) == 1</code> is <code>true</code>, then <code>std::<a href="https://en.cppreference.com/w/cpp/types/remove_cvref">remove_cvref_t</a>&lt;U&#8230;&#8203;&gt;</code> is not <code>facets_pack&lt;FPE&#8230;&#8203;.&gt;</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_assignment_operators_deleted">Assignment operators (deleted)</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">   facets_pack&amp; operator=(const facets_pack&amp;) = delete
   facets_pack&amp; operator=(facets_pack&amp;&amp;) = delete;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assignments are deleted because it is unclear what would be the correct
behavior when there is a reference type in <code>FPE...</code>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pack">7.2. Function template <code>pack</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename ... T&gt;
constexpr /* see below */ pack(const T&amp; ... args)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return type</dt>
<dd>
<p><code><a href="#facets_pack">facets_pack</a>&lt;std::remove_cvref_t&lt;T&gt;&gt;...&gt;</code></p>
</dd>
<dt class="hdlist1">Return value</dt>
<dd>
<p>A <code><a href="#facets_pack">facets_pack</a></code> object initialized with <code>std::forward&lt;T&gt;(args)...</code></p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="get_facet">7.3. Function template <code>get_facet</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename FCat, typename Tag, typename ... T&gt;
constexpr decltype(auto) get_facet(const facets_pack&lt;T...&gt;&amp; fp);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<p>If <a href="#has_facet"><code>has_facet&lt;FCat, Tag&gt;(fp)</code></a> returns <code>true</code> then
returns <code><a href="#do_get_facet">do_get_facet</a>&lt;FCat, Tag&gt;(fp)</code>, otherwise
return <code>FCat::get_default()</code>.</p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>FCat</code> is a <em><a href="#FacetCategory">FacetCategory</a></em> type.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="has_facet">7.4. Hypothetical function template <code>has_facet</code></h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This function template does not exist in this library.
       It is only documented to help to explain the
      <code><a href="#get_facet">get_facet</a></code> function template.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename FCat, typename Tag, typename FPE&gt;
constexpr bool has_facet(const FPE&amp; fpe)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>FPE</code> is an instance of <code><a href="#facets_pack">facets_pack</a></code>, then returns wheter there
is any elemente <code>elm</code> in <code>fpe</code> such that <code>has_facet&lt;FCat, Tag&gt;(elm)</code>
is <code>true</code>.</p>
</li>
<li>
<p>If <code>FPE</code> is an instance of <code><a href="#constrained_fpe">constrained_fpe</a>&lt;FPE, Filter&gt;</code>,
then returns <code>Filter&lt;Tag&gt;::value &amp;&amp; has_facet&lt;FCat, Tag&gt;(fpe.get())</code>.</p>
</li>
<li>
<p>If <code>FPE</code> is a  <a href="#Facet"><em>Facet</em></a> type, returns <code>std::is_same_v&lt;FCat, <a href="#facet_category">facet_category</a>&lt;FPE&gt;&gt;</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>FCat</code> is a <em><a href="#FacetCategory">FacetCategory</a></em> type.</p>
</li>
<li>
<p><code>FPE</code> satisfies <a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="do_get_facet">7.5. Hypothetical function template <code>do_get_facet</code></h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This function template is not part of the library.
      It is only documented to help to explain the
      <code><a href="#get_facet">get_facet</a></code> function template
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename FCat, typename Tag, typename FPE&gt;
constexpr decltype(auto) do_get_facet(const FPE&amp; fpe);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>FCat</code> satisfies <em><a href="#FacetCategory">FacetCategory</a></em>.</p>
</li>
<li>
<p><code>FPE</code> satisfies <a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</li>
<li>
<p><code>has_facet&lt;FCat, Tag&gt;(fpe)</code> is <code>true</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="constrained_fpe">7.6. Class template <code>constrained_fpe</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;template &lt;class&gt; class Filter, typename FPE&gt;
class constrained_fpe;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class template <code>constrained_fpe</code> is designed to be used in
<code><a href="#facets_pack">facets_pack</a></code>. <code>constrained_fpe&lt;Filter, FPE&gt;</code>
holds a value of <code>FPE</code> that will only be returned by
<code><a href="#get_facet">get_facet</a>&lt;Category, Tag&gt;</code> if <code>Filter&lt;Tag&gt;::value</code> is <code>true</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>Filter</code> is a <em><a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">UnaryTypeTrait</a></em>. For any type <code>T</code>, the expression
<code>Filter&lt;T&gt;::value</code> must be well-formed and convertible to <code>bool</code>.</p>
</li>
<li>
<p><code>FPE</code> satisfies <a href="#ConstrainableFacetsPackElement"><em>ConstrainableFacetsPackElement</em></a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_2">Synopsis</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;template &lt;class&gt; class Filter, typename FPE&gt;
class constrained_fpe
{
public:
    // <a href="#constrained_fpe_constructor">constructors</a>
    constexpr constrained_fpe(const constrained_fpe&amp;) = default;
    constexpr constrained_fpe(constrained_fpe&amp;&amp; other) = default;
    constexpr constrained_fpe() = default;

    template &lt;typename U&gt;
    constexpr constrained_fpe(U&amp;&amp;);

    // <a href="#constrained_fpe_element_access">element access</a>
    constexpr const FPE&amp; get() const;

private:
    FPE element; // exposition only;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_member_functions_5">Member functions</h4>
<div class="sect4">
<h5 id="constrained_fpe_constructor">Constructors</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr constrained_fpe(const constrained_fpe&amp; other);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Initializes the element of the <code>constrained_fpe</code> from
the const reference of the element of <code>other</code>.</p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>std::is_copy_constructible&lt;FPE&gt;::value</code> is <code>true</code>,
otherwise this constructor does not participate in overload resolution.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr constrained_fpe(constrained_fpe&amp;&amp; other);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Initializes the element of the <code>constrained_fpe</code> from
the rvalue reference of the element of <code>other</code>.</p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>std::is_move_constructible&lt;FPE&gt;::value</code> is <code>true</code>,
otherwise this constructor does not participate in overload resolution.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr constrained_fpe();</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Default-initializes <code>element</code>.</p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>std::is_default_constructible&lt;FPE&gt;::value</code> is <code>true</code>,
otherwise this constructor does not participate in overload resolution.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename U&gt;
constexpr explicit constrained_fpe(U&amp;&amp; arg);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Initializes element with <code>std::forward&lt;U&gt;(arg)</code>.</p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>std::is_constructible&lt;FPE, U&gt;::value</code> is <code>true</code>,
otherwise this constructor does not participate in overload resolution.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="constrained_fpe_element_access">Element access</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr const FPE&amp; get() const;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Return the stored element;</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="constrain">7.7. Function template <code>constrain</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;template &lt;class&gt; class Filter, typename T&gt;
constexpr constrained_fpe&lt;Filter, U&gt; constrain(const T&amp; arg);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>constrain</code> is just a syntatic sugar to create a <code><a href="#constrained_fpe">constrained_fpe</a></code> object.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return type</dt>
<dd>
<p><code>constrained_fpe&lt;Filter, U&gt;</code>, where <code>U</code> is
<code>std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;</code>.</p>
</dd>
<dt class="hdlist1">Return value</dt>
<dd>
<p><code>constrained_fpe&lt;Filter, U&gt;{ std::forward&lt;T&gt;(arg) }</code></p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>T</code> is such that <code>U</code> satisfies <a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="FacetsPackElement">7.8. Type requirement <em>FacetsPackElement</em></h3>
<div class="paragraph">
<p>A given type <code>F</code> satisfies <em>FacetsPackElement</em> if, and only if, one of the following conditions is true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>F</code> is a <a href="#Facet"><em>Facet</em></a> type.</p>
</li>
<li>
<p><code>F</code> is an instance of <code><a href="#facets_pack">facets_pack</a></code>.</p>
</li>
<li>
<p><code>F</code> is an instance of <code><a href="#constrained_fpe">constrained_fpe</a></code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="ConstrainableFacetsPackElement">7.9. Type requirement <em>ConstrainableFacetsPackElement</em></h3>
<div class="paragraph">
<p>A given a type <code>F</code> is a <em>ConstrainableFacetsPackElement</em> if, and only if,
one of the following conditions is true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>F</code> is a  <a href="#Facet"><em>Facet</em></a> type and  <code><a href="#facet_category">facet_category</a>&lt;F&gt;::constrainable</code> is <code>true</code>.</p>
</li>
<li>
<p><code>F</code> is <code><a href="#facets_pack">facets_pack</a>&lt;F2...&gt;</code> and all types in <code>F2...</code> are <em>ConstrainableFacetsPackElement</em>.</p>
</li>
<li>
<p><code>F</code> is an instance of <code><a href="#constrained_fpe">constrained_fpe</a></code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="Facet">7.10. Type requirement <em>Facet</em></h3>
<div class="paragraph">
<p>A given a type <code>F</code> satisfies <code>Facet</code> if all of the following conditions are met:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>F</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible"><em>MoveConstructible</em></a></p>
</li>
<li>
<p><code><a href="#facet_category">facet_category</a>&lt;F&gt;</code> satisfies the <em><a href="#FacetCategory">FacetCategory</a></em> requirements.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="FacetCategory">7.11. Type requirement <em>FacetCagory</em></h3>
<div class="paragraph">
<p>A given a type <code>FCat</code> satisfies <code>FacetCategory</code> if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FCat</code> has a static member function named <code>get_default</code> that takes
no argument and whose return type is either <code>F</code> or <code>const F&amp;</code>,
where <code>F</code> is a type that satisfies the requirements associated to
<code>FCat</code>.</p>
</li>
<li>
<p><code>FCat</code> has a member named <code>constrainable</code> that is a static constexpr
value convertible to <code>bool</code>. ( If this value is <code>false</code> then
the facets associated <code>FCat</code> can not be <a href="#constrained_fpe">constrained</a> ).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="facet_traits">7.12. Class template <code>facet_traits</code></h3>
<div class="paragraph">
<p>This class template provides the <a href="#Facet">Facet</a> informations.
If you create a new facet, you can either define such informations as
members of the facet, or specialize <code>facet_traits</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename F&gt;
class facet_traits
{
public:
    using category = /* Facet::category or void */;
};</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_public_members_4">Public members</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">typename /* */ category;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>Facet::category</code> if such member exist and is a type,
otherwise it is an alias to <code>void</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_specialization">Specialization</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename F&gt;
class facet_traits&lt;const F&gt;
{
public:
    using category = typename facet_traits&lt;F&gt;::category;
};</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="facet_category">7.13. Type alias <code>facet_category</code></h3>
<div class="paragraph">
<p><code>facet_category</code> is just a syntatic sugar:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename Facet&gt;
using facet_category = facet_traits&lt;Facet&gt;::typename category;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="destinators">8. Printing syntax</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code><a href="#printing_syntax">printing_syntax</a></code> class template implement the
functions availabe in the basic usage syntax of the library:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="syntax.svg" alt="syntax" width="660">
</div>
</div>
<div class="paragraph">
<p>The <em>target</em> is an expression that is or creates a <code>printing_syntax</code> object.
The header <code>&lt;strf.hpp&gt;</code> provides the following <em>target</em> expressions:</p>
</div>
<div class="exampleblock">
<div class="content">
<div id="to_char_ptr_range" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

<em>/* see below */</em> to(char8_t*  begin,  char8_t*  end);
<em>/* see below */</em> to(char*     begin,  char*     end);
<em>/* see below */</em> to(char16_t* begin,  char16_t* end);
<em>/* see below */</em> to(char32_t* begin,  char32_t* end);
<em>/* see below */</em> to(wchar_t*  begin,  wchar_t*  end);

} // namespace strf</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return type</dt>
<dd>
<p><code><a href="#printing_syntax">printing_syntax</a>&lt;DestCreator&gt;</code>, where <code>DestCreator</code>
is an implementation-defined type that satifies <em><a href="#DestinationCreator">DestinationCreator</a></em>.</p>
</dd>
<dt class="hdlist1">Return value</dt>
<dd>
<p>An object whose <code>DestCreator</code> object  <code>&#95;dest&#95;creator</code>
is such that <code>&#95;dest&#95;creator.create()</code> returns</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="destination_hpp.html#basic_cstr_destination">basic_cstr_destination</a>&lt;<em>char_type</em>&gt;{begin, end}</code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="to_char_ptr_count" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

<em>/* see below */</em> to(char8_t*  dest, std::size_t count);
<em>/* see below */</em> to(char*     dest, std::size_t count);
<em>/* see below */</em> to(char16_t* dest, std::size_t count);
<em>/* see below */</em> to(char32_t* dest, std::size_t count);
<em>/* see below */</em> to(wchar_t*  dest, std::size_t count);

} // namespace strf</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type and value
</td>
<td class="hdlist2">
<p>Same as of <code>to(dest, dest + count)</code>;</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="to_char_array" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template&lt;std::size_t N&gt; <em>/* see below */</em> to(char8_t  (&amp;dest)[N]);
template&lt;std::size_t N&gt; <em>/* see below */</em> to(char     (&amp;dest)[N]);
template&lt;std::size_t N&gt; <em>/* see below */</em> to(char16_t (&amp;dest)[N]);
template&lt;std::size_t N&gt; <em>/* see below */</em> to(char32_t (&amp;dest)[N]);
template&lt;std::size_t N&gt; <em>/* see below */</em> to(wchar_t  (&amp;dest)[N]);

} // namespace strf</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type and value
</td>
<td class="hdlist2">
<p>Same as of <code>to(dest, dest + N)</code>;</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="to_range" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
template &lt;typename CharT&gt;
<em>/* see below */</em> to_range(CharT* begin, CharT* end);

} // namespace strf</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Return type</dt>
<dd>
<p><code><a href="#printing_syntax">printing_syntax</a>&lt;DestCreator&gt;</code>, where <code>DestCreator</code>
is an implementation-defined type that satifies <em><a href="#DestinationCreator">DestinationCreator</a></em>.</p>
</dd>
<dt class="hdlist1">Return value</dt>
<dd>
<p>An object whose <code>DestCreator</code> object  <code>&#95;dest&#95;creator</code>
is such that <code>&#95;dest&#95;creator.create()</code> returns</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="destination_hpp.html#basic_char_array_writer">basic_char_array_writer</a>&lt;<em>char_type</em>&gt;{begin, end}</code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="to_range_array" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
template &lt;typename CharT, std::size_t N&gt;
<em>/* see below */</em> to_range(CharT (&amp;dest)[N]);

} // namespace strf</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type and value
</td>
<td class="hdlist2">
<p>Same as of <code>to_range(dest, dest + N)</code>;</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="to_range_count" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {
template &lt;typename CharT&gt;
<em>/* see below */</em> to_range(CharT* dest, std::size_t count);

} // namespace strf</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type and value
</td>
<td class="hdlist2">
<p>Same as of <code>to_range(dest, dest + count)</code>;</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="printing_syntax">8.1. Class template <code>printing_syntax</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt; typename DestCreator
         , typename ReservePolicy = no_reserve
         , typename... FPE&gt;
class printing_syntax;

}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>DestCreator</code> satisfy either <a href="#DestinationCreator">DestinationCreator</a> or <a href="#SizedDestinationCreator">SizedDestinationCreator</a>.</p>
</li>
<li>
<p><code>ReservePolicy</code> is <code>no_reserve</code>, <code>reserve_given_space</code> or <code>reserve_calc</code></p>
</li>
<li>
<p>All types in <code>FPE...</code> satisfy <a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_3">Synopsis</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

struct no_reserve {};

struct reserve_calc {};

struct reserve_given_space {
    constexpr explicit reserve_given_space(std::size_t s) : space(s) {}

    std::size_t space;
};

template &lt; typename DestCreator
         , typename ReservePolicy = no_reserve
         , typename... FPE&gt;
class printing_syntax
{
public:
    // constructors
    constexpr printing_syntax();
    constexpr explicit printing_syntax(const DestCreator&amp; dest_creator);
    constexpr explicit printing_syntax(DestCreator&amp;&amp; dest_creator);

    template &lt;typename... U&gt;
    constexpr printing_syntax
    ( const DestCreator&amp; dest_creator, ReservePolicy poli, U&amp;&amp;... fpes );

    template &lt;typename... U&gt;
    constexpr printing_syntax
    ( DestCreator&amp;&amp; dest_creator, ReservePolicy poli, U&amp;&amp;... fpes );

    // printing
    using return_type = /* ... */;

    return_type <a href="#printing_syntax_call_operator">operator()</a>(Args&amp;&amp; ... args) const;
    return_type <a href="#printing_syntax_line">line</a>(Args&amp;&amp;... args) const;
    return_type <a href="#printing_syntax_tr">tr</a>(Args&amp;&amp;... args) const;
    return_type <a href="#printing_syntax_trline">trline</a>(Args&amp;&amp;... args) const;

    // change reserve policy
    constexpr /* ... */ <a href="#printing_syntax_reserve">reserve</a>(std::integral auto capacity) /* ... */;
    constexpr /* ... */ <a href="#printing_syntax_reserve_calc">reserve_calc</a>() /* ... */;
    constexpr /* ... */ <a href="#printing_syntax_no_reserve">no_reserve</a>() /* ... */;


    // add facets
    template &lt;typename... U&gt;
    constexpr /* ... */ <a href="#printing_syntax_with">with</a>(U&amp;&amp;...) const &amp;;

    constexpr const printing_syntax&amp; with() const &amp;;
    constexpr const printing_syntax&amp; with() const &amp;&amp; ;
    constexpr printing_syntax&amp; with() &amp;;
    constexpr printing_syntax&amp;&amp; with() &amp;&amp;;


};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_member_types_2">Member types</h4>
<div id="printing_syntax_return_type" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">return_type</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>decltype(std::declval&lt;const typename DestCreator::destination_type&amp;&gt;().finish()</code>,
if such type is well-formed, otherwise <code>void</code></p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">char_type</code></pre>
</div>
</div>
<div class="paragraph">
<p>A type alias to <code>DestCreator::char_type</code></p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_constructors_3">Constructors</h4>
<div id="printing_syntax_default_ctor" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr printing_syntax() = default;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only participates in overload resolution if <code>DestCreator</code> and all types
in <code>FPE...</code> are default-constructible and <code>ReservePolicy</code> is not
<code>reserve_given_space</code>.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr printing_syntax(const DestCreator&amp; dest_creator)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<p>Initializes the inther <code>DestCreator</code> object with <code>dest_creator</code></p>
</dd>
<dt class="hdlist1">Compile time requirements</dt>
<dd>
<p>Only participates in overload resolution if <code>DestCreator</code>
is copy-constructible and all types in <code>FPE...</code> are
default-constructible and <code>ReservePolicy</code> is not
<code>reserve_given_space</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr printing_syntax(DestCreator&amp;&amp; dest_creator)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<p>Initializes the inther <code>DestCreator</code> object with <code>dest_creator</code></p>
</dd>
<dt class="hdlist1">Compile time requirements</dt>
<dd>
<p>Only participates in overload resolution if <code>DestCreator</code>
is move-constructible and all types in <code>FPE...</code> are
default-constructible and <code>ReservePolicy</code> is not
<code>reserve_given_space</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr printing_syntax(const DestCreator&amp; dest_creator, ReservePolicy poli, U&amp;&amp;... fpes)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializes the internal <code>DestCreator</code> object with <code>dest_creator</code>,</p>
</li>
<li>
<p>Initializes the internal <code>ReservePolicy</code> object  with <code>poli</code>,</p>
</li>
<li>
<p>Initializes the of the internal <code>FPE...</code> object with the correspoding value in <code>(U&amp;&amp;)fpes...</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Compile time requirements</dt>
<dd>
<p>Only participates in overload resolution if:</p>
<div class="ulist">
<ul>
<li>
<p><code>DestCreator</code> is copy-constructible</p>
</li>
<li>
<p>Each type in <code>FPE...</code> is constructible from the corresponding type in <code>U...</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr printing_syntax(DestCreator&amp;&amp; dest_creator, ReservePolicy poli, U&amp;&amp;... fpes</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializes the internal <code>DestCreator</code> object with <code>dest_creator</code>,</p>
</li>
<li>
<p>Initializes the internal <code>ReservePolicy</code> object  with <code>poli</code>,</p>
</li>
<li>
<p>Initializes the of the internal <code>FPE...</code> object with the correspoding value in <code>(U&amp;&amp;)fpes...</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Compile time requirements</dt>
<dd>
<p>Only participates in overload resolution if:</p>
<div class="ulist">
<ul>
<li>
<p><code>DestCreator</code> is move-constructible</p>
</li>
<li>
<p>Each type in <code>FPE...</code> is constructible from the corresponding type in <code>U...</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_member_functions_for_printing">Member functions for printing</h4>
<div id="printing_syntax_call_operator" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#printing_syntax_return_type">return_type</a> operator()(Args&amp;&amp;... args) const;</code></pre>
</div>
</div>
<details>
<summary class="title"><strong>Effect</strong></summary>
<div class="content">
<div class="paragraph">
<p>Executes the following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Distinguish the leading arguments in <code>args...</code> that specify facets,
from the remaining ones that specify values to be printed. Let the
first sub-list be here called <code>fargs...</code> and the second <code>pargs...</code></p>
</li>
<li>
<p>Create a <a href="#facets_pack">facets_pack</a> object from the the internal <code>FPE...</code> objects
and <code>fargs...</code>. Let it be here called <code>fpack</code>, an let its type be
<code>FPack</code> ( which is <code>facets_pack&lt;FPE..., std::remove_cvref_t&lt;decltype(fargs)&gt;...&gt;</code></p>
</li>
</ol>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">When <code>ReservePolicy</code> is <code>strf::reserve_given_space</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p>Let <code>dest_creator</code> be the internal <code>DestCreator</code> object, and <code>poli</code> be the internal <code>reserve_given_space</code> object. Do:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">using dest_type = typename DestCreator::sized_destination_type;
dest_type dest{dest&#95;creator.create(poli.space)};</code></pre>
</div>
</div>
</li>
<li>
<p>Print all arguments <code>pargs...</code> into <code>dest</code></p>
</li>
<li>
<p>Returns <code>dest.finish()</code> if such expression is valid</p>
</li>
</ol>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-none stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">When <code>ReservePolicy</code> is <code>strf::reserve_calc</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p>Do:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">using pre_type = <a href="#premeasurements">premeasurements</a>&lt;size_presence::yes, width_presence::no&gt;;
pre_type pre;</code></pre>
</div>
</div>
</li>
<li>
<p>For each <code>parg</code> in <code>pargs...</code>, do:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">auto printer = <a href="#make_printer">make_printer</a>&lt;char_type&gt;(&amp;pre, fpack, arg);</code></pre>
</div>
</div>
</li>
<li>
<p>Let <code>dest_creator</code> be the internal <code>DestCreator</code> object. Do:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">using dest_type = typename DestCreator::sized_destination_type;
dest_type dest{dest&#95;creator.create(pre.<a href="#size_accumulator_accumulated_ssize">accumulated_ssize</a>())};</code></pre>
</div>
</div>
</li>
<li>
<p>For each <code>printer</code>, do <code>printer(dest)</code></p>
</li>
<li>
<p>Return <code>dest.finish()</code> if such expression is valid.</p>
</li>
</ol>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-none stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">When <code>ReservePolicy</code> is <code>strf::no_reserve</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="olist arabic">
<ol class="arabic" start="3">
<li>
<p>Let <code>dest_creator</code> be the internal <code>DestCreator</code> object. Do:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">typename DestCreator::destination_type dest{dest&#95;creator.create()};</code></pre>
</div>
</div>
</li>
<li>
<p><code>Print all arguments `pargs...</code> into <code>dest</code></p>
</li>
<li>
<p>Return <code>dest.finish()</code> if such expression is valid.</p>
</li>
</ol>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</details>
</div>
</div>
<div id="printing_syntax_line" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#printing_syntax_return_type">return_type</a> line(Args&amp;&amp; ... args) const;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Equivalent to</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">return operator() ((Args&amp;&amp;)args..., (char_type)'\n');</code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="printing_syntax_tr" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#printing_syntax_return_type">return_type</a> tr(Args&amp;&amp;... args) const;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Equivalent to</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">return operator() ( (Facets&amp;&amp;)facets..., strf::<a href="#tr_string">tr</a>( (PArgs&amp;&amp;)pargs... ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>where:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Facets...</code> are the leading types in <code>Args...</code> are <em><a href="#FacetsPackElement">FacetsPackElement</a></em>s.</p>
</li>
<li>
<p><code>PArgs...</code> are the remaining types in <code>Args...</code>, and they are expected to be <em><a href="#Printable">Printable</a></em>.</p>
</li>
<li>
<p><code>facets...</code> are the arguments in <code>args...</code> that correspond to <code>Facets...</code></p>
</li>
<li>
<p><code>pargs...</code> are the remaining arguments in <code>args...</code> .</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div id="printing_syntax_trline" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp"><a href="#printing_syntax_return_type">return_type</a> trline(Args&amp;&amp; ... args) const;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Equivalent to</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">return operator() ( (Args&amp;&amp;)args..., (char_type)'\n' );</code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_member_functions_to_change_reserve_policy">Member functions to change Reserve Policy</h4>
<div id="printing_syntax_reserve" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr /* ... */  reserve(std::integral auto space) /* ... */;</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-rows stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">When <code>ReservePolicy</code> is <code>strf::reserve_given_space</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr       printing_syntax &amp;  reserve(std::integral auto space) &amp;;
constexpr       printing_syntax &amp;&amp; reserve(std::integral auto space) &amp;&amp;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Changes the space stored in the internal <code>strf::reserve_given_space</code> object,
and returns <code>*this</code> or <code>std::move(*this)</code>.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr printing_syntax reserve(std::integral auto space) const &amp;;
constexpr printing_syntax reserve(std::integral auto space) const &amp;&amp;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns a new <code>printing_syntax</code> whose internal <code>DestCreator</code> and <code>FPE...</code> objects
are copy-constructed or move-constructed ( depedending on the overload used )
from the internal <code>DestCreator</code> and <code>FPE...</code> objects of this object.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-none stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">When <code>ReservePolicy</code> is not <code>strf::reserve_calc</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr printing_syntax&lt;DestCreator, strf::reserve_calc, FPE...&gt;
reserve(std::integral auto space) const &amp;;

constexpr printing_syntax&lt;DestCreator, strf::reserve_calc, FPE...&gt;
reserve(std::integral auto space) &amp;&amp;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns a new <code>printing_syntax</code> whose internal <code>DestCreator</code> and <code>FPE...</code> objects
are copy-constructed or move-constructed ( depedending on the overload used )
from the internal <code>DestCreator</code> and <code>FPE...</code> objects of this object,
and the the internal <code>strf::reserve_calc</code> object is initialized with <code>space</code></p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="printing_syntax_reserve_calc" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr /* ... */  reserve_calc() /* ... */;</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-none stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">When <code>ReservePolicy</code> is <code>strf::reserve_calc</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr       printing_syntax &amp;  reserve_calc() &amp;;
constexpr const printing_syntax &amp;  reserve_calc() const &amp;;
constexpr       printing_syntax &amp;&amp; reserve_calc() &amp;&amp;;
constexpr const printing_syntax &amp;&amp; reserve_calc() const &amp;&amp;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just returns <code>*this</code> or <code>std::move(*this)</code></p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-none stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">When <code>ReservePolicy</code> is not <code>strf::reserve_calc</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr printing_syntax&lt;DestCreator, strf::reserve_calc, FPE...&gt;
reserve_calc() const &amp;;

constexpr printing_syntax&lt;DestCreator, strf::reserve_calc, FPE...&gt;
reserve_calc() &amp;&amp;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns a new <code>printing_syntax</code> whose internal <code>DestCreator</code> and <code>FPE...</code> objects
are copy-constructed or move-constructed ( depedending on the overload used )
from the internal <code>DestCreator</code> and <code>FPE...</code> objects of this object.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="printing_syntax_no_reserve" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr /* ... */  no_reserve() /* ... */;</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-none stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">When <code>ReservePolicy</code> is <code>strf::no_reserve</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr       printing_syntax &amp;  no_reserve() &amp;;
constexpr const printing_syntax &amp;  no_reserve() const &amp;;
constexpr       printing_syntax &amp;&amp; no_reserve() &amp;&amp;;
constexpr const printing_syntax &amp;&amp; no_reserve() const &amp;&amp;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just returns <code>*this</code> or <code>std::move(*this)</code>.</p>
</div></div></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-none stretch">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">When <code>ReservePolicy</code> is not <code>strf::no_reserve</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr printing_syntax&lt;DestCreator, strf::no_reserve, FPE...&gt; no_reserve() const &amp;;
constexpr printing_syntax&lt;DestCreator, strf::no_reserve, FPE...&gt; no_reserve() &amp;&amp;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns a new <code>printing_syntax</code> whose internal <code>DestCreator</code> and <code>FPE...</code> objects
are copy-constructed or move-constructed ( depedending on the overload used )
from the internal <code>DestCreator</code> and <code>FPE...</code> objects of this object.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_member_functions_to_add_facet_values">Member functions to add facet values</h4>
<div id="printing_syntax_with" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">template &lt;typename... U&gt;
constexpr /* ... */ with(U&amp;&amp;... fpes) const &amp;;

template &lt;typename... U&gt;
constexpr /* ... */ with(U&amp;&amp;... fpes) &amp;&amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>sizeof...(U)</code> is not zero, otherwise this overload does not participate in overload resolution.</p>
</li>
<li>
<p>All types in <code>std::remove_cvref_t&lt;U&gt;...</code> are <em><a href="#FacetsPackElement">FacetsPackElement</a></em></p>
</li>
<li>
<p>( In the <code>const &amp;&amp;</code> overload ) <code>DestCreator</code> and all types in <code>FPE...</code> are copy-constructible.</p>
</li>
<li>
<p>( In the <code>&amp;&amp;</code> overload ) <code>DestCreator</code> and all types in <code>FPE...</code> are move-constructible.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Return type</dt>
<dd>
<p><code>printing_syntax&lt;DestCreator, ReservePolicy, FPE..., std::remove_cvref_t&lt;U&gt;...&gt;</code></p>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Returns a new <code>printing_syntax</code> whose internal <code>DestCreator</code> and <code>FPE...</code> objects
are copy-constructed or move-constructed ( depedending on the overload used )
from the internal <code>DestCreator</code> and <code>FPE...</code> objects of this object.
and each the internal <code>std::remove_cvref_t&lt;U&gt;...</code> object is initialized with the
correspoding value in <code>(U&amp;&amp;)fpes...</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">constexpr const printing_syntax&amp; with() const &amp;;
constexpr const printing_syntax&amp; with() const &amp;&amp; ;
constexpr printing_syntax&amp; with() &amp;;
constexpr printing_syntax&amp;&amp; with() &amp;&amp;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just returns <code>*this</code> or <code>std::move(*this)</code></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="DestinationCreator">8.2. Type requirement <em>DestinationCreator</em></h3>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>char_type</code>, a character type</p>
</li>
<li>
<p><code>X</code>, an  <em>DestinationCreator</em> type for <code>char_type</code></p>
</li>
<li>
<p><code>x</code>, an expression of type <code>X</code> or <code>const X</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must hold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a></p>
</li>
<li>
<p><code>X</code> has a member type alias <code>X::char_type</code> defined as <code>char_type</code></p>
</li>
<li>
<p><code>X</code> has the <code>X::destination_type</code> that is a type alias to a concrete type that is derives
from <code><a href="destination_hpp.html#destination">destination</a>&lt;X::char_type&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And the following expression must be well-formed:</p>
</div>
<div id="DestinationCreator_create" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">typename X::destination_type{x.create()}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="SizedDestinationCreator">8.3. Type requirement <em>SizedDestinationCreator</em></h3>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>char_type</code>, a character type</p>
</li>
<li>
<p><code>size</code>, a value of the <code>std::size_t</code></p>
</li>
<li>
<p><code>X</code>, an  <em>SizedDestinationCreator</em> type for <code>char_type</code></p>
</li>
<li>
<p><code>x</code>, an expression of type <code>X</code> or <code>const X</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must hold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a></p>
</li>
<li>
<p><code>X</code> has a member type alias <code>T::char_type</code> defined as <code>char_type</code></p>
</li>
<li>
<p><code>X</code> has the <code>X::sized_destination_type</code> that is a type alias to a concrete type that derives
from <code>destination&lt;X::char_type&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And the following expression must be well-formed:</p>
</div>
<div id="SizedDestinationCreator_create" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">typename X::sized_destination_type{x.create(size)}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_miscellaneous">9. Miscellaneous</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="lettercase">9.1. The <code>lettercase</code> facet</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

enum class lettercase { lower = /*&#8230;&#8203;*/, mixed = /*&#8230;&#8203;*/, upper = /*&#8230;&#8203;*/ };

constexpr lettercase lowercase = lettercase::lower;
constexpr lettercase mixedcase = lettercase::mixed;
constexpr lettercase uppercase = lettercase::upper;

struct lettercase_c {
    static constexpr bool constrainable = true;
    constexpr static lettercase get_default() noexcept
    {
        return lettercase::lower;
    }
};

template &lt;&gt;
struct <a href="#facet_traits">facet_traits</a>&lt;lettercase&gt; {
    using category = lettercase_c;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_type_traits">9.2. Type traits</h3>
<div class="paragraph">
<p>The table below list class templates that satisfy
<a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">UnaryTypeTrait</a>.
They are created to be used in the <code>constrain</code> function template to filter
printable types.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_int_number</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">matches <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code> and the corresponding unsigned types</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_char</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">matches <code>char</code>, <code>char8_t</code>, <code>wchar_t</code>, <code>char16_t</code>, and <code>char32_t</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_string</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">matches strings.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><em>to-do</em></p>
</div>
</div>
<div class="sect2">
<h3 id="tag">9.3. Class template <code>tag</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="cpp">namespace strf {

template &lt;typename... &gt;
struct tag
{
    explicit tag() = default;
};

template &lt;typename T&gt;
struct tag&lt;T&gt;
{
    explicit constexpr tag() noexcept { }
    using type = T;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-03-30 15:40:12 -0400
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js"></script>
</body>
</html>